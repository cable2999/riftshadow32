act_comm.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
act_comm.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
act_comm.c:   if (ch->pcdata->confirm_delete)
act_comm.c:	    ch->pcdata->confirm_delete = FALSE;
act_comm.c:    	    sprintf( strsave, "%s%s.plr", PLAYER_DIR, capitalize( ch->name ) );
act_comm.c:	    ch->pause = 0;
act_comm.c:	    while (ch->affected) {
act_comm.c:	         affect_remove(ch,ch->affected);
act_comm.c:	cname	= palloc_string(ch->true_name);
act_comm.c: 	if( ((ch->played + (current_time - ch->logon)) / 3600) >= 15)
act_comm.c:    ch->pcdata->confirm_delete = TRUE;
act_comm.c:    if( ((ch->played + (current_time - ch->logon)) / 3600) >= 15) {
act_comm.c:    send_to_char("---------------------\n\r",ch);
act_comm.c:    if (!IS_SET(ch->comm,COMM_NOAUCTION))
act_comm.c:    if (!IS_SET(ch->comm,COMM_NOQUESTION))
act_comm.c:      if(!IS_SET(ch->comm,COMM_NOWIZ))
act_comm.c:    if (!IS_SET(ch->comm,COMM_DEAF))
act_comm.c:    if (IS_SET(ch->comm,COMM_QUIET))
act_comm.c:    if (IS_SET(ch->comm,COMM_SNOOP_PROOF))
act_comm.c:    if (ch->lines != PAGELEN)
act_comm.c:	if (ch->lines)
act_comm.c:	    sprintf(buf,"You display %d lines of scroll.\n\r",ch->lines+2);
act_comm.c:    if (IS_SET(ch->comm,COMM_NOTELL))
act_comm.c:    if (IS_SET(ch->comm,COMM_NOCHANNELS))
act_comm.c:    if (IS_SET(ch->comm,COMM_NOEMOTE))
act_comm.c:   if (IS_SET(ch->comm,COMM_DEAF))
act_comm.c:     REMOVE_BIT(ch->comm,COMM_DEAF);
act_comm.c:     SET_BIT(ch->comm,COMM_DEAF);
act_comm.c:    if (IS_SET(ch->comm,COMM_QUIET))
act_comm.c:      REMOVE_BIT(ch->comm,COMM_QUIET);
act_comm.c:     SET_BIT(ch->comm,COMM_QUIET);
act_comm.c:    if (!ch->pcdata->buffer->string || ch->pcdata->buffer->string[0] == '\0')
act_comm.c:    page_to_char(buf_string(ch->pcdata->buffer),ch);
act_comm.c:    clear_buf(ch->pcdata->buffer);
act_comm.c:	if (is_affected_area(ch->in_room->area,gsn_interference))
act_comm.c:    if (!is_cabal(ch) || cabal_table[ch->cabal].independent)
act_comm.c:      if (IS_SET(ch->comm,COMM_NOCABAL))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_NOCABAL);
act_comm.c:        SET_BIT(ch->comm,COMM_NOCABAL);
act_comm.c:    if (IS_SET(ch->in_room->room_flags, ROOM_SILENCE))
act_comm.c:        if (IS_SET(ch->comm,COMM_NOCHANNELS))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_NOCABAL);
act_comm.c:      if (IS_SET(ch->comm,COMM_ANSI)) {
act_comm.c:		cabal_table[ch->cabal].who_name, IS_NPC(ch) ? ch->short_descr : ch->true_name, get_char_color(ch,"channels"),
act_comm.c:		sprintf( buf, "%s%s: %s\n\r", cabal_table[ch->cabal].who_name,
act_comm.c:		IS_NPC(ch) ? ch->short_descr : ch->name, argument );
act_comm.c:    for ( d = descriptor_list; d != NULL; d = d->next )
act_comm.c:        if ( d->connected == CON_PLAYING &&
act_comm.c:             d->character != ch &&
act_comm.c:            ( ( is_same_cabal(ch,d->character) &&
act_comm.c:             !IS_SET(d->character->comm,COMM_NOCABAL)
act_comm.c:	     && !IS_SET(d->character->in_room->room_flags, ROOM_SILENCE))
act_comm.c:        || IS_SET(d->character->comm,COMM_ALL_CABALS) ) )
act_comm.c:	    if (IS_SET(d->character->comm,COMM_ANSI)) {
act_comm.c:		cabal_table[ch->cabal].who_name, !IS_NPC(ch) && can_see(d->character,ch) ? ch->true_name : PERS(ch,d->character),
act_comm.c:		get_char_color(d->character,"channels"), argument,
act_comm.c:			END_COLOR(d->character));
act_comm.c:            sprintf( buf, "%s%s: %s\n\r", cabal_table[ch->cabal].who_name,
act_comm.c:	    	!IS_NPC(ch) && can_see(d->character,ch) ? ch->true_name : PERS(ch,d->character), argument );
act_comm.c:	    send_to_char( buf, d->character );
act_comm.c:    if (IS_SET(ch->comm,COMM_ALL_CABALS))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_ALL_CABALS);
act_comm.c:        SET_BIT(ch->comm,COMM_ALL_CABALS);
act_comm.c:	trust = ch->level;
act_comm.c:	if(ch->level > 25 && !IS_IMMORTAL(ch) && !IS_SET(ch->act,PLR_HEROIMM))
act_comm.c:    		if (IS_SET(ch->comm,COMM_NONEWBIE))
act_comm.c:				REMOVE_BIT(ch->comm,COMM_NONEWBIE);
act_comm.c:				SET_BIT(ch->comm,COMM_NONEWBIE);
act_comm.c:    REMOVE_BIT(ch->comm,COMM_NONEWBIE);
act_comm.c:	if (IS_SET(ch->comm,COMM_ANSI)) 
act_comm.c:    for (wch = char_list; wch != NULL; wch = wch->next)
act_comm.c:		if (IS_NPC(wch) && wch->desc == NULL)
act_comm.c:		if ( (wch->level <= 25 && !IS_SET(wch->comm, COMM_NONEWBIE))
act_comm.c:				|| (IS_NPC(wch) && (wch->desc != NULL) && IS_IMMORTAL(wch->desc->original)))
act_comm.c:			if (IS_SET(wch->comm,COMM_ANSI))
act_comm.c:	trust = ch->level;
act_comm.c:	if(trust < 52 && !IS_SET(ch->act,PLR_HEROIMM))
act_comm.c:    		if (IS_SET(ch->comm,COMM_NOBUILDER))
act_comm.c:				REMOVE_BIT(ch->comm,COMM_NOBUILDER);
act_comm.c:				SET_BIT(ch->comm,COMM_NOBUILDER);
act_comm.c:    REMOVE_BIT(ch->comm,COMM_NOBUILDER);
act_comm.c:	if (IS_SET(ch->comm,COMM_ANSI)) 
act_comm.c:    for (wch = char_list; wch != NULL; wch = wch->next)
act_comm.c:		if (IS_NPC(wch) && wch->desc == NULL)
act_comm.c:		if ( ( IS_IMMORTAL(wch)) || IS_SET(wch->comm,COMM_BUILDER) || IS_HEROIMM(wch) ||
act_comm.c:			(IS_NPC(wch) && (wch->desc != NULL) && IS_IMMORTAL(wch->desc->original)) )
act_comm.c:			if (IS_SET(wch->comm,COMM_ANSI))
act_comm.c:    	if (IS_SET(ch->comm,COMM_NOWIZ)) {
act_comm.c:			REMOVE_BIT(ch->comm,COMM_NOWIZ);
act_comm.c:			SET_BIT(ch->comm,COMM_NOWIZ);
act_comm.c:    REMOVE_BIT(ch->comm,COMM_NOWIZ);
act_comm.c:    if (IS_SET(ch->comm,COMM_ANSI))
act_comm.c:    for (wch = char_list; wch != NULL; wch = wch->next)
act_comm.c:		if (IS_NPC(wch) && wch->desc == NULL)
act_comm.c:		if ( (IS_IMMORTAL(wch) || IS_SET(wch->comm,COMM_IMMORTAL) ||
act_comm.c:			(IS_NPC(wch) && (wch->desc != NULL) && IS_IMMORTAL(wch->desc->original))) &&
act_comm.c:			if (IS_SET(wch->comm,COMM_ANSI))
act_comm.c:	sn = -1;
act_comm.c:	if (sn == -1)
act_comm.c:	(*skill_table[sn].spell_fun) (sn,obj->level,ch,NULL,TAR_IGNORE);
act_comm.c:	for (o = buf; *i && (unsigned int)(o - buf) < sizeof(buf) - 1; i++, o++)
act_comm.c:	for (o = lowbuf; *i && (unsigned int)(o - lowbuf) < sizeof(lowbuf)-1; i++, o++)
act_comm.c:	if (IS_SET(ch->in_room->room_flags, ROOM_SILENCE))
act_comm.c:	if (!str_cmp(ch->name,"Karsus") && strstr(argument,"eing")
act_comm.c:	if ( argument[strlen(argument) - 1] == '!')
act_comm.c:	else if (argument[strlen(argument) - 1] == '?')
act_comm.c:    for ( victim = ch->in_room->people; victim != NULL; victim = victim->next_in_room )
act_comm.c:				if (is_affected(victim,gsn_word_of_command) && strstr(argument,victim->pcdata->command[0]))
act_comm.c:	if(IS_SET(ch->in_room->progtypes, RPROG_SPEECH))
act_comm.c:		(ch->in_room->rprogs->speech_prog) (ch->in_room, ch, argument);
act_comm.c:  for (room_char = ch->in_room->people; room_char != NULL;
act_comm.c:         room_char = room_char->next_in_room)
act_comm.c:      if (IS_SET(room_char->progtypes,MPROG_SPEECH) && room_char != ch) {
act_comm.c:        (room_char->pIndexData->mprogs->speech_prog) (room_char,ch,argument);
act_comm.c:		&& (ch->Class()->name == "anti-paladin"))
act_comm.c:	for (char_obj = ch->carrying; char_obj != NULL;
act_comm.c:		char_obj = char_obj->next_content)
act_comm.c:		if (IS_SET(char_obj->progtypes,IPROG_SPEECH) && char_obj->pIndexData->iprogs)
act_comm.c:			(char_obj->pIndexData->iprogs->speech_prog) (char_obj,ch,argument);
act_comm.c:	for (char_obj = ch->in_room->contents; char_obj != NULL;
act_comm.c:		char_obj = char_obj->next_content)
act_comm.c:		if (IS_SET(char_obj->progtypes,IPROG_SPEECH) && char_obj->pIndexData->iprogs)
act_comm.c:			(char_obj->pIndexData->iprogs->speech_prog) (char_obj,ch,argument);
act_comm.c:	if (IS_SET(ch->in_room->room_flags, ROOM_SILENCE))
act_comm.c:	if ( argument[strlen(argument) - 1] == '!')
act_comm.c:	else if (argument[strlen(argument) - 1] == '?')
act_comm.c:			if (is_affected(victim,gsn_word_of_command) && strstr(argument,victim->pcdata->command[0]))
act_comm.c:	if(is_affected(ch,gsn_silence) || IS_SET(ch->in_room->room_flags, ROOM_SILENCE))
act_comm.c:	if(IS_SET(ch->in_room->progtypes, RPROG_SPEECH))
act_comm.c:		(ch->in_room->rprogs->speech_prog) (ch->in_room, ch, argument);
act_comm.c:	for ( victim = ch->in_room->people; victim != NULL; victim = victim->next_in_room )
act_comm.c:				if (IS_SET(victim->progtypes,MPROG_SPEECH) && victim != ch)
act_comm.c:					(victim->pIndexData->mprogs->speech_prog) (victim,ch,argument);
act_comm.c:				if (is_affected(victim,gsn_word_of_command) && strstr(argument,victim->pcdata->command[0]))
act_comm.c:		&& (ch->Class()->name == "anti-paladin"))
act_comm.c:		|| IS_SET(ch->in_room->room_flags, ROOM_SILENCE))
act_comm.c:		length = strlen(ch->name);
act_comm.c:		length = strlen(ch->short_descr);
act_comm.c:	for (victim = ch->in_room->people; victim; victim = victim->next_in_room ) {
act_comm.c:				if (is_affected(victim,gsn_word_of_command) && strstr(argument,victim->pcdata->command[0]))
act_comm.c:    if ( IS_SET(ch->comm, COMM_NOCHANNELS) )
act_comm.c:    sprintf(buf,"%s: %s [%d] is PRAYing for: %s\n", log_time(), ch->true_name, ch->in_room->vnum,argument);
act_comm.c:    for ( d = descriptor_list; d != NULL; d = d->next )
act_comm.c:	victim = d->original ? d->original : d->character;
act_comm.c:	if ( d->connected == CON_PLAYING &&
act_comm.c:	     d->character != ch &&
act_comm.c:	     !IS_SET(victim->comm, COMM_SHOUTSOFF) &&
act_comm.c:	     !IS_SET(victim->comm, COMM_QUIET) &&
act_comm.c:	     victim->level >= 52 )
act_comm.c:		get_char_color(victim,"prays"),ch->true_name,ch->in_room->vnum,argument,END_COLOR(victim));
act_comm.c:	    send_to_char(buf,d->character);
act_comm.c:    if (IS_SET(ch->comm, COMM_NOTELL) || IS_SET(ch->comm,COMM_DEAF))
act_comm.c:    if ( IS_SET(ch->comm, COMM_QUIET) )
act_comm.c:    if (IS_SET(ch->comm,COMM_DEAF))
act_comm.c:	if (is_affected_area(ch->in_room->area,gsn_interference))
act_comm.c:     * -- Furey
act_comm.c:    for (victim = char_list; victim != NULL; victim = victim->next)
act_comm.c:	if (is_name(victim->name,arg)
act_comm.c:	&& (IS_NPC(victim) && victim->pIndexData->vnum == MOB_VNUM_DECOY))
act_comm.c:	if (victim->in_room == NULL || (IS_IMMORTAL(ch) ? !is_name(arg,(victim->true_name ? victim->true_name : victim->name)):
act_comm.c:			!is_name(arg,victim->name)) || !can_see( ch,victim ))
act_comm.c:    if (victim == NULL || ( IS_NPC(victim) && victim->in_room != ch->in_room ) )
act_comm.c:    if (IS_SET(ch->in_room->room_flags, ROOM_SILENCE) || IS_SET(victim->in_room->room_flags,ROOM_SILENCE))
act_comm.c:    if ( victim->desc == NULL && !IS_NPC(victim))
act_comm.c:        add_buf(victim->pcdata->buffer,buf);
act_comm.c:    if ( !(IS_IMMORTAL(ch) && ch->level > LEVEL_IMMORTAL) && (!IS_AWAKE(victim)  ||
act_comm.c:    if ((IS_SET(victim->comm,COMM_QUIET) || IS_SET(victim->comm,COMM_DEAF))
act_comm.c:	if (IS_SET(victim->progtypes,MPROG_SPEECH) && victim != ch)
act_comm.c:		(victim->pIndexData->mprogs->speech_prog) (victim,ch,argument);
act_comm.c:	if (is_affected(victim,gsn_word_of_command) && strstr(argument,victim->pcdata->command[0]))
act_comm.c:    victim->reply	= ch;
act_comm.c:	for(vch = char_list; vch; vch = vch->next)
act_comm.c:		if(!IS_NPC(vch) && vch->reply == ch)
act_comm.c:			vch->reply = NULL;
act_comm.c:    if ( IS_SET(ch->comm, COMM_NOTELL) )
act_comm.c:    if ( ( victim = ch->reply ) == NULL )
act_comm.c:    if ( victim->desc == NULL && !IS_NPC(victim) && !IS_SWITCHED(victim) && victim->pcdata)
act_comm.c:        add_buf(victim->pcdata->buffer,buf);
act_comm.c:    if ((IS_SET(victim->comm,COMM_QUIET) || IS_SET(victim->comm,COMM_DEAF))
act_comm.c:	if (IS_SET(victim->progtypes,MPROG_SPEECH) && victim != ch)
act_comm.c:		(victim->pIndexData->mprogs->speech_prog) (victim,ch,argument);
act_comm.c:	victim->reply	= ch;
act_comm.c:    if ( IS_SET(ch->comm, COMM_NOSHOUT) || (IS_SHIFTED(ch) && !IS_IMMORTAL(ch)))
act_comm.c:	if (!str_cmp(ch->name,"Karsus") && strstr(argument,"eing")
act_comm.c:    if (IS_SET(ch->comm,COMM_ANSI))
act_comm.c:    for ( d = descriptor_list; d != NULL; d = d->next )
act_comm.c:	if ( d->connected == CON_PLAYING
act_comm.c:	&&   d->character != ch
act_comm.c:	&&   d->character->in_room != NULL
act_comm.c:	&&   d->character->in_room->area == ch->in_room->area
act_comm.c:        &&   !IS_SET(d->character->comm,COMM_QUIET) )
act_comm.c:		if (IS_SET(d->character->in_room->room_flags, ROOM_SILENCE))
act_comm.c:		if(!IS_AWAKE(d->character))
act_comm.c:        sprintf(buf,"$n yells '%s$t%s'",get_char_color(d->character,"yells"),END_COLOR(d->character));
act_comm.c:	    act_new(buf,ch,argument,d->character,TO_VICT, POS_SLEEPING);
act_comm.c:		if (is_affected(d->character,gsn_word_of_command) && strstr(argument,d->character->pcdata->command[0]))
act_comm.c:			command_execute(d->character);
act_comm.c:        for (d = descriptor_list; d; d = d->next)
act_comm.c:                if (d->connected == CON_PLAYING
act_comm.c:                &&  d->character->in_room != NULL && ch->in_room != NULL
act_comm.c:                &&  d->character->in_room->area == ch->in_room->area
act_comm.c:				&&  d->character != ch
act_comm.c:				&&  !IS_SET(d->character->in_room->room_flags, ROOM_SILENCE))
act_comm.c:                        send_to_char(form_table[ch->pcdata->shifted].yell,d->character);
act_comm.c:                        send_to_char("\n\r",d->character);
act_comm.c:	if (ch->invis_level >= LEVEL_HERO)
act_comm.c:	if(ch && ch->in_room && attacker && can_see(ch,attacker))
act_comm.c:		if(IS_SET(ch->in_room->area->progtypes, APROG_MYELL))
act_comm.c:			((ch->in_room->area->aprogs->myell_prog) (ch->in_room->area, attacker, ch));
act_comm.c:	if ( !IS_NPC(ch) && IS_SET(ch->comm, COMM_NOEMOTE) )
act_comm.c:    if ( !IS_NPC(ch) && IS_SET(ch->comm, COMM_NOEMOTE) )
act_comm.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
act_comm.c:	if (vch->desc == NULL || vch == ch)
act_comm.c:	if ((letter = strstr(argument,vch->name)) == NULL)
act_comm.c:	temp[strlen(argument) - strlen(letter)] = '\0';
act_comm.c: 	name = vch->name;
act_comm.c:	    if (*letter == '\'' && matches == strlen(vch->name))
act_comm.c:	    if (*letter == 's' && matches == strlen(vch->name))
act_comm.c: 	    if (matches == strlen(vch->name))
act_comm.c:		if (matches == strlen(vch->name))
act_comm.c:		    name = vch->name;
act_comm.c:	    name = vch->name;
act_comm.c: * 											-El
act_comm.c:		sprintf(buf,"%s is %sING: ",ch->name,type);
act_comm.c:    if (!autoq && ch->position == POS_FIGHTING)
act_comm.c:    if (!autoq && ch->position  < POS_STUNNED)
act_comm.c:    if (!autoq && ch->pause > 0 && !IS_IMMORTAL(ch))
act_comm.c:	if(!autoq && !IS_SET(ch->in_room->room_flags,ROOM_LAW)
act_comm.c:		&& ch->in_room->cabal==0 && !IS_IMMORTAL(ch))
act_comm.c:	if (!autoq && ch->in_room->cabal != 0 && !IS_IMMORTAL(ch))
act_comm.c:        if (ch->in_room->cabal != ch->cabal)
act_comm.c:			obj_next = obj->next;
act_comm.c:				if (obj->carried_by != NULL && obj->carried_by == ch)
act_comm.c:			bug("Trying to autoquit char %s with pending queue.", ch->name);
act_comm.c:    if (ch->cabal != 0 && ch->pcdata->host)
act_comm.c:		ch->true_name, !IS_SET(ch->comm, COMM_NOSOCKET) ? ch->pcdata->host : "",
act_comm.c:		autoq ? "auto" : "", ((current_time - ch->logon) / 60),
act_comm.c:		obj_next = obj->next;
act_comm.c:			if (obj->carried_by != NULL && obj->carried_by == ch)
act_comm.c:		} else if (obj->pIndexData->limtotal != 0 && ch->level < 10)
act_comm.c:			if (obj->carried_by == ch)
act_comm.c:		wch_next = wch->next;
act_comm.c:		if (wch->defending!= NULL && wch->defending == ch)
act_comm.c:			wch->defending  =  NULL;
act_comm.c:			for(laf = wch->affected; laf != NULL; laf = laf->next)
act_comm.c:				if(laf->type == gsn_empathy)
act_comm.c:			if(laf->owner == ch)
act_comm.c:		if (IS_NPC(wch) && IS_AFFECTED(wch,AFF_CHARM) && wch->master==ch && IS_SET(wch->act,ACT_UNDEAD))
act_comm.c:		if ((wch->pIndexData->vnum == MOB_VNUM_DECOY || wch->pIndexData->vnum == MOB_VNUM_SHADOW)
act_comm.c:			&& is_name(ch->name,wch->name))
act_comm.c:    id = ch->id;
act_comm.c:    d = ch->desc;
act_comm.c:	d_next = d->next;
act_comm.c:	tch = d->original ? d->original : d->character;
act_comm.c:	if (tch && tch->id == id)
act_comm.c:    ch->pcdata->save_timer = 2;
act_comm.c:    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master != NULL )
act_comm.c:	act( "But you'd rather follow $N!", ch, NULL, ch->master, TO_CHAR );
act_comm.c:	if ( ch->master == NULL )
act_comm.c:    if (!IS_NPC(victim) && IS_SET(victim->act,PLR_NOFOLLOW) && /*!IS_IMMORTAL(ch) && */
act_comm.c:    REMOVE_BIT(ch->act,PLR_NOFOLLOW);
act_comm.c:    if ( ch->master != NULL )
act_comm.c:    if ( ch->master != NULL )
act_comm.c:	bug( "Add_follower: non-null master.", 0 );
act_comm.c:    ch->master        = master;
act_comm.c:    ch->leader        = NULL;
act_comm.c:	if((chance = get_skill(ch, gsn_trail))>0 && IS_SET(master->act,PLR_NOFOLLOW))
act_comm.c:			af.level = ch->level;
act_comm.c:			af.duration  = -1;
act_comm.c:    if ( ch->master == NULL )
act_comm.c:		REMOVE_BIT( ch->affected_by, AFF_CHARM );
act_comm.c:    if ( can_see( ch->master, ch ) && ch->in_room != NULL && !(IS_NPC(ch) && ch->pIndexData->vnum == MOB_VNUM_ANCHOR))
act_comm.c:		act( "$n stops following you.",     ch, NULL, ch->master, TO_VICT    );
act_comm.c:    	act( "You stop following $N.",      ch, NULL, ch->master, TO_CHAR    );
act_comm.c:    if (ch->master->pet == ch)
act_comm.c:	ch->master->pet = NULL;
act_comm.c:    ch->master = NULL;
act_comm.c:    ch->leader = NULL;
act_comm.c:    if ((pet = ch->pet) != NULL)
act_comm.c:    	if (pet->in_room != NULL)
act_comm.c:    ch->pet = NULL;
act_comm.c:    if ( ch->master != NULL )
act_comm.c:    	if (ch->master->pet == ch)
act_comm.c:    	    ch->master->pet = NULL;
act_comm.c:    ch->leader = NULL;
act_comm.c:		fch_next = fch->next;
act_comm.c:		/*if(!fch->in_room && IS_NPC(fch))
act_comm.c:			bug("Error: Mob %d in room is NULL!",fch->pIndexData->vnum);
act_comm.c:			if  (fch->master == ch)
act_comm.c:				REMOVE_BIT(fch->affected_by,AFF_CHARM);
act_comm.c:			if ( fch->master == ch && !is_affected(fch, gsn_trail) )
act_comm.c:			if ( fch->leader == ch && !is_affected(fch, gsn_trail) )
act_comm.c:	    		fch->leader = fch;
act_comm.c:		if (!IS_AFFECTED(victim, AFF_CHARM) || victim->master != ch
act_comm.c:		||  (IS_IMMORTAL(victim) && victim->trust >= ch->trust))
act_comm.c:    for ( och = ch->in_room->people; och != NULL; och = och_next )
act_comm.c:		och_next = och->next_in_room;
act_comm.c:		&&   och->master == ch
act_comm.c:		if(IS_NPC(och) && och->pIndexData->vnum == ACADEMY_PET)
act_comm.c:	leader = (ch->leader != NULL) ? ch->leader : ch;
act_comm.c:	for ( gch = char_list; gch != NULL; gch = gch->next )
act_comm.c:				exp_tnl = (gch->level * exp_per_level(gch) - gch->exp);
act_comm.c:				epl = pc_race_table[gch->race].xpadd + 1500;
act_comm.c:				epl += (int)((gch->level - 2) * epl * 0.08);
act_comm.c:				exp_ltl = (gch->level * exp_per_level(gch) - (gch->level - 1) * epl);
act_comm.c:                "[%2d %s] %-32s %3d%%hp %3d%%mana %3d%%mv %3d%%tnl\n\r",
act_comm.c:                    gch->level,
act_comm.c:                    IS_NPC(gch) ? "Mob" : gch->Class()->who_name,
act_comm.c:	(gch->max_hit == 0) ? 0 : (gch->hit*100)/gch->max_hit,
act_comm.c:	(gch->max_mana == 0) ? 0 :
act_comm.c:                    (gch->mana*100)/gch->max_mana,
act_comm.c:	(gch->max_move == 0) ? 0 :
act_comm.c:                    (gch->move*100)/gch->max_move,
act_comm.c:                "[Minion] %-32s %3d%%hp %3d%%mana %3d%%mv\n\r",
act_comm.c:	(gch->max_hit == 0) ? 0 : (gch->hit*100)/gch->max_hit,
act_comm.c:	(gch->max_mana == 0) ? 0 : (gch->mana*100)/gch->max_mana,
act_comm.c:	(gch->max_move == 0) ? 0 : (gch->move*100)/gch->max_move);
act_comm.c:    if ( ch->master != NULL || ( ch->leader != NULL && ch->leader != ch ) )
act_comm.c:    if ( victim->master != ch && ch != victim )
act_comm.c:	victim->leader = NULL;
act_comm.c:    victim->leader = ch;
act_comm.c:		&& ch->Class()->name == "anti-paladin"
act_comm.c:		&& ch->pcdata->learned[gsn_traitors_luck] > 1) {
act_comm.c:		af.level		=	ch->level;
act_comm.c:		af.duration		=	-1;
act_comm.c:		&& victim->Class()->name == "anti-paladin"
act_comm.c:		&& victim->pcdata->learned[gsn_traitors_luck] > 1) {
act_comm.c:		af.level		=	ch->level;
act_comm.c:		af.duration		=	-1;
act_comm.c:		for (vch = char_list; vch; vch = vch->next)
act_comm.c:    if ( ch->gold <  amount_gold)
act_comm.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
act_comm.c:    ch->gold 	-= amount_gold;
act_comm.c:    ch->gold 	+= share_gold + extra_gold;
act_comm.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
act_comm.c:	    gch->gold += share_gold;
act_comm.c:	if (is_affected_area(ch->in_room->area,gsn_interference))	
act_comm.c:    if ( IS_SET( ch->comm, COMM_NOTELL ) )
act_comm.c:    for ( gch = char_list; gch != NULL; gch = gch->next )
act_comm.c:	if (!mob->speech)
act_comm.c:	for (speech = mob->speech; speech; speech = speech->next) {
act_comm.c:		if (!str_cmp(speech->name,name)) {
act_comm.c:	if (!speech || !speech->first_line || !mob || !mob->in_room)
act_comm.c:	if (speech->first_line != speech->current_line)
act_comm.c:	if (!speech || !speech->first_line || !mob || !mob->in_room)
act_comm.c:	if (mob->position < POS_RESTING)
act_comm.c:	if ((line = speech->current_line) == NULL) {
act_comm.c:		speech->current_line = speech->first_line;
act_comm.c:	copy = palloc_string(line->text);
act_comm.c:				strcat(buf,ch->name);
act_comm.c:				i += (strlen(ch->name) - 1);
act_comm.c:				point--;
act_comm.c:	switch(line->type) {
act_comm.c:			sprintf(buf,"%s %s",ch->name,buf);
act_comm.c:			return bug ("Error in speech -- missing/invalid type.",0);
act_comm.c:	if (!line->next) {
act_comm.c:		speech->current_line = speech->first_line;
act_comm.c:	speech->current_line = line->next;
act_comm.c:	if (speech->current_line->delay <= 0) {
act_comm.c:	RS.Queue.AddToQueue(speech->current_line->delay, 3, speech_handler, ch, mob, speech);
act_comm.c:/*    if ( ( ach->level - bch->level > 8 || ach->level - bch->level < -8 ) && !IS_NPC(ach) )
act_comm.c:    if ( ach->leader != NULL ) ach = ach->leader;
act_comm.c:    if ( bch->leader != NULL ) bch = bch->leader;
act_comm.c:    || victim->master != ch)
act_comm.c:	deltype == 1 ? "DELETED" : deltype == 2 ? "CON-DIE" : deltype == 3 ? "OLD-AGE" : deltype == 4 ? "AUTODELETE" : "DELETED",
act_comm.c:	ch->level,
act_comm.c:	pc_race_table[ch->race].who_name,
act_comm.c:	(RSTR)ch->Class()->who_name,
act_comm.c:	cabal_table[ch->cabal].who_name,
act_comm.c:	ch->true_name,
act_comm.c:	IS_NPC(ch) ? "" : ch->pcdata->title,
act_comm.c:	IS_NPC(ch) ? "" : (ch->pcdata->extitle) ? ch->pcdata->extitle : "",
act_comm.c:	ch->pcdata->kills[PK_KILLS],
act_comm.c:	ch->pcdata->killed[PK_KILLED],
act_comm.c:	(int) (ch->played + current_time - ch->logon) / 3600,
act_comm.c:	if ( IS_NPC(killer) && (killer->master != NULL))
act_comm.c:		killer = killer->master;
act_comm.c:		killer->true_name, killer->cabal, dead->true_name, dead->cabal, log_time(), escape_string(dead->in_room->name), dead->in_room->vnum, current_time);
act_comm.c:	if (!IS_NPC(killer) || IS_NPC(dead) || !IS_EXPLORE(killer->in_room)) {
act_comm.c:		dead->true_name,
act_comm.c:		killer->short_descr,
act_comm.c:		killer->in_room->area->name,
act_comm.c:		killer->in_room->name,
act_comm.c:	if(!ch->pcdata->host && !ch->desc)
act_comm.c:	if(IS_SET(ch->comm, COMM_NOSOCKET))
act_comm.c:	escape = (char *) ((ch->pcdata->host) ? escape_string(ch->pcdata->host) : escape_string(ch->desc->host));
act_comm.c:		ch->true_name,
act_comm.c:		type == 2 ? ((current_time - ch->logon) / 60) : -1,
act_comm.c:		type > 0 ? count_carried(ch,FALSE) : -1,
act_comm.c:		type > 0 ? count_carried(ch,TRUE) : -1,
act_ente.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
act_ente.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
act_ente.c:   	&&   !IS_SET(room->room_flags, ROOM_PRIVATE)
act_ente.c:  	&&   !IS_SET(room->room_flags, ROOM_SOLITARY)
act_ente.c:	&&   !IS_SET(room->room_flags, ROOM_SAFE)
act_ente.c:	&&	 !IS_SET(room->room_flags, ROOM_HEROES_ONLY)
act_ente.c:	&&	 !IS_SET(room->room_flags, ROOM_GODS_ONLY)
act_ente.c:	&&   !IS_SET(room->room_flags, ROOM_NO_GATE)) {
act_ente.c:				if (!(IS_SET(ch->act,ACT_AGGRESSIVE) &&
act_ente.c:					!IS_SET(room->room_flags,ROOM_LAW)))
act_ente.c:    if ( ch->fighting != NULL )
act_ente.c:        old_room = ch->in_room;
act_ente.c:	portal = get_obj_list( ch, argument,  ch->in_room->contents );
act_ente.c:	if (portal->item_type != ITEM_PORTAL
act_ente.c:        ||  (IS_SET_OLD(portal->value[1],EX_CLOSED) && !IS_TRUSTED(ch,ANGEL)))
act_ente.c:	if (!IS_TRUSTED(ch,ANGEL) && !IS_SET_OLD(portal->value[2],GATE_NOCURSE)
act_ente.c:	||   IS_SET(old_room->room_flags,ROOM_NO_RECALL)))
act_ente.c:	if (IS_SET_OLD(portal->value[2],GATE_RANDOM) || portal->value[3] == -1 ||
act_ente.c:		(IS_SET_OLD(portal->value[2],GATE_BUGGY) && number_percent() < 5))
act_ente.c:		spell_teleport(skill_lookup("teleport"),ch->level,ch,ch,TAR_CHAR_SELF);
act_ente.c:            location = get_room_index(portal->value[3]);
act_ente.c:        if (IS_NPC(ch) && IS_SET(ch->act,ACT_AGGRESSIVE)
act_ente.c:        &&  IS_SET(location->room_flags,ROOM_LAW))
act_ente.c:	if (IS_SET_OLD(portal->value[2],GATE_NORMAL_EXIT))
act_ente.c:	if (IS_SET_OLD(portal->value[2],GATE_GOWITH)) /* take the gate along */
act_ente.c:	if (IS_SET_OLD(portal->value[2],GATE_NORMAL_EXIT))
act_ente.c:	if (portal->value[0] > 0)
act_ente.c:	    portal->value[0]--;
act_ente.c:        for (fch = to_room->people; fch != NULL; fch = fch_next)
act_ente.c:                fch_next = fch->next_in_room;
act_ente.c:	        for (obj = fch->carrying; obj != NULL; obj = obj->next_content)
act_ente.c:                	if (IS_SET(obj->progtypes,IPROG_GREET))
act_ente.c:                        	(obj->pIndexData->iprogs->greet_prog) (obj,ch);
act_ente.c:      		if (IS_NPC(fch) && IS_SET(fch->progtypes,MPROG_GREET))
act_ente.c:        		(fch->pIndexData->mprogs->greet_prog) (fch,ch);
act_ente.c:        for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
act_ente.c:                if (IS_SET(obj->progtypes,IPROG_ENTRY))
act_ente.c:                        (obj->pIndexData->iprogs->entry_prog) (obj);
act_ente.c:        if (IS_SET(to_room->progtypes, RPROG_ENTRY))
act_ente.c:                (to_room->rprogs->entry_prog) (to_room, ch);
act_ente.c:    	for ( fch = old_room->people; fch != NULL; fch = fch_next )
act_ente.c:            fch_next = fch->next_in_room;
act_ente.c:            if (portal == NULL || portal->value[0] == 0)
act_ente.c:            if ( fch->master == ch && IS_AFFECTED(fch,AFF_CHARM)
act_ente.c:            &&   fch->position < POS_STANDING)
act_ente.c:            if ( fch->master == ch && fch->position == POS_STANDING)
act_ente.c:                if (IS_SET(ch->in_room->room_flags,ROOM_LAW)
act_ente.c:                &&  (IS_NPC(fch) && IS_SET(fch->act,ACT_AGGRESSIVE)))
act_ente.c: 	if (portal != NULL && portal->value[0] == 0)
act_ente.c:	    if (ch->in_room == old_room)
act_ente.c:	    else if (old_room->people != NULL)
act_ente.c:		    old_room->people,portal,NULL,TO_CHAR);
act_ente.c:		    old_room->people,portal,NULL,TO_ROOM);
act_info.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
act_info.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
act_info.c:    if ((fShort && (obj->short_descr == NULL || obj->short_descr[0] == '\0'))
act_info.c:    ||  (obj->description == NULL || obj->description[0] == '\0'))
act_info.c:		for (oaf = obj->affected; oaf != NULL; oaf = oaf->next)
act_info.c:			if(oaf->type == gsn_stash)
act_info.c:		sprintf( buf, "(Stashed by %s) ", oaf->owner->name);
act_info.c:	if ( obj->short_descr != NULL )
act_info.c:	    strcat( buf, obj->short_descr );
act_info.c:	if ( obj->description != NULL)
act_info.c:	    strcat( buf, obj->description );
act_info.c:    if ( ch->desc == NULL )
act_info.c:    line = ch->lines;
act_info.c:    for ( obj = list; obj != NULL; obj = obj->next_content )
act_info.c:    ch->lines = 0;
act_info.c:    for ( obj = list; obj != NULL; obj = obj->next_content )
act_info.c:		if(IS_SET(obj->extra_flags, ITEM_NOSHOW) && !IS_IMMORTAL(ch))
act_info.c:		if ( obj->wear_loc == WEAR_NONE && can_see_obj( ch, obj ))
act_info.c:	    	if ( IS_NPC(ch) || IS_SET(ch->comm, COMM_COMBINE) )
act_info.c:				for ( iShow = nShow - 1; iShow >= 0; iShow-- )
act_info.c:		if ( IS_NPC(ch) || IS_SET(ch->comm, COMM_COMBINE) )
act_info.c:		if ( IS_NPC(ch) || IS_SET(ch->comm, COMM_COMBINE) )
act_info.c:    ch->lines = line;
act_info.c:	if ( IS_SET(victim->comm,COMM_AFK     )   ) strcat( buf, "[AFK] "        );
act_info.c:	if (victim->ghost)
act_info.c:    if ( victim->invis_level >= LEVEL_HERO    ) strcat( buf, "(Wizi) "	     );
act_info.c:    if ( IS_AFFECTED(victim, AFF_CHARM) && (!IS_NPC(victim) || victim->pIndexData->vnum != 80)) strcat( buf, "(Charmed) "    );
act_info.c:		for (af = victim->affected; af; af = af->next)
act_info.c:			if (af->aftype == AFT_SPELL)
act_info.c:		if(IS_SET(victim->act, ACT_NOCTURNAL))
act_info.c:		&& ((af = affect_find(victim->affected,gsn_creeping_tomb)) != NULL)
act_info.c:		&& af->duration <= 2)					strcat (buf, "(Entombed) ");
act_info.c:	if (!IS_NPC(victim) && victim->pcdata->energy_state == -5)	strcat(buf, "(Frozen) ");
act_info.c:	   (str_cmp(victim->long_descr,"") && victim->long_descr[0]!='\0')) && 
act_info.c:	strcat(buf,victim->long_descr);
act_info.c:    if ( !IS_NPC(victim) && !IS_SET(ch->comm, COMM_BRIEF))
act_info.c:	strcat( buf, victim->pcdata->title );
act_info.c:    switch ( victim->position )
act_info.c:	if (victim->on != NULL)
act_info.c:	    if (IS_SET_OLD(victim->on->value[2], SLEEP_AT))
act_info.c:		    victim->on->short_descr);
act_info.c:	    else if (IS_SET_OLD(victim->on->value[2], SLEEP_ON))
act_info.c:		    victim->on->short_descr);
act_info.c:		    victim->on->short_descr);
act_info.c:        if (victim->on != NULL)
act_info.c:            if (IS_SET_OLD(victim->on->value[2],REST_AT))
act_info.c:                    victim->on->short_descr);
act_info.c:            else if (IS_SET_OLD(victim->on->value[2],REST_ON))
act_info.c:                    victim->on->short_descr);
act_info.c:	    else if (IS_SET_OLD(victim->on->value[2],LOUNGE_ON))
act_info.c:		    victim->on->short_descr);
act_info.c:                    victim->on->short_descr);
act_info.c:        if (victim->on != NULL)
act_info.c:            if (IS_SET_OLD(victim->on->value[2],SIT_AT))
act_info.c:                    victim->on->short_descr);
act_info.c:            else if (IS_SET_OLD(victim->on->value[2],SIT_ON))
act_info.c:                    victim->on->short_descr);
act_info.c:                    victim->on->short_descr);
act_info.c:	if (victim->on != NULL)
act_info.c:	    if (IS_SET_OLD(victim->on->value[2], STAND_AT))
act_info.c:		    victim->on->short_descr);
act_info.c:	    else if (IS_SET_OLD(victim->on->value[2],STAND_ON))
act_info.c:		   victim->on->short_descr);
act_info.c:		    victim->on->short_descr);
act_info.c:	if ( victim->fighting == NULL )
act_info.c:	else if ( victim->fighting == ch )
act_info.c:	else if ( victim->in_room == victim->fighting->in_room )
act_info.c:	    strcat( buf, PERS( victim->fighting, ch ) );
act_info.c:    if ( victim->description[0] != '\0' )
act_info.c:		send_to_char( victim->description, ch );
act_info.c:    if ( victim->max_hit > 0 )
act_info.c:		percent = ( 100 * victim->hit ) / victim->max_hit;
act_info.c:		percent = -1;
act_info.c:			(victim->pcdata->beauty == 1 ||
act_info.c:			 victim->pcdata->beauty == 3 ||
act_info.c:			 victim->pcdata->beauty == 4) ? "n" : "",
act_info.c:			(victim->sex == 2) ? beauty_table[victim->pcdata->beauty].female : beauty_table[victim->pcdata->beauty].male,
act_info.c:			sex_table[victim->sex].name,
act_info.c:			pc_race_table[victim->race].name,
act_info.c:			(!str_cmp(pc_race_table[victim->race].name,"celestial")
act_info.c:			 	|| !str_cmp(pc_race_table[victim->race].name,"planar")
act_info.c:				|| !str_cmp(pc_race_table[victim->race].name,"abyss")) ?
act_info.c:		sprintf(buf,"%s$E is hovering in mid-air!%s",get_char_color(ch,"white"),END_COLOR(ch));
act_info.c:		for (paf = victim->affected; paf; paf = paf->next)
act_info.c:			if (paf->type == gsn_rotating_ward)
act_info.c:			for(tObj = victim->carrying; tObj; tObj = tObj->next_content)
act_info.c:			if(tObj->wear_loc == WEAR_COSMETIC)
act_info.c:				for(worn_over = victim->carrying; worn_over; worn_over = worn_over->next_content)
act_info.c:					if(worn_over != tObj && IS_SET(tObj->extra_flags, ITEM_UNDER_CLOTHES) && is_worn(worn_over))
act_info.c:						if(worn_over->wear_flags[0] + pow(2, ITEM_WEAR_COSMETIC) == tObj->wear_flags[0])
act_info.c:				sprintf(buf2,"%s>",tObj->wear_loc_name ? tObj->wear_loc_name : "bug: unset wear_loc on cosmetic");
act_info.c:				sprintf(buf, "<worn %-14s",buf2);
act_info.c:	&& victim->cabal == CABAL_HORDE
act_info.c:	&& belt->pIndexData->vnum == OBJ_VNUM_TROPHY_BELT
act_info.c:	&& victim->pcdata->trophy && belt->value[4] >= 1)
act_info.c:		placeholder = victim->pcdata->trophy;
act_info.c:		send_to_char(belt->extra_descr->description,ch);
act_info.c:		for (counter = 1; counter <= belt->value[4];counter++)
act_info.c:					victim->pcdata->trophy->victname);
act_info.c:			if (counter >= belt->value[4])
act_info.c:			if (!victim->pcdata->trophy->next) 
act_info.c:			victim->pcdata->trophy = victim->pcdata->trophy->next;
act_info.c:		victim->pcdata->trophy = placeholder;
act_info.c:		show_list_to_char( victim->carrying, ch, TRUE, TRUE );
act_info.c:			if (victim->gold <= 0) {
act_info.c:			} else if (victim->gold < 10) {
act_info.c:			} else if (victim->gold < 100) {
act_info.c:			} else if (victim->gold < 1000) {
act_info.c:			} else if (victim->gold < 10000) {
act_info.c:			} else if (victim->gold < 100000) {
act_info.c:    if ( victim->max_hit > 0 )
act_info.c:	percent = ( 100 * victim->hit ) / victim->max_hit;
act_info.c:	percent = -1;
act_info.c:			(victim->pcdata->beauty == 1 ||
act_info.c:			 victim->pcdata->beauty == 3 ||
act_info.c:			 victim->pcdata->beauty == 4) ? "n" : "",
act_info.c:			(victim->sex == 2) ? beauty_table[victim->pcdata->beauty].female : beauty_table[victim->pcdata->beauty].male,
act_info.c:			sex_table[victim->sex].name,
act_info.c:			pc_race_table[victim->race].name);
act_info.c:	sprintf(buf,"%s %s", victim->name, get_battle_condition(victim, percent));
act_info.c:	show_list_to_char( victim->carrying, ch, TRUE, TRUE );
act_info.c:    if ( victim->description[0] != '\0' )
act_info.c:	send_to_char( victim->description, ch );
act_info.c:    if ( victim->max_hit > 0 )
act_info.c:	percent = ( 100 * victim->hit ) / victim->max_hit;
act_info.c:	percent = -1;
act_info.c:			(victim->pcdata->beauty == 1 ||
act_info.c:			 victim->pcdata->beauty == 3 ||
act_info.c:			 victim->pcdata->beauty == 4) ? "n" : "",
act_info.c:			(victim->sex == 2) ? beauty_table[victim->pcdata->beauty].female : beauty_table[victim->pcdata->beauty].male,
act_info.c:			sex_table[victim->sex].name,
act_info.c:			pc_race_table[victim->race].name);
act_info.c:	sprintf(buf,"%s %s", victim->name, get_battle_condition(victim, percent));
act_info.c:    for ( rch = list; rch != NULL; rch = rch->next_in_room )
act_info.c:	if ( get_trust(ch) < rch->invis_level)
act_info.c:	if (IS_NPC(rch) && IS_SET(rch->act, ACT_WARD_MOB))
act_info.c:    if (!IS_NPC(ch) && IS_SET(ch->act,PLR_HOLYLIGHT))
act_info.c:	if ( is_affected_area(ch->in_room->area, gsn_whiteout) &&
act_info.c:		for (paf = ch->in_room->area->affected;paf;paf = paf->next) {
act_info.c:			if (paf->type == gsn_whiteout)	break;
act_info.c:		if (paf->owner != ch) {
act_info.c:	if (ch->lines == 0)
act_info.c:		    ch->lines + 2);
act_info.c:        ch->lines = 0;
act_info.c:    ch->lines = lines - 2;
act_info.c:	sprintf(buf,"%-12s",social_table[iSocial].name);
act_info.c:    send_to_char("---------------------\n\r",ch);
act_info.c:    if (IS_SET(ch->act,PLR_AUTOABORT))
act_info.c:    if (IS_SET(ch->act,PLR_AUTOASSIST))
act_info.c:    if (IS_SET(ch->act,PLR_AUTOEXIT))
act_info.c:    if (IS_SET(ch->act,PLR_AUTOGOLD))
act_info.c:    if (IS_SET(ch->act,PLR_AUTOLOOT))
act_info.c:    if (IS_SET(ch->act,PLR_AUTOSAC))
act_info.c:    if (IS_SET(ch->act,PLR_AUTOSPLIT))
act_info.c:    if (IS_SET(ch->comm,COMM_COMPACT))
act_info.c:    if (IS_SET(ch->comm,COMM_PROMPT))
act_info.c:    if (IS_SET(ch->comm,COMM_ANSI))
act_info.c:    if (IS_SET(ch->comm,COMM_COMBINE))
act_info.c:    if (IS_SET(ch->act,PLR_NOSUMMON))
act_info.c:    if (IS_SET(ch->act,PLR_NOFOLLOW))
act_info.c:    if(IS_SET(ch->comm,COMM_ANSI))
act_info.c:        REMOVE_BIT(ch->comm,COMM_ANSI);
act_info.c:        SET_BIT(ch->comm,COMM_ANSI);
act_info.c:	sprintf(buf,"%i) %-20s (currently %s%s%s)\n\r",i+1,capitalize(color_event[i].event_name),
act_info.c:	get_char_color(ch,ch->pcdata->color_scheme[i]), ch->pcdata->color_scheme[i],END_COLOR(ch));
act_info.c:    sprintf(buf,"Your color is %s.  Use color TOGGLE to switch color on/off.\n\r",IS_SET(ch->comm,COMM_ANSI) ? "ON" : "OFF");
act_info.c:    ch->pcdata->color_scheme[eventnum] = get_color_name(arg2);
act_info.c:    if (IS_SET(ch->act,PLR_AUTOABORT))
act_info.c:      REMOVE_BIT(ch->act,PLR_AUTOABORT);
act_info.c:      SET_BIT(ch->act,PLR_AUTOABORT);
act_info.c:    if (IS_SET(ch->act,PLR_AUTOASSIST))
act_info.c:      REMOVE_BIT(ch->act,PLR_AUTOASSIST);
act_info.c:      SET_BIT(ch->act,PLR_AUTOASSIST);
act_info.c:    if (IS_SET(ch->act,PLR_AUTOEXIT))
act_info.c:      REMOVE_BIT(ch->act,PLR_AUTOEXIT);
act_info.c:      SET_BIT(ch->act,PLR_AUTOEXIT);
act_info.c:    if (IS_SET(ch->act,PLR_AUTOGOLD))
act_info.c:      REMOVE_BIT(ch->act,PLR_AUTOGOLD);
act_info.c:      SET_BIT(ch->act,PLR_AUTOGOLD);
act_info.c:    if (IS_SET(ch->act,PLR_AUTOLOOT))
act_info.c:      REMOVE_BIT(ch->act,PLR_AUTOLOOT);
act_info.c:      SET_BIT(ch->act,PLR_AUTOLOOT);
act_info.c:    if (IS_SET(ch->act,PLR_AUTOSAC))
act_info.c:      REMOVE_BIT(ch->act,PLR_AUTOSAC);
act_info.c:      SET_BIT(ch->act,PLR_AUTOSAC);
act_info.c:    if (IS_SET(ch->act,PLR_AUTOSPLIT))
act_info.c:      REMOVE_BIT(ch->act,PLR_AUTOSPLIT);
act_info.c:      SET_BIT(ch->act,PLR_AUTOSPLIT);
act_info.c:    if (IS_SET(ch->comm,COMM_BRIEF))
act_info.c:      REMOVE_BIT(ch->comm,COMM_BRIEF);
act_info.c:      SET_BIT(ch->comm,COMM_BRIEF);
act_info.c:    if (IS_SET(ch->comm,COMM_COMPACT))
act_info.c:      REMOVE_BIT(ch->comm,COMM_COMPACT);
act_info.c:      SET_BIT(ch->comm,COMM_COMPACT);
act_info.c:    if (IS_SET(ch->comm,COMM_SHOW_AFFECTS))
act_info.c:      REMOVE_BIT(ch->comm,COMM_SHOW_AFFECTS);
act_info.c:      SET_BIT(ch->comm,COMM_SHOW_AFFECTS);
act_info.c:	send_to_char("%L: Lag Status (+ is lagged, and - is not)\n\r", ch);
act_info.c:	if (IS_SET(ch->comm,COMM_PROMPT))
act_info.c:      	    REMOVE_BIT(ch->comm,COMM_PROMPT);
act_info.c:      	    SET_BIT(ch->comm,COMM_PROMPT);
act_info.c:   free_pstring( ch->prompt );
act_info.c:   ch->prompt = palloc_string( buf );
act_info.c:   sprintf(buf,"Your prompt is now set to %s.\n\r",ch->prompt );
act_info.c:    if (IS_SET(ch->comm,COMM_COMBINE))
act_info.c:      REMOVE_BIT(ch->comm,COMM_COMBINE);
act_info.c:      SET_BIT(ch->comm,COMM_COMBINE);
act_info.c:    if (IS_SET(ch->act,PLR_CANLOOT))
act_info.c:      REMOVE_BIT(ch->act,PLR_CANLOOT);
act_info.c:      SET_BIT(ch->act,PLR_CANLOOT);
act_info.c:    if (IS_SET(ch->act,PLR_NOFOLLOW))
act_info.c:      REMOVE_BIT(ch->act,PLR_NOFOLLOW);
act_info.c:      SET_BIT(ch->act,PLR_NOFOLLOW);
act_info.c:      if (IS_SET(ch->imm_flags,IMM_SUMMON))
act_info.c:	REMOVE_BIT(ch->imm_flags,IMM_SUMMON);
act_info.c:	SET_BIT(ch->imm_flags,IMM_SUMMON);
act_info.c:      if (IS_SET(ch->act,PLR_NOSUMMON))
act_info.c:        REMOVE_BIT(ch->act,PLR_NOSUMMON);
act_info.c:        SET_BIT(ch->act,PLR_NOSUMMON);
act_info.c:    if ( ch->desc == NULL )
act_info.c:    if ( ch->position < POS_SLEEPING )
act_info.c:    if ( ch->position == POS_SLEEPING )
act_info.c:    if ( ch->desc == NULL )
act_info.c:    if ( ch->position < POS_SLEEPING )
act_info.c:    if ( ch->position == POS_SLEEPING )
act_info.c:	switch(obj->item_type)
act_info.c:    if ( ch->desc == NULL )
act_info.c:    if ( ch->position < POS_SLEEPING )
act_info.c:    if ( ch->position == POS_SLEEPING )
act_info.c:    	&&   !IS_SET(ch->act, PLR_HOLYLIGHT)
act_info.c:    	&&   room_is_dark( ch->in_room )
act_info.c:		show_char_to_char( ch->in_room->people, ch );
act_info.c:		sprintf(buf,ch->in_room->name);
act_info.c:		if (IS_IMMORTAL(ch) && (IS_NPC(ch) || IS_SET(ch->act,PLR_HOLYLIGHT)))
act_info.c:	    	sprintf(buf," [Room %d]",ch->in_room->vnum);
act_info.c:			for(victim = ch->in_room->people; victim; victim = victim->next_in_room)
act_info.c:				if(IS_NPC(victim) && IS_SET(victim->act, ACT_WARD_MOB))
act_info.c:	|| ( !IS_NPC(ch) && !IS_SET(ch->comm, COMM_BRIEF) )) && !is_affected(ch,gsn_plasma_arc) && (get_bv_stage(ch) < 2))
act_info.c:	    send_to_char( ch->in_room->description, ch );
act_info.c:    if ( (IS_NPC(ch) || (!IS_NPC(ch) && IS_SET(ch->act, PLR_AUTOEXIT))) && (get_bv_stage(ch) < 1))
act_info.c:	if(is_affected_room(ch->in_room, gsn_conflagration) && ch->in_room->sector_type == SECT_CONFLAGRATION)
act_info.c:	if(is_affected_room(ch->in_room, gsn_essence_of_plasma)) 
act_info.c:	if(is_affected_room(ch->in_room, gsn_glaciate) && ch->in_room->sector_type == SECT_ICE) 
act_info.c:	if(is_affected_room(ch->in_room, gsn_caustic_vapor)) 
act_info.c:	if(is_affected_room(ch->in_room, gsn_blanket)) 
act_info.c:	if(is_affected_room(ch->in_room, gsn_flood))
act_info.c:	if(is_affected_room(ch->in_room, gsn_riptide))
act_info.c:		for (raf = ch->in_room->affected; raf != NULL; raf = raf->next)
act_info.c:			if (raf->type == gsn_riptide && raf->owner == ch && raf->location == APPLY_ROOM_NONE && raf->modifier == 1)
act_info.c:			} else if (raf->type == gsn_riptide && raf->owner == ch && raf->location == APPLY_ROOM_NONE && raf->modifier == 2)
act_info.c:		af = affect_find(ch->affected,gsn_mark_of_wrath);
act_info.c:			if (!ch->in_room->tracks[i])
act_info.c:			if (ch->in_room->tracks[i]->prey != af->owner)
act_info.c:			direction = (char*)flag_name_lookup(ch->in_room->tracks[i]->direction,direction_table);
act_info.c:				af->owner->name,
act_info.c:	if (ch->in_room->sector_type == SECT_SNOW) {
act_info.c:			if (!ch->in_room->tracks[i])	
act_info.c:			if (!ch->in_room->tracks[i]->prey)
act_info.c:			if (ch->in_room->tracks[i]->flying)
act_info.c:			direction = (char *)flag_name_lookup(ch->in_room->tracks[i]->direction,direction_table);
act_info.c:				(ch->in_room->tracks[i]->prey->race == 4) ? "elven" :
act_info.c:					pc_race_table[ch->in_room->tracks[i]->prey->race].race_time,
act_info.c:	show_list_to_char( ch->in_room->contents, ch, FALSE, FALSE );
act_info.c:	show_char_to_char( ch->in_room->people,   ch );
act_info.c:	pdesc = get_extra_descr(arg3,ch->in_room->extra_descr);                                                       
act_info.c:		switch ( obj->item_type )
act_info.c:	    		if ( obj->value[1] <= 0 )
act_info.c:					obj->value[1] <     obj->value[0] / 4
act_info.c:		    		? "less than half-" :
act_info.c:					obj->value[1] < 3 * obj->value[0] / 4
act_info.c:		    		? "about half-"     : "more than half-",
act_info.c:					liq_table[obj->value[2]].liq_color);
act_info.c:	    		if ( IS_SET_OLD(obj->value[1], CONT_CLOSED) )
act_info.c:				if(obj->contains)
act_info.c:					show_list_to_char( obj->contains, ch, TRUE, TRUE );
act_info.c:		if (ch->in_room->area->sky == SKY_OVERCAST ||
act_info.c:			ch->in_room->area->sky >= SKY_DOWNPOUR)
act_info.c:    for ( obj = ch->in_room->contents; obj != NULL; obj = obj->next_content )
act_info.c:			pdesc = get_extra_descr( arg3, obj->extra_descr );
act_info.c:		    pdesc = get_extra_descr( arg3, obj->pIndexData->extra_descr );
act_info.c:			if ( is_name( arg3, obj->name ) )
act_info.c:					send_to_char( obj->description, ch );
act_info.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
act_info.c:	    	pdesc = get_extra_descr( arg3, obj->extra_descr );
act_info.c:			pdesc = get_extra_descr( arg3, obj->pIndexData->extra_descr );
act_info.c:		    if ( is_name( arg3, obj->name ) )
act_info.c:					send_to_char (obj->description, ch);
act_info.c:	if (obj && (obj->item_type == ITEM_URN))
act_info.c:			int_to_string(obj->value[4]), (obj->value[4] == 1) ? "" : "s");
act_info.c:	if (obj && (obj->item_type == ITEM_SCROLL)
act_info.c:		&& (obj->pIndexData->vnum == OBJ_VNUM_SCRIBE))
act_info.c:		if(ch->cabal == CABAL_SCION)
act_info.c:				skill_table[obj->value[1]].name);
act_info.c:	if (obj && (obj->pIndexData->vnum == OBJ_VNUM_CHESSBOARD))
act_info.c:	if (obj && (obj->item_type == ITEM_SCROLL)
act_info.c:		&& (obj->pIndexData->vnum == OBJ_VNUM_SCRIBE))
act_info.c:		if(ch->cabal == CABAL_SCION)
act_info.c:				skill_table[obj->value[1]].name);
act_info.c:	if (obj && obj->item_type == ITEM_URN)
act_info.c:			int_to_string(obj->value[4]), (obj->value[4] == 1) ? "" : "s");
act_info.c:	pexit = ch->in_room->exit[door];
act_info.c:    if (pexit->u1.to_room && is_affected_room(pexit->u1.to_room,gsn_conflagration))
act_info.c:	if (is_affected_room(pexit->u1.to_room, gsn_smokescreen) || is_affected_room(ch->in_room, gsn_smokescreen))
act_info.c:    if ( pexit->description != NULL && pexit->description[0] != '\0' )
act_info.c:		send_to_char( pexit->description, ch );
act_info.c:	if ( pexit && !IS_SET(pexit->exit_info, EX_CLOSED)
act_info.c:		&& crystal->pIndexData->vnum == OBJ_VNUM_CRYSTAL) {
act_info.c:		in_room = ch->in_room;
act_info.c:		char_to_room(ch,pexit->u1.to_room);
act_info.c:    if ( pexit->keyword    != NULL
act_info.c:    &&   pexit->keyword[0] != '\0'
act_info.c:    &&   pexit->keyword[0] != ' ' )
act_info.c:	if ( IS_SET(pexit->exit_info, EX_CLOSED) && !IS_SET(pexit->exit_info,EX_NONOBVIOUS))
act_info.c:	    act( "The $T is closed.", ch, NULL, pexit->keyword, TO_CHAR );
act_info.c:	else if ( IS_SET(pexit->exit_info, EX_ISDOOR) && !IS_SET(pexit->exit_info,EX_NONOBVIOUS))
act_info.c:	    act( "The $T is open.",   ch, NULL, pexit->keyword, TO_CHAR );
act_info.c: * Thanks to Zrin for auto-exit part.
act_info.c:	if(is_affected_room(ch->in_room, gsn_smokescreen)) {
act_info.c:	sprintf(buf,"Obvious exits from room %d:\n\r",ch->in_room->vnum);
act_info.c:	if ( ( pexit = ch->in_room->exit[door] ) != NULL
act_info.c:	&&   pexit->u1.to_room != NULL
act_info.c:	&&   can_see_room(ch,pexit->u1.to_room)
act_info.c:	&&   (!IS_SET(pexit->exit_info, EX_NONOBVIOUS) || IS_IMMORTAL(ch))
act_info.c:	&&   (!is_affected_room(ch->in_room,gsn_smokescreen)))
act_info.c:		if (IS_SET(pexit->exit_info,EX_CLOSED) || IS_SET(pexit->exit_info,EX_NONOBVIOUS))
act_info.c:		if (IS_SET(pexit->exit_info,EX_CLOSED) || IS_SET(pexit->exit_info,EX_NONOBVIOUS))
act_info.c:		sprintf( buf + strlen(buf), "%-5s - %s",
act_info.c:		    room_is_dark( pexit->u1.to_room )
act_info.c:			: pexit->u1.to_room->name
act_info.c:			" %s%s(room %d)\n\r",IS_SET(pexit->exit_info,EX_CLOSED) ? "(CLOSED) " : "",
act_info.c:					     IS_SET(pexit->exit_info,EX_NONOBVIOUS) ? "(NONOBVIOUS) "
act_info.c:					     : "", pexit->u1.to_room->vnum);
act_info.c:	    ch->gold);
act_info.c:	ch->gold, ch->exp,
act_info.c:        ch->level * exp_per_level(ch) - ch->exp);
act_info.c:	ch->true_name,
act_info.c:	ch->pcdata->title,
act_info.c:	ch->level,
act_info.c:        get_age(ch), pc_race_table[ch->race].race_time, ch->pcdata->birth_date);
act_info.c:    float tmp = (float) get_hours(ch) / (float) ch->pcdata->death_time * 100.001;
act_info.c:        race_table[ch->race].name,
act_info.c:		sex_table[ch->sex].name,
act_info.c:        IS_NPC(ch) ? "mobile" : ch->Class()->name);
act_info.c:    if ( get_trust( ch ) != ch->level )
act_info.c:	ch->hit,  ch->max_hit,
act_info.c:	ch->mana, ch->max_mana,
act_info.c:	ch->move, ch->max_move);
act_info.c:	if ((ch->Class()->GetIndex() == CLASS_WARRIOR) || ch->pcdata->special > 0) {
act_info.c:	ch->practice, ch->train,ch->pcdata->special);
act_info.c:	ch->practice, ch->train);
act_info.c:	ch->carry_number, can_carry_n(ch),
act_info.c:	ch->perm_stat[STAT_STR],
act_info.c:	ch->perm_stat[STAT_INT],
act_info.c:	ch->perm_stat[STAT_WIS],
act_info.c:	ch->perm_stat[STAT_DEX],
act_info.c:	ch->perm_stat[STAT_CON],
act_info.c:	ch->exp,  ch->gold);
act_info.c:    if (!IS_NPC(ch) && ch->level < LEVEL_HERO)
act_info.c:        (ch->level * exp_per_level(ch) - ch->exp));
act_info.c:		ch->wimpy,hometown_table[ch->hometown].name);
act_info.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK]   > 10 )
act_info.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_THIRST] > 35 )
act_info.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_HUNGER] > 35 )
act_info.c:    switch ( ch->position )
act_info.c:    /* print AC values -- print negative AC as 0 */
act_info.c:    if (ch->level >= 30)
act_info.c:	    sprintf(buf,"well-armored against %s.\n\r",temp);
act_info.c:	    sprintf(buf,"very well-armored against %s.\n\r",temp);
act_info.c:	    sprintf(buf,"nigh-invulnerable to %s.\n\r",temp);
act_info.c:      if (IS_SET(ch->act,PLR_HOLYLIGHT))
act_info.c:      if (ch->invis_level)
act_info.c:        sprintf( buf, "  Invisible: level %d",ch->invis_level);
act_info.c:      if (ch->incog_level)
act_info.c:	sprintf(buf,"  Incognito: level %d",ch->incog_level);
act_info.c:    if ( ch->level >= 15 )
act_info.c:         if ( ch->alignment == 1000 ) send_to_char( "good,", ch );
act_info.c:    else if ( ch->alignment == 0 ) send_to_char( "neutral,", ch );
act_info.c:         if ( ch->pcdata->ethos == 1000 ) send_to_char( "lawful ethos.\n\r", ch );
act_info.c:    else if ( ch->pcdata->ethos == 0 ) send_to_char( "neutral ethos.\n\r", ch );
act_info.c:	if(ch->pcdata->trusting)
act_info.c:		sprintf(buf,"You are trusting %s.\n\r", ch->pcdata->trusting->name);
act_info.c:    if (ch->Class()->GetIndex() == CLASS_SORCERER) {
act_info.c:	sprintf(buf, "Your major elemental focus is %s and your para-elemental focus is %s.\n\r",sphere_table[ch->pcdata->ele_major].name,sphere_table[ch->pcdata->ele_para].name);
act_info.c:    if (ch->Class()->GetIndex() == CLASS_ANTI_PALADIN)
act_info.c:		if(demon_table[i].type == LESSER_DEMON && ch->pcdata->lesserdata[i] >= FAVOR_GRANTED)
act_info.c:		   ch->pcdata->greaterdata[i-MAX_LESSER] >= FAVOR_GRANTED)
act_info.c:          if(IS_SET(ch->pcdata->styles, style_table[i].bit))
act_info.c:		ch->pcdata->style && ch->pcdata->style == i ? "currently" : "versed", style_table[i].name);
act_info.c:    if (IS_SET(ch->comm,COMM_SHOW_AFFECTS))
act_info.c:    if ( ch->affected != NULL && (ch->affected->aftype!=AFT_INVIS || ch->affected->next!=NULL))
act_info.c:	for ( paf = ch->affected; paf != NULL; paf = paf->next )
act_info.c:	    if(paf->aftype==AFT_INVIS)
act_info.c:	    if (paf_last != NULL && (paf->type == paf_last->type && ((paf->name == NULL && paf_last->name == NULL) || !str_cmp(paf->name,paf_last->name))))
act_info.c:		if (ch->level >= 20)
act_info.c:		if (paf->aftype == AFT_SKILL)
act_info.c:	    	sprintf( buf, "Skill  : %-17s", paf->name ? paf->name : skill_table[paf->type].name );
act_info.c:		else if (paf->aftype == AFT_POWER)
act_info.c:	    	sprintf( buf, "Power  : %-17s", paf->name ? paf->name : skill_table[paf->type].name );
act_info.c:		else if (paf->aftype == AFT_MALADY)
act_info.c:	    	sprintf( buf, "Malady : %-17s", paf->name ? paf->name : skill_table[paf->type].name );
act_info.c:		else if (paf->aftype == AFT_COMMUNE)
act_info.c:	    	sprintf( buf, "Commune: %-17s", paf->name ? paf->name : skill_table[paf->type].name );
act_info.c:		else if (paf->aftype == AFT_RUNE)
act_info.c:			sprintf( buf, "Rune   : %-17s", paf->name ? paf->name : skill_table[paf->type].name );
act_info.c:		else if (paf->aftype == AFT_TIMER)
act_info.c:			sprintf( buf, "Timer  : %-17s", paf->name ? paf->name : skill_table[paf->type].name );
act_info.c:		else if (paf->aftype != AFT_INVIS)
act_info.c:			sprintf( buf, "Spell  : %-17s", paf->name ? paf->name : skill_table[paf->type].name );
act_info.c:	    if ( ch->level >= 20 )
act_info.c:			showdur = paf->duration+1;
act_info.c:			sprintf( buf3, "%d", paf->modifier);
act_info.c:		(paf->mod_name > -1) ? mod_names[paf->mod_name].name : affect_loc_name(paf->location),
act_info.c:		(paf->mod_name > -1) ? "" : " by ",
act_info.c:		(paf->mod_name > -1) ? "" : buf3);
act_info.c:		if(paf->aftype!=AFT_INVIS)
act_info.c:		if ( paf->duration == -1 )
act_info.c:		if(paf->aftype!=AFT_INVIS)
act_info.c:	    if(paf->aftype!=AFT_INVIS);
act_info.c:	"Pebble-sized hailstones fall from the sky"
act_info.c:		sprintf(buf,"You can't see the sky from here, but the air around you is %s.\n\r", temp_look[ch->in_room->area->temp]);
act_info.c:		sky_look[ch->in_room->area->sky],
act_info.c:		temp_look[ch->in_room->area->temp],
act_info.c:		wind_look[ch->in_room->area->wind]);
act_info.c:		if (ch->in_room->area->sky == SKY_OVERCAST ||
act_info.c:			ch->in_room->area->sky >= SKY_DOWNPOUR) {
act_info.c:    for ( pHelp = help_first; pHelp != NULL; pHelp = pHelp->next )
act_info.c:    	level = (pHelp->level < 0) ? -1 * pHelp->level - 1 : pHelp->level;
act_info.c:	if (pHelp->level < 61)
act_info.c:	if ( is_name( argall, pHelp->keyword ) )
act_info.c:	    if ( pHelp->level >= 0 && str_cmp( argall, "imotd" ) )
act_info.c:		add_buf(output,pHelp->keyword);
act_info.c:	    if ( pHelp->text[0] == '.' )
act_info.c:		add_buf(output,pHelp->text+1);
act_info.c:		add_buf(output,pHelp->text);
act_info.c:	    if (ch->desc != NULL && ch->desc->connected != CON_PLAYING
act_info.c:	    &&  		    ch->desc->connected != CON_GEN_GROUPS)
act_info.c:    for (d = descriptor_list; d != NULL; d = d->next) {
act_info.c: 		if (d->connected != CON_PLAYING || !can_see(ch,d->character))
act_info.c:		wch = ( d->original != NULL ) ? d->original : d->character;
act_info.c:		if (is_affected(d->character, gsn_disguise))
act_info.c:		if (str_cmp(wch->name, wch->true_name) ? IS_IMMORTAL(ch) ?
act_info.c:			!str_prefix(arg,wch->true_name) : 0 :
act_info.c:			!str_prefix(arg,wch->name)) {
act_info.c:	    class_name = wch->Class()->who_name;
act_info.c:	    switch(wch->level) {
act_info.c:			case MAX_LEVEL - 0 : class_name = "IMP"; 	break;
act_info.c:			case MAX_LEVEL - 1 : class_name = "CRE";	break;
act_info.c:			case MAX_LEVEL - 2 : class_name = "SUP";	break;
act_info.c:			case MAX_LEVEL - 3 : class_name = "DEI";	break;
act_info.c:			case MAX_LEVEL - 4 : class_name = "GOD";	break;
act_info.c:			case MAX_LEVEL - 5 : class_name = "IMM";	break;
act_info.c:			case MAX_LEVEL - 6 : class_name = "DEM";	break;
act_info.c:			case MAX_LEVEL - 7 : class_name = "ANG";	break;
act_info.c:			case MAX_LEVEL - 8 : class_name = "AVA";	break;
act_info.c:		switch(wch->level) {
act_info.c:			case MAX_LEVEL - 0 : imm_lvl = "Creator";	break;
act_info.c:			case MAX_LEVEL - 1 : imm_lvl = " Elder ";	break;
act_info.c:			case MAX_LEVEL - 2 : imm_lvl = " Elder ";	break;
act_info.c:			case MAX_LEVEL - 3 : imm_lvl = "Greater";	break;
act_info.c:			case MAX_LEVEL - 4 : imm_lvl = "Greater";	break;
act_info.c:			case MAX_LEVEL - 5 : imm_lvl = "Greater";	break;
act_info.c:			case MAX_LEVEL - 6 : imm_lvl = " Minor ";	break;
act_info.c:			case MAX_LEVEL - 7 : imm_lvl = " Minor ";	break;
act_info.c:			case MAX_LEVEL - 8 : imm_lvl = "Avatar ";	break;
act_info.c:		if (IS_IMMORTAL(ch) || (IS_HEROIMM(wch) && wch->level<52)) {
act_info.c:			sprintf(buf, "[%2d %-5s %s%s] %s%s%s%s%s%s%s%s%s%s%s%s\n\r",
act_info.c:                wch->level,
act_info.c:				pc_race_table[wch->race].who_name_five,
act_info.c:				(get_trust(ch) >= 52) && wch->pcdata->history_buffer != NULL ?
act_info.c:	     		wch->incog_level >= LEVEL_HERO ? "(Incog) ": "",
act_info.c: 	     		wch->invis_level >= LEVEL_HERO ? "(Wizi) " : "",
act_info.c:             	cabal_table[wch->cabal].who_name,
act_info.c:				(get_trust(ch)>=57) && IS_SET(wch->act, PLR_MORON) ?
act_info.c:	     		(IS_SET(wch->comm, COMM_AFK) && (ch->level > 51)) ? "[AFK] " : "",
act_info.c:	     		IS_SET(wch->act,PLR_CRIMINAL) ? "(WANTED) " : "",
act_info.c:             	IS_SET(wch->act,PLR_THIEF) ? "(THIEF) " : "",
act_info.c:				wch->true_name,
act_info.c: 				IS_NPC(wch) ? "" : wch->pcdata->title,
act_info.c:				(wch->pcdata->extitle) ? wch->pcdata->extitle : "");
act_info.c:			if (wch->pcdata->shifted > -1)
act_info.c:                                sprintf(disp,"[%2d %-5s %s]",
act_info.c:                                                wch->level,
act_info.c:                                                pc_race_table[wch->race].who_name_five,
act_info.c:				(wch->cabal==ch->cabal) ? cabal_table[wch->cabal].who_name :"",	
act_info.c:				wch->name,
act_info.c:				IS_NPC(wch) ? "" : wch->pcdata->title,
act_info.c:				(wch->pcdata->extitle) ? wch->pcdata->extitle : "");
act_info.c:			if(wch->pcdata->shifted>-1)
act_info.c:				sprintf(disp,"[%2d %-5s %s]",
act_info.c:						wch->level,
act_info.c:						pc_race_table[wch->race].who_name_five,
act_info.c:					wch->incog_level >= LEVEL_HERO ? "(Incog) " : "",
act_info.c:					wch->invis_level >= LEVEL_HERO ? "(Wizi) " : "",
act_info.c:					(wch->cabal == ch->cabal || IS_IMMORTAL(wch)) ?
act_info.c:					cabal_table[wch->cabal].who_name : "", "",
act_info.c:					IS_SET(wch->comm, COMM_AFK) ? "[AFK] " : "",
act_info.c:					IS_SET(wch->act,PLR_CRIMINAL) ? "(WANTED) " : "",
act_info.c:					IS_SET(wch->act,PLR_THIEF) ? "(THIEF) " : "",
act_info.c:					wch->name,
act_info.c:					IS_NPC(wch) ? "" : wch->pcdata->title,
act_info.c:						(wch->pcdata->extitle) ? wch->pcdata->extitle : "");
act_info.c:                if (iClass == -1) {
act_info.c:                            if (iCabal == ch->cabal || IS_IMMORTAL(ch) ) {
act_info.c:    for ( d = descriptor_list; d != NULL; d = d->next )
act_info.c:        if ( d->connected != CON_PLAYING || !can_see( ch, d->character ) )
act_info.c:        	wch   = ( d->original != NULL ) ? d->original : d->character;
act_info.c:		if (wch->pcdata->old && !IS_IMMORTAL(ch))
act_info.c:   	        	&& ch->pcdata->induct == 5)
act_info.c:		if ( wch->level < iLevelLower
act_info.c:        		||   wch->level > iLevelUpper
act_info.c:        		|| ( fImmortalOnly  && (wch->level < LEVEL_IMMORTAL && !(IS_HEROIMM(wch)) ))
act_info.c:        		|| ( fClassRestrict && !rgfClass[wch->Class()->GetIndex()] )
act_info.c:        		|| ( fRaceRestrict && !rgfRace[wch->race])
act_info.c:			|| ( fCriminal && !IS_SET(wch->act,PLR_CRIMINAL))
act_info.c:			|| ( fBuilder && !IS_SET(wch->comm,COMM_BUILDER))
act_info.c:			|| ( fNewbie && wch->level > 10)
act_info.c:        		|| ( fCabalRestrict && !rgfCabal[wch->cabal])
act_info.c:			|| (fRole && !wch->pcdata->role)
act_info.c:			|| (fNoDesc && wch->description != NULL && strlen(wch->description) > 144)
act_info.c:		class_name = wch->Class()->who_name;
act_info.c:		switch ( wch->level ) {
act_info.c:            case MAX_LEVEL - 0 : class_name = "IMP";     break;
act_info.c:            case MAX_LEVEL - 1 : class_name = "CRE";     break;
act_info.c:            case MAX_LEVEL - 2 : class_name = "SUP";     break;
act_info.c:            case MAX_LEVEL - 3 : class_name = "DEI";     break;
act_info.c:            case MAX_LEVEL - 4 : class_name = "GOD";     break;
act_info.c:            case MAX_LEVEL - 5 : class_name = "IMM";     break;
act_info.c:            case MAX_LEVEL - 6 : class_name = "DEM";     break;
act_info.c:            case MAX_LEVEL - 7 : class_name = "ANG";     break;
act_info.c:            case MAX_LEVEL - 8 : class_name = "AVA";     break;
act_info.c:		switch(wch->level) {
act_info.c:			case MAX_LEVEL - 0 : imm_lvl = "Creator";	break;
act_info.c:			case MAX_LEVEL - 1 : imm_lvl = " Elder ";	break;
act_info.c:			case MAX_LEVEL - 2 : imm_lvl = " Elder ";	break;
act_info.c:			case MAX_LEVEL - 3 : imm_lvl = "Greater";	break;
act_info.c:			case MAX_LEVEL - 4 : imm_lvl = "Greater";	break;
act_info.c:			case MAX_LEVEL - 5 : imm_lvl = "Greater";	break;
act_info.c:			case MAX_LEVEL - 6 : imm_lvl = " Minor ";	break;
act_info.c:			case MAX_LEVEL - 7 : imm_lvl = " Minor ";	break;
act_info.c:			case MAX_LEVEL - 8 : imm_lvl = "Avatar ";	break;
act_info.c:	if(IS_IMMORTAL(ch) || (wch->level < 52 && IS_HEROIMM(wch)))
act_info.c:		sprintf( buf, "[%2d %-5s %s%s] %s%s%s%s%s%s%s%s%s%s%s%s%s\n\r",
act_info.c:    				wch->level,
act_info.c:	   				pc_race_table[wch->race].who_name_five,
act_info.c:					(get_trust(ch) >= 52) && wch->pcdata->history_buffer != NULL ? " *" : rbuf,
act_info.c:	    			wch->incog_level >= LEVEL_HERO ? "(Incog) " : "",
act_info.c:	    			wch->invis_level >= LEVEL_HERO ? "(Wizi) " : "",
act_info.c:            		cabal_table[wch->cabal].who_name,
act_info.c:					(get_trust(ch)>=57) && IS_SET(wch->act, PLR_MORON) ? "(MORON) " : "",
act_info.c:	    			(IS_SET(wch->comm, COMM_AFK) && (ch->level > 51)) ? "[AFK] " : "",
act_info.c:            		IS_SET(wch->act, PLR_CRIMINAL) ? "(WANTED) " : "",
act_info.c:            		IS_SET(wch->act, PLR_THIEF)  ? "(THIEF) "  : "",
act_info.c:	    			wch->true_name,
act_info.c:	    			IS_NPC(wch) ? "" : wch->pcdata->title ,
act_info.c:					(wch->pcdata->extitle) ? wch->pcdata->extitle : "");
act_info.c:		if (wch->pcdata->shifted > -1)
act_info.c:                                sprintf(disp,"[%2d %-5s %s]",
act_info.c:                                                wch->level,
act_info.c:                                                pc_race_table[wch->race].who_name_five,
act_info.c:				(wch->cabal==ch->cabal) ? cabal_table[wch->cabal].who_name :"",	
act_info.c:				wch->true_name,
act_info.c:				IS_NPC(wch) ? "" : wch->pcdata->title,
act_info.c:				(wch->pcdata->extitle) ? wch->pcdata->extitle : "");
act_info.c:		if(wch->pcdata->shifted>-1)
act_info.c:                                sprintf(disp,"[%2d %-5s %s]",
act_info.c:                                                wch->level,
act_info.c:                                                pc_race_table[wch->race].who_name_five,
act_info.c:	    			wch->incog_level >= LEVEL_HERO ? "(Incog) " : "",
act_info.c:	    			wch->invis_level >= LEVEL_HERO ? "(Wizi) " : "",
act_info.c:            		(wch->cabal == ch->cabal || IS_IMMORTAL(wch)) ?
act_info.c:            		cabal_table[wch->cabal].who_name : "",
act_info.c:	    			IS_SET(wch->comm, COMM_AFK) ? "[AFK] " : "",
act_info.c:            		IS_SET(wch->act, PLR_CRIMINAL) ? "(WANTED) " : "",
act_info.c:            		IS_SET(wch->act, PLR_THIEF)  ? "(THIEF) "  : "",
act_info.c:					wch->true_name,
act_info.c:	    			IS_NPC(wch) ? "" : wch->pcdata->title,
act_info.c:					(wch->pcdata->extitle) ? wch->pcdata->extitle : "" );
act_info.c:    for ( d = descriptor_list; d != NULL; d = d->next )
act_info.c:        if ( d->connected == CON_PLAYING)
act_info.c:	 if ( can_see( ch, d->character ) && !IS_SWITCHED(d->character))
act_info.c:    show_list_to_char( ch->carrying, ch, TRUE, TRUE );
act_info.c:			for(tObj = ch->carrying; tObj; tObj = tObj->next_content)
act_info.c:			if(tObj->wear_loc == WEAR_COSMETIC)
act_info.c:				sprintf(buf2,"%s>",tObj->wear_loc_name ? tObj->wear_loc_name : "bug: unset wear_loc on cosmetic");
act_info.c:				sprintf(buf, "<worn %-14s",buf2);
act_info.c:		for (obj2 = ch->carrying; obj2 != NULL; obj2 = obj2->next_content) {
act_info.c:			if (obj2->wear_loc != WEAR_NONE
act_info.c:	   	 		&&  obj1->item_type == obj2->item_type
act_info.c:	   			&&  (obj1->wear_flags[0] == obj2->wear_flags[0])
act_info.c:				&& IS_SET(obj1->wear_flags, ITEM_TAKE)
act_info.c:				&& IS_SET(obj2->wear_flags,ITEM_TAKE))
act_info.c:    else if ( obj1->item_type != obj2->item_type )
act_info.c:		switch ( obj1->item_type ) {
act_info.c:			    value1 = obj1->value[0] + obj1->value[1] + obj1->value[2];
act_info.c:			    value2 = obj2->value[0] + obj2->value[1] + obj2->value[2];
act_info.c:				value1 = (1 + obj1->value[2]) * obj1->value[1];
act_info.c:				value2 = (1 + obj2->value[2]) * obj2->value[1];
act_info.c:    if (IS_AFFECTED(ch,AFF_BLIND) || (get_bv_stage(ch) > -1))
act_info.c:	if (is_affected_area(ch->in_room->area, gsn_cyclone))
act_info.c:	if (is_affected_room(ch->in_room, gsn_smokescreen))
act_info.c:	for ( d = descriptor_list; d; d = d->next )
act_info.c:	    if ( d->connected == CON_PLAYING
act_info.c:	    && ( victim = d->character ) != NULL
act_info.c:	    &&   victim->in_room != NULL
act_info.c:	    &&   !IS_SET(victim->in_room->room_flags,ROOM_NOWHERE)
act_info.c:	    &&   (!IS_SET(victim->in_room->room_flags,ROOM_IMP_ONLY) || ch->level==60)
act_info.c: 	    &&   (is_room_owner(ch,victim->in_room)
act_info.c:	    ||    !room_is_private(victim->in_room))
act_info.c:	    &&   (victim->in_room->area == ch->in_room->area
act_info.c:		||   (is_adjacent_area(victim->in_room->area,ch->in_room->area)
act_info.c:		&&   (IS_IMMORTAL(ch) || ch->pcdata->greaterdata[GREATER_GERYON] == GERYON_FINGER)) )
act_info.c:		&&	 !is_affected_room(victim->in_room, gsn_smokescreen)
act_info.c:		sprintf( buf, "%s%-28s %s%s%s\n\r",
act_info.c:			(!IS_NPC(ch) && ch == victim && is_affected(ch, gsn_shroud_of_secrecy)) ? ch->true_name : PERS(victim,ch),
act_info.c:			IS_IMMORTAL(ch) ? victim->in_room->area->name : "",
act_info.c:			IS_IMMORTAL(ch) ? ": " : "",victim->in_room->name );
act_info.c:	for ( d = descriptor_list; d; d = d->next )
act_info.c:	    if ( d->connected == CON_PLAYING
act_info.c:	    && ( victim = d->character ) != NULL
act_info.c:	    &&   victim->in_room != NULL
act_info.c:	    &&   !IS_SET(victim->in_room->room_flags,ROOM_NOWHERE)
act_info.c:	    &&   (!IS_SET(victim->in_room->room_flags,ROOM_IMP_ONLY) || ch->level==60)
act_info.c: 	    &&   (is_room_owner(ch,victim->in_room)
act_info.c:	    ||    !room_is_private(victim->in_room))
act_info.c:	    &&   (victim->in_room->area == ch->in_room->area
act_info.c:		||   (is_adjacent_area(victim->in_room->area,ch->in_room->area)
act_info.c:		&&   !is_affected_room(victim->in_room, gsn_smokescreen))
act_info.c:		sprintf( buf, "%s%-28s %s%s%s\n\r",
act_info.c:			(!IS_NPC(ch) && ch == victim && is_affected(ch, gsn_shroud_of_secrecy)) ? ch->true_name : PERS(victim,ch),
act_info.c:			IS_IMMORTAL(ch) ? victim->in_room->area->name : "",
act_info.c:			IS_IMMORTAL(ch) ? ": " : "",victim->in_room->name );
act_info.c:	for ( victim = char_list; victim != NULL; victim = victim->next )
act_info.c:	    if ( victim->in_room != NULL
act_info.c:	    &&   (victim->in_room->area == ch->in_room->area
act_info.c:		||   (is_adjacent_area(victim->in_room->area,ch->in_room->area)
act_info.c:	    &&   (!IS_SET(victim->in_room->room_flags,ROOM_IMP_ONLY) || ch->level==60)
act_info.c:	    &&   is_name( arg, victim->name )
act_info.c:		&&   !is_affected_room(victim->in_room, gsn_smokescreen))
act_info.c:		sprintf( buf, "%s%-28s %s%s%s\n\r",
act_info.c:			PERS(victim,ch),IS_IMMORTAL(ch) ? victim->in_room->area->name : "",
act_info.c:			IS_IMMORTAL(ch) ? ": " : "",victim->in_room->name );
act_info.c:    diff = victim->level - ch->level;
act_info.c:	if ( diff <= -10 )
act_info.c:    else if ( diff <=  -5 )
act_info.c:    else if ( diff <=  -2 )
act_info.c:    diff = victim->size - ch->size;
act_info.c:	else if (diff == -1)
act_info.c:	else if (diff < -1)
act_info.c:    if ( victim->alignment >=  1 )
act_info.c:    else if ( victim->alignment <= -1 )
act_info.c:    if(victim->alignment >= 1)
act_info.c:    free_pstring( ch->pcdata->title );
act_info.c:    ch->pcdata->title = palloc_string( buf );
act_info.c:    if ( IS_NPC(ch) || ch->level < 52 )
act_info.c:    	strtime[strlen(strtime)-1] = '\0';	
act_info.c:	fprintf(fp,"%s: TITLE- %s is titling %s.\n",strtime,ch->name,argument);
act_info.c:	sprintf(buf,"AUTO: Titled to (%s) by %s.\n\r",argument, ch->true_name);
act_info.c:    free_pstring(ch->pcdata->extitle);
act_info.c:    ch->pcdata->extitle = palloc_string(buf);
act_info.c:	free_pstring(ch->pcdata->extitle);
act_info.c:	ch->pcdata->extitle = NULL;
act_info.c:    	strtime[strlen(strtime)-1] = '\0';	
act_info.c:	fprintf(fp,"%s: TITLE- %s is titling %s.\n",strtime,ch->name,argument);
act_info.c:	sprintf(buf,"AUTO: Extitled to (%s) by %s.\n\r", argument, ch->true_name);
act_info.c:	free_pstring(ch->description);
act_info.c:	ch->description = palloc_string(argument);
act_info.c:	ch->pcdata->entered_text[0] = '\0';
act_info.c:    if((!str_cmp(argument,"") && str_cmp(arg1,"-")) || (str_cmp(arg1,"+") && str_cmp(arg1,"-")))
act_info.c:    	send_to_char( ch->description ? ch->description : "(None).\n\r", ch );
act_info.c:		free_pstring( ch->description );
act_info.c:		add_buf(buffer, ch->description);
act_info.c:		free_pstring( ch->description );
act_info.c:		ch->description = palloc_string( buf_string(buffer) );
act_info.c:	else if(!str_cmp(arg1,"-"))
act_info.c:		if(ch->description == NULL || ch->description[0] == '\0')
act_info.c:		strcpy(buf, ch->description);
act_info.c:		for (len = strlen(buf); len > 0; len--)                                                                       
act_info.c:						len--;                                                                                                
act_info.c:					free_pstring(ch->description);                                                                         
act_info.c:					ch->description = palloc_string(buf);                                                                       
act_info.c:		free_pstring(ch->description);                                                                                 
act_info.c:		ch->description = palloc_string(buf);                                                                               
act_info.c:		if(!ch->description)
act_info.c:		ch->description = format_string(ch->description);
act_info.c:    if (ch->max_hit == 0)
act_info.c:	percenta = (ch->hit * 100) / ch->max_hit;
act_info.c:    if (ch->max_mana == 0)
act_info.c:        percentb = (ch->mana * 100) / ch->max_mana;
act_info.c:    if (ch->max_move == 0)
act_info.c:        percentc = (ch->move * 100) / ch->max_move;
act_info.c:		* 2: Electric boogaloo -cal */
act_info.c:        if(ch->Class()->GetIndex() == CLASS_NECROMANCER) {
act_info.c:        if(ch->pcdata->learned[skill_lookup("ritual of flesh")] > 0 && ch->pcdata->souls < 30)
act_info.c:            ch->pcdata->learned[skill_lookup("ritual of flesh")] = -2;  
act_info.c:        if(ch->pcdata->learned[skill_lookup("ritual of soul")] > 0 && ch->pcdata->souls < 55)
act_info.c:            ch->pcdata->learned[skill_lookup("ritual of soul")] = -2;   
act_info.c:        if(ch->pcdata->learned[skill_lookup("visceral divination")] && ch->pcdata->souls < 70)
act_info.c:            ch->pcdata->learned[skill_lookup("visceral divination")] = -2;
act_info.c:					if(ch->pcdata->learned[style_skill] < style_percent[p].percent)
act_info.c:		if (skill_table[sn].skill_level[ch->Class()->GetIndex()] > 52)
act_info.c:	    if ( ch->level < skill_table[sn].skill_level[ch->Class()->GetIndex()]
act_info.c:	      || ch->pcdata->learned[sn] < 1)
act_info.c:			sprintf( buf, "%-18s %3d%%  ",
act_info.c:			skill_table[sn].name, ch->pcdata->learned[sn] );
act_info.c:	    ch->practice );
act_info.c:	for ( mob = ch->in_room->people; mob != NULL; mob = mob->next_in_room )
act_info.c:	    if ( IS_NPC(mob) && IS_SET(mob->act, ACT_PRACTICE) )
act_info.c:	if ( ch->practice <= 0 )
act_info.c:	&&   (ch->level < skill_table[sn].skill_level[ch->Class()->GetIndex()]
act_info.c: 	||    ch->pcdata->learned[sn] < 1))) /* skill is not known */
act_info.c:                    if(ch->pcdata->learned[skill_lookup(group_table[gn].name)] < style_percent[p].percent)
act_info.c:	if ( ch->pcdata->learned[sn] >= adept )
act_info.c:	    ch->practice--;
act_info.c:		base *= mcap - ch->pcdata->learned[sn];
act_info.c:		ch->pcdata->learned[sn] += base;
act_info.c:			ch->Class()->ctype==CLASS_CASTER))
act_info.c:			ch->Class()->ctype==CLASS_COMMUNER))
act_info.c:		if(ch->pcdata->learned[sn] >= adept)
act_info.c:		   ch->pcdata->learned[sn] = adept;
act_info.c:	wimpy = ch->max_hit / 5;
act_info.c:    if ( wimpy > ch->max_hit/2 )
act_info.c:    ch->wimpy	= wimpy;
act_info.c:    if ( strcmp(crypt(arg1, ch->pcdata->pwd ), ch->pcdata->pwd ) )
act_info.c:    pwdnew = crypt( arg2, ch->name );
act_info.c:    free_pstring( ch->pcdata->pwd );
act_info.c:    ch->pcdata->pwd = palloc_string( pwdnew );
act_info.c:            return ch->long_descr;
act_info.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
act_info.c:        if ( (arg[0] != '\0') && !is_name(arg,rch->name) && (!IS_IMMORTAL(ch) || !rch->true_name || !is_name(arg,rch->true_name)))
act_info.c:    for (rch = room->people; rch != NULL; rch = rch->next_in_room)
act_info.c:        if ( (arg[0] != '\0') && !is_name(arg,rch->name) && (!IS_IMMORTAL(ch) || !rch->true_name || !is_name(arg,rch->true_name)))
act_info.c:    for (banker = ch->in_room->people; banker != NULL; banker = banker->next_in_room)
act_info.c:        if (IS_NPC(banker) && IS_SET(banker->act,ACT_BANKER))
act_info.c:    sprintf(buf,"You have %ld gold coins in your account.\n\r",ch->gold_bank);
act_info.c:    if (ch->gold_bank == 0)
act_info.c:    for (banker = ch->in_room->people; banker != NULL; banker = banker->next_in_room)
act_info.c:        if (IS_SET(banker->act,ACT_BANKER))
act_info.c:		if(ch->pcdata->deposited_items[i] > 0)
act_info.c:			pIndex = get_obj_index(ch->pcdata->deposited_items[i]);
act_info.c:				ch->pcdata->deposited_items[i] = 0;
act_info.c:			sprintf(buf,"%d) %s - estimated at %d gold\n\r",i+1,pIndex->short_descr,
act_info.c:				UMAX(1,pIndex->cost+number_range((int)(-.1 * pIndex->cost), (int)(.1 * pIndex->cost))));
act_info.c:	if((i = ch->pcdata->deposited_items[amount-1]) == 0 || (pIndex = get_obj_index(i)) == NULL)
act_info.c:	ch->pcdata->deposited_items[amount-1] = 0;
act_info.c:		if(ch->pcdata->deposited_items[i-1] == 0 && ch->pcdata->deposited_items[i] > 0)
act_info.c:			ch->pcdata->deposited_items[i-1] = ch->pcdata->deposited_items[i];
act_info.c:			ch->pcdata->deposited_items[i] = 0;
act_info.c:    if (ch->gold_bank < amount)
act_info.c:    ch->gold_bank -= amount;
act_info.c:    ch->gold += amount;
act_info.c:    ch->gold -= charges;
act_info.c:    for (banker = ch->in_room->people; banker != NULL; banker = banker->next_in_room)
act_info.c:        if (IS_NPC(banker) && IS_SET(banker->act,ACT_BANKER))
act_info.c:		return mob_tell(banker,ch,"Hey genius, around here we call that a 'with-draw-al'.");
act_info.c:	if (ch->gold < amount)
act_info.c:	if (amount + ch->gold_bank > ch->level * 4000)
act_info.c:	ch->gold_bank += (2 * amount) / 3;
act_info.c:	ch->gold -= amount;
act_info.c:    	sprintf(buf,"Your new balance is %ld gold.\n\r",ch->gold_bank);
act_info.c:    if(deposited->pIndexData->limtotal > 0)
act_info.c:	if(ch->pcdata->deposited_items[i] == 0)
act_info.c:    charges = UMAX(deposited->level * 15, deposited->cost / 8);
act_info.c:    if(ch->gold < charges)
act_info.c:    sprintf(buf,"%s A pleasure to do business with you.",ch->name);
act_info.c:    sprintf(buf,"You deposit %s at a cost of %d gold.\n\r",deposited->short_descr,charges);
act_info.c:    ch->gold -= charges;
act_info.c:    ch->pcdata->deposited_items[i] = deposited->pIndexData->vnum;
act_info.c:	for (victim = char_list; victim != NULL; victim = victim->next)
act_info.c:	if (victim->pcdata->wanteds > 0)
act_info.c:	sprintf(buf1,"%s has %d flags.\n\r",victim->name,victim->pcdata->wanteds);
act_info.c:	if (!(ch->level > LEVEL_HERO)) {
act_info.c:victim->pcdata->kills[PK_KILLS],
act_info.c:victim->pcdata->kills[PK_GOOD],
act_info.c:victim->pcdata->kills[PK_NEUTRAL],
act_info.c:victim->pcdata->kills[PK_EVIL],
act_info.c:victim->pcdata->killed[PK_KILLED],
act_info.c:victim->pcdata->killed[MOB_KILLED]
act_info.c:  if(ch->mana < UMAX(obj->level-10, 15))
act_info.c:				obj->name,item_name(obj->item_type), extra_bit_name( obj->extra_flags ));
act_info.c:		sprintf(buf, "%sWeight is %d, value is %d, level is %d.\n\r", buf, obj->weight, obj->cost, obj->level);
act_info.c:		switch ( obj->item_type )
act_info.c:        			if ( obj->value[i] >= 0 && obj->value[i] < MAX_SKILL)
act_info.c:						if (str_cmp( skill_table[obj->value[i]].name, "reserved"))
act_info.c:							sprintf(buf,"%s '%s'", buf, skill_table[obj->value[i]].name);
act_info.c:				if ( obj->value[3] >= 0 && obj->value[3] < MAX_SKILL && str_cmp(skill_table[obj->value[3]].name, "reserved") )
act_info.c:					sprintf(buf, "Has some charges of some level '%s'.\n\r", skill_table[obj->value[3]].name);
act_info.c:				sprintf(buf, "It holds %s-colored %s.\n\r", liq_table[obj->value[2]].liq_color, liq_table[obj->value[2]].liq_name);
act_info.c:						obj->value[0], obj->value[3], cont_bit_name(obj->value[1]));
act_info.c:				if (obj->value[4] != 100)
act_info.c:					obj->value[4]);
act_info.c:				switch (obj->value[0])
act_info.c:        		if (obj->pIndexData->new_format)
act_info.c:							obj->value[1],obj->value[2], (1 + obj->value[2]) * obj->value[1] / 2);
act_info.c:							obj->value[1], obj->value[2], ( obj->value[1] + obj->value[2] ) / 2 );
act_info.c:				if (obj->value[4])  /* weapon flags */
act_info.c:					sprintf(buf, "%sWeapons flags: %s\n\r",buf, weapon_bit_name(obj->value[4]));
act_info.c:						obj->value[0], obj->value[1], obj->value[2], obj->value[3] );
act_info.c:		for (app = obj->apply; app; app = app->next)
act_info.c:			sprintf( buf, "Affects %s by %d.\n\r", affect_loc_name( app->location ), app->modifier );
act_info.c:	ch->mana -= UMAX(obj->level-10, 15);
act_info.c:	int i, ovnum = obj->pIndexData->vnum;
act_info.c:	if (ch->pcdata->newbie==TRUE)
act_info.c:			IS_NPC(victim) ? victim->short_descr : victim->name,
act_info.c:			victim->in_room->name,
act_info.c:			victim->in_room->vnum,
act_info.c:			victim->in_room->area->name);
act_info.c:	sprintf(buf, "%ihp/%ihp  %im/%im  %imv/%imv\n\r",ch->hit,ch->max_hit,ch->mana,ch->max_mana,ch->move,ch->max_move);
act_info.c:	for (vch = victim->in_room->people; vch != NULL; vch = vch_next)
act_info.c:		vch_next = vch->next_in_room;
act_info.c:		send_to_char(vch->name,ch);
act_info.c:	if (victim->fighting != NULL) {
act_info.c:		send_to_char ((IS_NPC(victim->fighting) ? victim->fighting->short_descr : victim->fighting->name), ch);
act_info.c:	if(victim->description)
act_info.c:		sprintf(buf,"\n\rDescription: %s",victim->description);
act_info.c:	show_list_to_char( victim->carrying, ch, TRUE, FALSE );
act_info.c:	TOGGLE_BIT(ch->pcdata->trust, TRUST_GROUP);
act_info.c:	if(IS_SET(ch->pcdata->trust,TRUST_GROUP))
act_info.c:        if(!IS_SET(ch->pcdata->trust,TRUST_GROUP))
act_info.c:        TOGGLE_BIT(ch->pcdata->trust, TRUST_CABAL);
act_info.c:        if(IS_SET(ch->pcdata->trust,TRUST_CABAL))
act_info.c:        if(!IS_SET(ch->pcdata->trust,TRUST_CABAL))
act_info.c:		if(!ch->pcdata->trusting)
act_info.c:		act("You no longer trust $N with questionable actions.",ch,0,ch->pcdata->trusting,TO_CHAR);
act_info.c:		ch->pcdata->trusting = NULL;
act_info.c:	ch->pcdata->trusting = victim;
act_info.c:			send_to_char(victim->true_name, ch);
act_info.c:			if (victim->pcdata->role == NULL || victim->pcdata->role[0] == '\0') 
act_info.c:                	add_buf(output,victim->pcdata->role);
act_info.c:		if (!strcmp(arg1,"-"))
act_info.c:                if (ch->pcdata->temp_role == NULL || ch->pcdata->temp_role[0] == '\0')
act_info.c:                strcpy(obuf,ch->pcdata->temp_role);
act_info.c:                for (len = strlen(obuf); len > 0; len--)
act_info.c:                                                len--;
act_info.c:                                        free_pstring(ch->pcdata->temp_role);
act_info.c:                                        ch->pcdata->temp_role = palloc_string(obuf);
act_info.c:                free_pstring(ch->pcdata->temp_role);
act_info.c:                ch->pcdata->temp_role = palloc_string(obuf);
act_info.c:						if (ch->pcdata->temp_role)
act_info.c:                        	strcat(obuf,ch->pcdata->temp_role);
act_info.c:						if(strlen(obuf) + (ch->pcdata->role ? strlen(ch->pcdata->role) : 0) > MAX_BUF-1000)
act_info.c:						free_pstring(ch->pcdata->temp_role);
act_info.c:                        ch->pcdata->temp_role = palloc_string(obuf);
act_info.c:                if (ch->pcdata->temp_role == NULL || ch->pcdata->temp_role[0] == '\0')
act_info.c:                        add_role(ch, ch->pcdata->temp_role);
act_info.c:                        free_pstring(ch->pcdata->temp_role);
act_info.c:                        ch->pcdata->temp_role = NULL;
act_info.c:    if(ch->pcdata->temp_role!=NULL)
act_info.c:        if (ch->pcdata->role)
act_info.c:                sprintf(buf,ch->pcdata->role);
act_info.c:                strtime, ch->level, (int)((ch->played + current_time - ch->logon) / 3600));
act_info.c:        free_pstring(ch->pcdata->role);
act_info.c:        ch->pcdata->role = palloc_string(buf);
act_info.c:        if (ch->pcdata->temp_role == NULL || ch->pcdata->temp_role[0] == '\0')
act_info.c:                add_buf(output,ch->pcdata->temp_role);
act_info.c:        if (ch->pcdata->role == NULL || ch->pcdata->role[0] == '\0') {
act_info.c:                add_buf(output,ch->pcdata->role);
act_move.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
act_move.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
act_move.c:	if(ch->in_room->sector_type != SECT_UNDERWATER && is_affected(ch, gsn_drowning))
act_move.c:	switch(af->duration)
act_move.c:						(int)((ch->max_hit / 100)*25),
act_move.c:						(int)((ch->max_hit / 100)*75),
act_move.c:	if(!is_affected(ch, gsn_drowning) && to_room->sector_type == SECT_UNDERWATER && !IS_IMMORTAL(ch) && !IS_HEROIMM(ch))
act_move.c:	else if(is_affected(ch, gsn_drowning) && to_room->sector_type != SECT_UNDERWATER)
act_move.c:     if(!ch->in_room)
act_move.c:	invnum = ch->in_room->vnum;
act_move.c:	if (is_affected_room(ch->in_room, gsn_smokescreen))
act_move.c:		for (raf = ch->in_room->affected; raf != NULL; raf = raf->next)
act_move.c:			if (raf->type == gsn_smokescreen)
act_move.c:		if (raf->owner == ch)
act_move.c:		else if(raf->owner == ch->master && automatic)
act_move.c:			act("You follow $N through the smoke.", ch, 0, ch->master, TO_CHAR);
act_move.c:    in_room = ch->in_room;
act_move.c:    if ( ( pexit   = in_room->exit[door] ) == NULL
act_move.c:   		|| ( to_room = pexit->u1.to_room   ) == NULL
act_move.c:    	|| !can_see_room(ch,pexit->u1.to_room))
act_move.c:/*    if(pexit->has_rune == TRUE)
act_move.c:		if(((*rune->function) (rune, ch, &door, NULL)) == TRUE)
act_move.c:			if ( ( pexit   = in_room->exit[d0] ) == NULL
act_move.c:				|| ( to_room = pexit->u1.to_room   ) == NULL
act_move.c:				|| !can_see_room(ch,pexit->u1.to_room))
act_move.c:		if (IS_SET(pexit->exit_info,EX_LOCKED)
act_move.c:			&& ch->pIndexData->Class()->GetIndex() == CLASS_THIEF)
act_move.c:		if (IS_SET(pexit->exit_info,EX_CLOSED) && IS_SET(ch->parts,PART_HANDS))
act_move.c:		if (IS_SET(pexit->exit_info,EX_CLOSED) && ch->size >= 3)
act_move.c:    if (IS_SET(pexit->exit_info, EX_CLOSED)
act_move.c:	|| IS_SET(pexit->exit_info,EX_NOPASS))
act_move.c:		return act("Alas, you cannot go that way.",ch,NULL,pexit->keyword,TO_CHAR);
act_move.c:		&& in_room->sector_type == SECT_ICE
act_move.c:		&& to_room->sector_type == SECT_UNDERWATER)
act_move.c:   		&& ch->master != NULL
act_move.c:	    && in_room == ch->master->in_room )
act_move.c:		&& (IS_SET(to_room->room_flags,ROOM_AREA_EXPLORE)
act_move.c:		|| IS_SET(to_room->area->area_flags,AREA_NO_NEWBIES)))
act_move.c:	if(IS_NPC(ch) && IS_SET(to_room->room_flags, ROOM_NO_MOB))
act_move.c:    if(!IS_NPC(ch) && ch->ghost>0 && IS_SET(to_room->area->area_flags,AREA_UNGHOST))
act_move.c:	ch->ghost=0;
act_move.c:	if ((to_room->sector_type == SECT_VERTICAL || to_room->sector_type == SECT_AIR) && 
act_move.c:	if (to_room->sector_type == SECT_WATER
act_move.c:	    for (obj = ch->carrying; obj != NULL; obj = obj->next_content )
act_move.c:		if ( obj->item_type == ITEM_BOAT )
act_move.c:	if ((to_room->sector_type == SECT_UNDERWATER 
act_move.c:		|| (in_room->sector_type == SECT_UNDERWATER 
act_move.c:		&& to_room->sector_type != SECT_UNDERWATER))
act_move.c:		paf = affect_find(ch->affected,gsn_quicksand_sinking);
act_move.c:		if (number_percent() > ((get_curr_stat(ch,STAT_STR) * 4) - 5 * paf->modifier))
act_move.c:	if(IS_SET(in_room->progtypes, RPROG_MOVE))
act_move.c:		if (((in_room->rprogs->move_prog) (in_room, ch, door)) == FALSE)
act_move.c:	for(moveprog = ch->in_room->people; moveprog; moveprog = moveprog->next_in_room)
act_move.c:		if(IS_SET(moveprog->progtypes, MPROG_MOVE))
act_move.c:			if(((moveprog->pIndexData->mprogs->move_prog) (ch,moveprog,ch->in_room,door)) == FALSE)
act_move.c:	move = sect_table[to_room->sector_type].move_cost + sect_table[in_room->sector_type].move_cost;
act_move.c:	wait = sect_table[to_room->sector_type].wait;
act_move.c:	if (ch->pcdata->energy_state < -2)
act_move.c:	if(!IS_NPC(ch) && is_affected(ch,gsn_rage) && ch->pcdata->tribe == TRIBE_ELK)
act_move.c:	if(is_affected_area(ch->in_room->area,gsn_gravity_well))
act_move.c:		for(well = object_list; well; well = well->next)
act_move.c:			if(well->item_type == ITEM_GRAVITYWELL
act_move.c:				&& well->in_room
act_move.c:				&& well->in_room->area == in_room->area)
act_move.c:			if(!gravroom->exit[oppdir] || !gravroom->exit[oppdir]->u1.to_room)
act_move.c:			gravroom = gravroom->exit[oppdir]->u1.to_room;
act_move.c:			wait = UMAX(8 - distance, wait);
act_move.c:	if (ch->legs < 1)
act_move.c:	} else if (ch->legs < 2)
act_move.c:    if ( ch->move < (int)move )
act_move.c:	ch->move -= (int)move;
act_move.c:	if (to_room->sector_type != SECT_UNDERWATER || ch->in_room->sector_type != SECT_UNDERWATER)
act_move.c:	if (to_room->sector_type == SECT_UNDERWATER)
act_move.c:	if (to_room->sector_type == SECT_AIR 
act_move.c:		|| to_room->sector_type == SECT_VERTICAL
act_move.c:		|| to_room->sector_type == SECT_WATER
act_move.c:		|| to_room->sector_type == SECT_UNDERWATER)
act_move.c:		 && to_room->sector_type
act_move.c:		 && to_room->sector_type
act_move.c:		&& !check_silent_movement(ch, ch->in_room)
act_move.c:		&&   ch->invis_level < LEVEL_HERO
act_move.c:		if (to_room->sector_type == SECT_UNDERWATER || ch->in_room->sector_type == SECT_UNDERWATER)
act_move.c:		else if (ch->legs < 1)
act_move.c:		else if (ch->legs < 2)
act_move.c:		if (ch->legs < 2 && is_land(ch->in_room) && is_land(to_room))
act_move.c:    if ( (to_room->sector_type != SECT_FOREST) && (to_room->sector_type != SECT_MOUNTAIN) && (to_room->sector_type != SECT_HILLS ) )
act_move.c:    if(ch->fighting)
act_move.c:	if(in_room->area != to_room->area)
act_move.c:		for( d = descriptor_list; d; d = d->next )
act_move.c:			if ( d->connected == CON_PLAYING                                                                          
act_move.c:		        && ( victim = d->character ) != NULL                                                                      
act_move.c:		        &&   victim->in_room != NULL                                                                              
act_move.c:		        &&   (victim->in_room->area == ch->in_room->area)                                                          
act_move.c:		&& !check_silent_movement(ch, ch->in_room)
act_move.c:    	&&   ch->invis_level < LEVEL_HERO
act_move.c:		if (to_room->sector_type == SECT_UNDERWATER || ch->in_room->sector_type == SECT_UNDERWATER)
act_move.c:		else if (ch->legs < 1)
act_move.c:		else if (ch->legs < 2)
act_move.c:                if((imaf=affect_find(ch->affected,gsn_impale)) && imaf->owner)
act_move.c:                        owner = imaf->owner;
act_move.c:                if (!ch->in_room || ch->ghost > 0)
act_move.c:		for (raf = in_room->affected; raf != NULL; raf = raf->next)
act_move.c:			if (raf->modifier == door && raf->type == gsn_tripwire)
act_move.c:		for (raf_two = to_room->affected; raf_two != NULL; raf_two = raf_two->next)
act_move.c:			if (raf_two->modifier == reverse_d(door) && raf->type == gsn_tripwire)
act_move.c:		if (raf->owner == ch)
act_move.c:			twchance += (get_curr_stat(ch,STAT_DEX) + get_curr_stat(ch,STAT_INT) - 30) * 2;	
act_move.c:			if (!is_safe(raf->owner,ch) && (number_percent() > twchance))
act_move.c:				ch->position = POS_RESTING;
act_move.c:		for (raf = to_room->affected; raf != NULL; raf = raf->next)
act_move.c:			if (raf->type == gsn_riptide && raf->location == APPLY_ROOM_NONE && raf->modifier == 1)
act_move.c:				if (is_safe_new(raf->owner,ch,FALSE) || raf->owner == ch)
act_move.c:				for (room = top_affected_room; room; room = room->aff_next )
act_move.c:						for (raf_two = room->affected; raf_two != NULL; raf_two = raf_two->next)
act_move.c:							if (raf_two->type == gsn_riptide && raf_two->owner == raf->owner && raf_two->location == APPLY_ROOM_NONE && raf_two->modifier == 2)
act_move.c:		for (raf = to_room->affected; raf; raf = raf->next)
act_move.c:			if (raf->type == gsn_frost_growth)
act_move.c:		if (is_same_cabal(ch,raf->owner) || is_same_group(ch,raf->owner))
act_move.c:		if (is_safe(ch,raf->owner))
act_move.c:		if (number_percent() <= (5 * (get_curr_stat(ch,STAT_DEX) - 15 ))) {
act_move.c:			act("You almost lose your footing on the surprisingly-slick ground, but steady yourself.",ch,0,0,TO_CHAR);
act_move.c:			act("$n almost loses $s footing on the frost-covered ground, but remains standing.",ch,0,0,TO_ROOM);
act_move.c:		WAIT_STATE(ch, (ch->carry_weight/150) * PULSE_VIOLENCE);
act_move.c:		damage_new(raf->owner, ch, 5 + ch->carry_weight/6, TYPE_UNDEFINED, DAM_BASH, TRUE, HIT_UNBLOCKABLE, HIT_NOADD, HIT_NOMULT, "the fall*");
act_move.c:		ch->position = POS_RESTING;
act_move.c:		for (raf = to_room->affected; raf; raf = raf->next)
act_move.c:			if (raf->type == gsn_quicksand)
act_move.c:		if (is_safe_new(raf->owner,ch,FALSE)
act_move.c:			|| is_same_group(raf->owner,ch)
act_move.c:			|| is_same_cabal(raf->owner,ch))
act_move.c:		qs.level		=	raf->level;
act_move.c:		qs.duration		=	-1;
act_move.c:		for (raf = to_room->affected; raf; raf = raf->next)
act_move.c:			if (raf->type == gsn_stalactites)
act_move.c:		if (is_safe_new(raf->owner,ch, FALSE)
act_move.c:			|| is_same_group(raf->owner,ch)
act_move.c:			|| is_same_cabal(raf->owner,ch))
act_move.c:		if (number_percent() > (10 * get_curr_stat(ch,STAT_DEX) - 175)) {
act_move.c:			damage_new(raf->owner,ch,dice(raf->level,3),gsn_stalactites,DAM_PIERCE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the falling stalactite*");
act_move.c:			damage_new(raf->owner,ch,0,gsn_stalactites,DAM_PIERCE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the falling stalactite*");
act_move.c:		if (--raf->modifier <= 0)
act_move.c:		if (!ch->in_room || ch->ghost > 0)  return;
act_move.c:		for (raf = to_room->affected; raf != NULL; raf = raf->next) {
act_move.c:			if (raf->type == gsn_caustic_vapor)	break;
act_move.c:		if (!is_safe(raf->owner,ch) && !is_affected(ch,gsn_neutralize)) {
act_move.c:				cvaf.level		=	raf->level;
act_move.c:				cvaf.owner		=	raf->owner;
act_move.c:			for (paf = ch->affected; paf != NULL; paf = paf->next) {
act_move.c:				if (paf->type == gsn_noxious_fumes) break;
act_move.c:			paf->modifier = URANGE(0,paf->modifier,5);
act_move.c:			paf->modifier++;
act_move.c:			cvaf2.level		=	raf->level;
act_move.c:			cvaf2.owner		=	raf->owner;
act_move.c:			switch(paf->modifier) {
act_move.c:					dam = dice(raf->level/3,2);
act_move.c:					dam = dice(raf->level/3,3);
act_move.c:					dam = dice(raf->level/3,3);
act_move.c:					dam = dice(raf->level/2,2);
act_move.c:					dam = dice(raf->level/2,2);
act_move.c:					dam = dice(raf->level/2,3);
act_move.c:			if (paf->modifier >= 3)
act_move.c:			damage_new(raf->owner,ch,dam,raf->type,DAM_POISON,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the noxious fumes*$");
act_move.c:			if (!ch->in_room || ch->ghost > 0)	return;
act_move.c:		if (!is_safe(ch,raf->owner) && is_affected(ch,gsn_neutralize)) {
act_move.c:    if(to_room->has_rune == TRUE && to_room == ch->in_room)
act_move.c:                (*rune->function) (rune, ch, &door, NULL);
act_move.c:	if(to_room->trap && to_room->trap->armed)
act_move.c:		trip_trap(ch, to_room, to_room->trap);
act_move.c:	for (fch = to_room->people,room_has_pc = FALSE; fch != NULL; fch = fch_next)
act_move.c:		fch_next = fch->next_in_room;
act_move.c:	for (fch = to_room->people; fch != NULL; fch = fch_next)
act_move.c:		fch_next = fch->next_in_room;
act_move.c:	for (obj = fch->carrying; room_has_pc && obj != NULL; obj = obj->next_content)
act_move.c:		if (IS_SET(obj->progtypes,IPROG_GREET))
act_move.c:			(obj->pIndexData->iprogs->greet_prog) (obj,ch);
act_move.c:      if (room_has_pc && IS_SET(fch->progtypes,MPROG_GREET))
act_move.c:        (fch->pIndexData->mprogs->greet_prog) (fch,ch);
act_move.c:	for (obj = ch->carrying; room_has_pc && obj != NULL; obj = obj->next_content)
act_move.c:		if (IS_SET(obj->progtypes,IPROG_ENTRY))
act_move.c:			(obj->pIndexData->iprogs->entry_prog) (obj);
act_move.c:	if (IS_SET(to_room->progtypes, RPROG_ENTRY))
act_move.c:		(to_room->rprogs->entry_prog) (to_room, ch);
act_move.c:    for ( fch = in_room->people; fch != NULL; fch = fch_next )
act_move.c:	fch_next = fch->next_in_room;
act_move.c:	if ( fch->master == ch && IS_AFFECTED(fch,AFF_CHARM)
act_move.c:	&&   fch->position < POS_STANDING)
act_move.c:	if ( fch->master == ch && fch->position == POS_STANDING && can_see_room(fch,to_room))
act_move.c:	    if (IS_SET(ch->in_room->room_flags,ROOM_LAW)
act_move.c:	    &&  (IS_NPC(fch) && IS_SET(fch->act,ACT_AGGRESSIVE)))
act_move.c:for (obj = ch->in_room->contents; obj != NULL;
act_move.c:     obj = obj->next_content)
act_move.c:    if (IS_SET(obj->progtypes,IPROG_GREET))
act_move.c:      (obj->pIndexData->iprogs->greet_prog) (obj,ch);
act_move.c:    if (IS_SET(ch->progtypes,MPROG_ENTRY))
act_move.c:      (ch->pIndexData->mprogs->entry_prog) (ch);
act_move.c:	if (!IS_NPC(ch) && (to_room->tracks[0] != NULL)) {
act_move.c:			if(to_room->tracks[i]->prey == ch) {
act_move.c:		if (i == MAX_TRACKS)	i--;
act_move.c:		if(to_room->tracks[i]->prey == ch) {
act_move.c:			for(;i<MAX_TRACKS-1;i++) {
act_move.c:				to_room->tracks[i]->prey = to_room->tracks[i+1]->prey;
act_move.c:				to_room->tracks[i]->time = to_room->tracks[i+1]->time;
act_move.c:				to_room->tracks[i]->direction = to_room->tracks[i+1]->direction;
act_move.c:				to_room->tracks[i]->flying = to_room->tracks[i+1]->flying;
act_move.c:				to_room->tracks[i]->sneaking = to_room->tracks[i+1]->sneaking;
act_move.c:				to_room->tracks[i]->bleeding = to_room->tracks[i+1]->bleeding;
act_move.c:				to_room->tracks[i]->legs = to_room->tracks[i+1]->legs;
act_move.c:			to_room->tracks[MAX_TRACKS - 1]->prey = NULL;
act_move.c:			to_room->tracks[MAX_TRACKS - 1]->direction = -1;
act_move.c:	if (!trap->armed)
act_move.c:	trap->armed = FALSE;
act_move.c:	if (trap->timer) {
act_move.c:		act(trap->trig_echo,ch,0,0,TO_ALL);
act_move.c:		RS.Queue.AddToQueue(trap->timer, 3, trap_execute, NULL, room, trap);
act_move.c:	act(trap->exec_echo,victim,0,0,TO_ALL);
act_move.c:	switch (trap->type) {
act_move.c:			damage_new(victim,victim,(dice(trap->quality*10,7)),TYPE_UNDEFINED,DAM_PIERCE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the razor-tipped dart*");
act_move.c:			damage_new(victim,victim,(dice(trap->quality*5,7)),TYPE_UNDEFINED,DAM_PIERCE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the poison-tipped dart*");
act_move.c:			if (saves_spell(8*trap->quality,victim,DAM_POISON)) {
act_move.c:			if(IS_SET(victim->affected_by,AFF_POISON))
act_move.c:			af.level		= trap->quality * 7;
act_move.c:			af.modifier		= -5;
act_move.c:			af.duration		= trap->quality * 2;
act_move.c:			for (vch = room->people; vch; vch = vch_next) {
act_move.c:				vch_next = vch->next_in_room;
act_move.c:				damage_new(vch,vch,dice(trap->quality*9,9),TYPE_UNDEFINED,DAM_FIRE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the fireball*");
act_move.c:			dam = damage_new(victim,victim,dice(trap->quality*10,9),TYPE_UNDEFINED,DAM_LIGHTNING,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the lightning bolt*");
act_move.c:			if (trap->quality > 5)
act_move.c:				shock_effect(victim, trap->quality * 7, dam, TARGET_CHAR);
act_move.c:			if (trap->quality < 5)
act_move.c:				mod = (trap->quality * 3) - 6;
act_move.c:				mod = trap->quality * 2;
act_move.c:			for (vch = room->people; vch; vch = vch->next_in_room) {
act_move.c:				if (saves_spell(vch->level + mod,vch,DAM_OTHER)) {
act_move.c:					af.level		=	trap->quality * 6;
act_move.c:					af.duration		=	trap->quality * 4;
act_move.c:			spell_acid_stream(gsn_acid_stream, trap->quality * 7, victim, victim, TARGET_CHAR);
act_move.c:			for (vch = room->people; vch; vch = vch->next_in_room) {
act_move.c:				if (trap->quality <= 4) 
act_move.c:					vch->mana = vch->mana / (trap->quality + 1);
act_move.c:				else if (trap->quality == 5)
act_move.c:					vch->mana = 0;
act_move.c:					vch->mana = 0;
act_move.c:					af.level		=	vch->level;
act_move.c:					af.duration		=	trap->quality * 4;
act_move.c:	    if ( ( pexit = ch->in_room->exit[door] ) != NULL
act_move.c:	    &&   IS_SET(pexit->exit_info, EX_ISDOOR)
act_move.c:	    &&   pexit->keyword != NULL
act_move.c:	    &&   is_name( arg, pexit->keyword ) )
act_move.c:	return -1;
act_move.c:    if ( ( pexit = ch->in_room->exit[door] ) == NULL )
act_move.c:	return -1;
act_move.c:    if ( !IS_SET(pexit->exit_info, EX_ISDOOR) )
act_move.c:	return -1;
act_move.c:	if (obj->item_type == ITEM_PORTAL)
act_move.c:	    if (!IS_SET_OLD(obj->value[1], EX_ISDOOR))
act_move.c:	    if (!IS_SET_OLD(obj->value[1], EX_CLOSED))
act_move.c:	    if (IS_SET_OLD(obj->value[1], EX_LOCKED))
act_move.c:	    REMOVE_BIT_OLD(obj->value[1], EX_CLOSED);
act_move.c:	if ( obj->item_type != ITEM_CONTAINER)
act_move.c:	if ( !IS_SET_OLD(obj->value[1], CONT_CLOSED) )
act_move.c:	if ( IS_SET_OLD(obj->value[1], CONT_LOCKED) )
act_move.c:	if (IS_SET(obj->progtypes,IPROG_OPEN))
act_move.c:		if (((obj->pIndexData->iprogs->open_prog) (obj,ch)) == FALSE)
act_move.c:	REMOVE_BIT_OLD(obj->value[1], CONT_CLOSED);
act_move.c:	pexit = ch->in_room->exit[door];
act_move.c:    if(IS_SET(ch->in_room->progtypes,RPROG_OPEN))
act_move.c:    	if(((ch->in_room->rprogs->open_prog) (ch->in_room,ch,pexit)) == FALSE)
act_move.c:	if ( !IS_SET(pexit->exit_info, EX_CLOSED) )
act_move.c:	if (  IS_SET(pexit->exit_info, EX_LOCKED) )
act_move.c:	if ( IS_SET(pexit->exit_info, EX_JAMMED) )
act_move.c:	REMOVE_BIT(pexit->exit_info, EX_CLOSED);
act_move.c:	act( "$n opens the $T.", ch, NULL, (pexit->keyword[0] != '\0') ? pexit->keyword : "door", TO_ROOM );
act_move.c:	if ( ( to_room   = pexit->u1.to_room            ) != NULL
act_move.c:	&&   ( pexit_rev = to_room->exit[rev_dir[door]] ) != NULL
act_move.c:	&&   pexit_rev->u1.to_room == ch->in_room )
act_move.c:	    REMOVE_BIT( pexit_rev->exit_info, EX_CLOSED );
act_move.c:	    for ( rch = to_room->people; rch != NULL; rch = rch->next_in_room )
act_move.c:		act( "The $T opens.", rch, NULL, (pexit_rev->keyword[0] != '\0') ? pexit_rev->keyword : "door", TO_CHAR );
act_move.c:	if (obj->item_type == ITEM_PORTAL)
act_move.c:	    if (!IS_SET_OLD(obj->value[1],EX_ISDOOR)
act_move.c:	    ||   IS_SET_OLD(obj->value[1],EX_NOCLOSE))
act_move.c:	    if (IS_SET_OLD(obj->value[1],EX_CLOSED))
act_move.c:	    SET_BIT_OLD(obj->value[1],EX_CLOSED);
act_move.c:	if ( obj->item_type != ITEM_CONTAINER )
act_move.c:	if ( IS_SET_OLD(obj->value[1], CONT_CLOSED) )
act_move.c:	if ( !IS_SET_OLD(obj->value[1], CONT_CLOSEABLE) )
act_move.c:	SET_BIT_OLD(obj->value[1], CONT_CLOSED);
act_move.c:	pexit	= ch->in_room->exit[door];
act_move.c:	if ( IS_SET(pexit->exit_info, EX_CLOSED) )
act_move.c:	if ( IS_SET(pexit->exit_info, EX_NOCLOSE) )
act_move.c:	SET_BIT(pexit->exit_info, EX_CLOSED);
act_move.c:	act( "$n closes the $T.", ch, NULL, pexit->keyword, TO_ROOM );
act_move.c:	if ( ( to_room   = pexit->u1.to_room            ) != NULL
act_move.c:	&&   ( pexit_rev = to_room->exit[rev_dir[door]] ) != 0
act_move.c:	&&   pexit_rev->u1.to_room == ch->in_room )
act_move.c:	    SET_BIT( pexit_rev->exit_info, EX_CLOSED );
act_move.c:	    for ( rch = to_room->people; rch != NULL; rch = rch->next_in_room )
act_move.c:		act( "The $T closes.", rch, NULL, pexit_rev->keyword, TO_CHAR );
act_move.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
act_move.c:	if ( obj->pIndexData->vnum == key )
act_move.c:	if (obj->item_type == ITEM_PORTAL)
act_move.c:	    if (!IS_SET_OLD(obj->value[1],EX_ISDOOR)
act_move.c:	    ||  IS_SET_OLD(obj->value[1],EX_NOCLOSE))
act_move.c:	    if (!IS_SET_OLD(obj->value[1],EX_CLOSED))
act_move.c:	    if (obj->value[4] < 0 || IS_SET_OLD(obj->value[1],EX_NOLOCK))
act_move.c:	    if (!has_key(ch,obj->value[4]))
act_move.c:	    if (IS_SET_OLD(obj->value[1],EX_LOCKED))
act_move.c:	    SET_BIT_OLD(obj->value[1],EX_LOCKED);
act_move.c:	if ( obj->item_type != ITEM_CONTAINER )
act_move.c:	if ( !IS_SET_OLD(obj->value[1], CONT_CLOSED) )
act_move.c:	if ( obj->value[2] < 0 )
act_move.c:	if ( !has_key( ch, obj->value[2] ) )
act_move.c:	if ( IS_SET_OLD(obj->value[1], CONT_LOCKED) )
act_move.c:	SET_BIT_OLD(obj->value[1], CONT_LOCKED);
act_move.c:	pexit	= ch->in_room->exit[door];
act_move.c:	if ( !IS_SET(pexit->exit_info, EX_CLOSED) )
act_move.c:	if ( pexit->key < 0 )
act_move.c:	if ( !has_key( ch, pexit->key) )
act_move.c:	if ( IS_SET(pexit->exit_info, EX_LOCKED) )
act_move.c:	SET_BIT(pexit->exit_info, EX_LOCKED);
act_move.c:	act( "$n locks the $T.", ch, NULL, pexit->keyword, TO_ROOM );
act_move.c:	if ( ( to_room   = pexit->u1.to_room            ) != NULL
act_move.c:	&&   ( pexit_rev = to_room->exit[rev_dir[door]] ) != 0
act_move.c:	&&   pexit_rev->u1.to_room == ch->in_room )
act_move.c:	    SET_BIT( pexit_rev->exit_info, EX_LOCKED );
act_move.c:	if (obj->item_type == ITEM_PORTAL)
act_move.c:	    if (!IS_SET_OLD(obj->value[1],EX_ISDOOR))
act_move.c:	    if (!IS_SET_OLD(obj->value[1],EX_CLOSED))
act_move.c:	    if (obj->value[4] < 0)
act_move.c:	    if (!has_key(ch,obj->value[4]))
act_move.c:	    if (!IS_SET_OLD(obj->value[1],EX_LOCKED))
act_move.c:	    REMOVE_BIT_OLD(obj->value[1],EX_LOCKED);
act_move.c:	if ( obj->item_type != ITEM_CONTAINER )
act_move.c:	if ( !IS_SET_OLD(obj->value[1], CONT_CLOSED) )
act_move.c:	if ( obj->value[2] < 0 )
act_move.c:	if ( !has_key( ch, obj->value[2] ) )
act_move.c:	if ( !IS_SET_OLD(obj->value[1], CONT_LOCKED) )
act_move.c:	REMOVE_BIT_OLD(obj->value[1], CONT_LOCKED);
act_move.c:	pexit = ch->in_room->exit[door];
act_move.c:	if ( !IS_SET(pexit->exit_info, EX_CLOSED) )
act_move.c:	if ( pexit->key < 0 )
act_move.c:	if ( !has_key( ch, pexit->key) )
act_move.c:	if ( !IS_SET(pexit->exit_info, EX_LOCKED) )
act_move.c:	REMOVE_BIT(pexit->exit_info, EX_LOCKED);
act_move.c:	act( "$n unlocks the $T.", ch, NULL, pexit->keyword, TO_ROOM );
act_move.c:	if ( ( to_room   = pexit->u1.to_room            ) != NULL
act_move.c:	&&   ( pexit_rev = to_room->exit[rev_dir[door]] ) != NULL
act_move.c:	&&   pexit_rev->u1.to_room == ch->in_room )
act_move.c:	    REMOVE_BIT( pexit_rev->exit_info, EX_LOCKED );
act_move.c:    for ( gch = ch->in_room->people; gch; gch = gch->next_in_room )
act_move.c:	if ( IS_NPC(gch) && IS_AWAKE(gch) && ch->level + 5 < gch->level )
act_move.c:	if (obj->item_type == ITEM_PORTAL)
act_move.c:	    if (!IS_SET_OLD(obj->value[1],EX_ISDOOR))
act_move.c:	    if (!IS_SET_OLD(obj->value[1],EX_CLOSED))
act_move.c:	    if (obj->value[4] < 0)
act_move.c:	    if (IS_SET_OLD(obj->value[1],EX_PICKPROOF))
act_move.c:	    REMOVE_BIT_OLD(obj->value[1],EX_LOCKED);
act_move.c:	if ( obj->item_type != ITEM_CONTAINER )
act_move.c:	if ( !IS_SET_OLD(obj->value[1], CONT_CLOSED) )
act_move.c:	if ( obj->value[2] < 0 )
act_move.c:	if ( !IS_SET_OLD(obj->value[1], CONT_LOCKED) )
act_move.c:	if ( IS_SET_OLD(obj->value[1], CONT_PICKPROOF) )
act_move.c:	REMOVE_BIT_OLD(obj->value[1], CONT_LOCKED);
act_move.c:	pexit = ch->in_room->exit[door];
act_move.c:	if ( !IS_SET(pexit->exit_info, EX_CLOSED) && !IS_IMMORTAL(ch))
act_move.c:	if ( pexit->key < 0 && !IS_IMMORTAL(ch))
act_move.c:	if ( !IS_SET(pexit->exit_info, EX_LOCKED) )
act_move.c:	if ( IS_SET(pexit->exit_info, EX_PICKPROOF) && !IS_IMMORTAL(ch))
act_move.c:	REMOVE_BIT(pexit->exit_info, EX_LOCKED);
act_move.c:	act( "$n picks the $T.", ch, NULL, pexit->keyword, TO_ROOM );
act_move.c:	if ( ( to_room   = pexit->u1.to_room            ) != NULL
act_move.c:	&&   ( pexit_rev = to_room->exit[rev_dir[door]] ) != NULL
act_move.c:	&&   pexit_rev->u1.to_room == ch->in_room )
act_move.c:	    REMOVE_BIT( pexit_rev->exit_info, EX_LOCKED );
act_move.c:	if (ch->position == POS_FIGHTING)
act_move.c:	obj = get_obj_list(ch,argument,ch->in_room->contents);
act_move.c:	if (obj->item_type != ITEM_FURNITURE
act_move.c:	||  (!IS_SET_OLD(obj->value[2],STAND_AT)
act_move.c:	&&   !IS_SET_OLD(obj->value[2],STAND_ON)
act_move.c:	&&   !IS_SET_OLD(obj->value[2],STAND_IN)))
act_move.c:	if (ch->on != obj && count_users(obj) >= obj->value[0])
act_move.c: 	ch->on = obj;
act_move.c:    switch ( ch->position )
act_move.c:	    ch->on = NULL;
act_move.c:	else if (IS_SET_OLD(obj->value[2],STAND_AT))
act_move.c:	else if (IS_SET_OLD(obj->value[2],STAND_ON))
act_move.c:	ch->position = POS_STANDING;
act_move.c:	    ch->on = NULL;
act_move.c:	else if (IS_SET_OLD(obj->value[2],STAND_AT))
act_move.c:	else if (IS_SET_OLD(obj->value[2],STAND_ON))
act_move.c:	ch->position = POS_STANDING;
act_move.c:    if (ch->position == POS_FIGHTING)
act_move.c:	obj = get_obj_list(ch,argument,ch->in_room->contents);
act_move.c:    else obj = ch->on;
act_move.c:        if (obj->item_type != ITEM_FURNITURE
act_move.c:    	||  (!IS_SET_OLD(obj->value[2],REST_ON)
act_move.c:    	&&   !IS_SET_OLD(obj->value[2],REST_IN)
act_move.c:	&&   !IS_SET_OLD(obj->value[2],LOUNGE_ON)
act_move.c:    	&&   !IS_SET_OLD(obj->value[2],REST_AT)))
act_move.c:        if (obj != NULL && ch->on != obj && count_users(obj) >= obj->value[0])
act_move.c:	ch->on = obj;
act_move.c:    switch ( ch->position )
act_move.c:	else if (IS_SET_OLD(obj->value[2],REST_AT))
act_move.c:        else if (IS_SET_OLD(obj->value[2],REST_ON))
act_move.c:	else if(IS_SET_OLD(obj->value[2],LOUNGE_ON))
act_move.c:	ch->position = POS_RESTING;
act_move.c:        else if (IS_SET_OLD(obj->value[2],REST_AT))
act_move.c:        else if (IS_SET_OLD(obj->value[2],REST_ON))
act_move.c:        else if (IS_SET_OLD(obj->value[2],LOUNGE_ON))
act_move.c:	ch->position = POS_RESTING;
act_move.c:        else if (IS_SET_OLD(obj->value[2],REST_AT))
act_move.c:        else if (IS_SET_OLD(obj->value[2],REST_ON))
act_move.c:        else if (IS_SET_OLD(obj->value[2],LOUNGE_ON))
act_move.c:	ch->position = POS_RESTING;
act_move.c:    if (ch->position == POS_FIGHTING)
act_move.c:	obj = get_obj_list(ch,argument,ch->in_room->contents);
act_move.c:    else obj = ch->on;
act_move.c:	if (obj->item_type != ITEM_FURNITURE
act_move.c:	||  (!IS_SET_OLD(obj->value[2],SIT_ON)
act_move.c:	&&   !IS_SET_OLD(obj->value[2],SIT_IN)
act_move.c:	&&   !IS_SET_OLD(obj->value[2],SIT_AT)))
act_move.c:	if (obj != NULL && ch->on != obj && count_users(obj) >= obj->value[0])
act_move.c:	ch->on = obj;
act_move.c:    switch (ch->position)
act_move.c:            else if (IS_SET_OLD(obj->value[2],SIT_AT))
act_move.c:            else if (IS_SET_OLD(obj->value[2],SIT_ON))
act_move.c:	    ch->position = POS_SITTING;
act_move.c:	    else if (IS_SET_OLD(obj->value[2],SIT_AT))
act_move.c:	    else if (IS_SET_OLD(obj->value[2],SIT_ON))
act_move.c:	    ch->position = POS_SITTING;
act_move.c:	    else if (IS_SET_OLD(obj->value[2],SIT_AT))
act_move.c:	    else if (IS_SET_OLD(obj->value[2],SIT_ON))
act_move.c:    	    ch->position = POS_SITTING;
act_move.c:    if (ch->pause > 5)
act_move.c:    switch ( ch->position )
act_move.c:	if (argument[0] == '\0' && ch->on == NULL)
act_move.c:	    ch->position = POS_SLEEPING;
act_move.c:		obj = ch->on;
act_move.c:	    	obj = get_obj_list( ch, argument,  ch->in_room->contents );
act_move.c:	    if (obj->item_type != ITEM_FURNITURE
act_move.c:	    ||  (!IS_SET_OLD(obj->value[2],SLEEP_ON)
act_move.c:	    &&   !IS_SET_OLD(obj->value[2],SLEEP_IN)
act_move.c:	    &&	 !IS_SET_OLD(obj->value[2],SLEEP_AT)))
act_move.c:	    if (ch->on != obj && count_users(obj) >= obj->value[0])
act_move.c:	    ch->on = obj;
act_move.c:	    if (IS_SET_OLD(obj->value[2],SLEEP_AT))
act_move.c:	    else if (IS_SET_OLD(obj->value[2],SLEEP_ON))
act_move.c:	    ch->position = POS_SLEEPING;
act_move.c:	if (ch->in_room->sector_type == SECT_AIR 
act_move.c:		|| ch->in_room->sector_type == SECT_VERTICAL
act_move.c:		|| ch->in_room->sector_type == SECT_WATER
act_move.c:		|| ch->in_room->sector_type == SECT_UNDERWATER)
act_move.c:		af.level     = ch->level;
act_move.c:		af.duration  = ch->level;
act_move.c:	    if(ch->original_name) {
act_move.c:		free_pstring(ch->name);
act_move.c:		ch->name=palloc_string(ch->original_name);
act_move.c:		free_pstring(ch->original_name);
act_move.c:		ch->original_name=NULL;
act_move.c:	  af.level    = ch->level;
act_move.c:	  af.duration = -1;
act_move.c:	  if(!(ch->original_name)) {
act_move.c:	 	free_pstring(ch->original_name);
act_move.c:		ch->original_name=palloc_string(ch->name);
act_move.c:		free_pstring(ch->name);
act_move.c:		ch->name=palloc_string(buf);
act_move.c:	  af.modifier = ch->level*5;
act_move.c:	  af.modifier = ch->level*2;
act_move.c:	  af.modifier = ch->level*2;
act_move.c:        || (ch->level < skill_table[gsn_vigilance].skill_level[ch->Class()->GetIndex()]) )
act_move.c:        if (ch->mana < 30)
act_move.c:        if (number_percent() > ch->pcdata->learned[gsn_vigilance])
act_move.c:        ch->mana -= 15;
act_move.c:        af.level = ch->level;
act_move.c:        ch->mana -= 30;
act_move.c:	|| ch->level < skill_table[gsn_acute_vision].skill_level[ch->Class()->GetIndex()])
act_move.c:   if (ch->mana < 25)
act_move.c:    ch->mana -= 12;
act_move.c:    af.level = ch->level;
act_move.c:    af.duration = ch->level;
act_move.c:    ch->mana -= 25;
act_move.c:    if ( (get_skill(ch,gsn_camp) == 0) || ch->level < skill_table[gsn_camp].skill_level[ch->Class()->GetIndex()] )
act_move.c:    if (ch->position == POS_SLEEPING )
act_move.c:    if ((ch->in_room->sector_type != SECT_FOREST) && (ch->in_room->sector_type != SECT_HILLS)
act_move.c:    && (ch->in_room->sector_type != SECT_MOUNTAIN) )
act_move.c:    af.level = ch->level;
act_move.c:    if ( !IS_IMMORTAL(ch) && (ch->in_room->sector_type != SECT_FOREST) && (ch->in_room->sector_type != SECT_MOUNTAIN) && 
act_move.c:(ch->in_room->sector_type != SECT_HILLS ) )
act_move.c:	SET_BIT(ch->affected_by, AFF_CAMOUFLAGE);
act_move.c:	REMOVE_BIT(ch->affected_by,AFF_CAMOUFLAGE);
act_move.c:/* Creep - Camo sneak -- Dioxide */
act_move.c:	af.level     = ch->level;
act_move.c:	wait = 100 - chance;
act_move.c:    if (ch->in_room->sector_type != SECT_CITY && ch->in_room->sector_type != SECT_INSIDE &&
act_move.c:	ch->in_room->sector_type != SECT_ROAD && !IS_IMMORTAL(ch))
act_move.c:	if (ch->Class()->GetIndex() == CLASS_ASSASSIN && ch->pause > 8)
act_move.c:	SET_BIT(ch->affected_by, AFF_HIDE);
act_move.c:	REMOVE_BIT( ch->affected_by, AFF_CAMOUFLAGE );
act_move.c:    REMOVE_BIT   ( ch->affected_by, AFF_HIDE		);
act_move.c:    REMOVE_BIT   ( ch->affected_by, AFF_INVISIBLE	);
act_move.c:    if(IS_SET(race_table[ch->race].aff, AFF_SNEAK))
act_move.c:		REMOVE_BIT   ( ch->affected_by, AFF_SNEAK		);
act_move.c:    if (IS_NPC(ch) && !IS_SET(ch->act,ACT_PET))
act_move.c:	if (ch->level > 15 && !IS_IMMORTAL(ch) && !ch->ghost)
act_move.c:	location = get_room_index(hometown_table[ch->hometown].recall);
act_move.c:    if ( ch->in_room == location )
act_move.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
act_move.c:    if ( ( victim = ch->fighting ) != NULL) {
act_move.c:    ch->move /= 2;
act_move.c:    if (ch->pet != NULL)
act_move.c:		do_recall(ch->pet,"");
act_move.c:    sh_int stat = - 1;
act_move.c:    for ( mob = ch->in_room->people; mob; mob = mob->next_in_room )
act_move.c:	if ( IS_NPC(mob) && IS_SET(mob->act, ACT_TRAIN) )
act_move.c:	sprintf( buf, "You have %d training sessions.\n\r", ch->train );
act_move.c:	if ( ch->perm_stat[STAT_STR] < get_max_train(ch,STAT_STR))
act_move.c:	if ( ch->perm_stat[STAT_INT] < get_max_train(ch,STAT_INT))
act_move.c:	if ( ch->perm_stat[STAT_WIS] < get_max_train(ch,STAT_WIS))
act_move.c:	if ( ch->perm_stat[STAT_DEX] < get_max_train(ch,STAT_DEX))
act_move.c:	if ( ch->perm_stat[STAT_CON] < get_max_train(ch,STAT_CON))
act_move.c:    	if ( cost > ch->train )
act_move.c:	ch->train -= cost;
act_move.c:        ch->pcdata->perm_hit += 10;
act_move.c:        ch->max_hit += 10;
act_move.c:        ch->hit +=10;
act_move.c:        if ( cost > ch->train )
act_move.c:	ch->train -= cost;
act_move.c:        ch->pcdata->perm_mana += 10;
act_move.c:        ch->max_mana += 10;
act_move.c:        ch->mana += 10;
act_move.c:    if ( ch->perm_stat[stat]  >= get_max_train(ch,stat) )
act_move.c:    if ( cost > ch->train )
act_move.c:    ch->train		-= cost;
act_move.c:    ch->perm_stat[stat]		+= 1;
act_move.c:    || (ch->level < skill_table[gsn_bear_call].skill_level[ch->Class()->GetIndex()]) )
act_move.c:    if (ch->mana <= 70)
act_move.c:    for (check = char_list; check != NULL; check = check->next)
act_move.c:        if  ( (check->master == ch)
act_move.c:	 && check->pIndexData->vnum == MOB_VNUM_BEAR )
act_move.c:    if ( (ch->in_room->sector_type != SECT_FOREST)
act_move.c:    && (ch->in_room->sector_type != SECT_HILLS)
act_move.c:    && (ch->in_room->sector_type != SECT_MOUNTAIN) )
act_move.c:    if (number_percent() > ch->pcdata->learned[gsn_bear_call])
act_move.c:    ch->mana -= 35;
act_move.c:    ch->mana -= 70;
act_move.c:    a_level = ch->level;
act_move.c:    animal->level = a_level;
act_move.c:    animal->max_hit = ch->max_hit + dice(a_level, 5);
act_move.c:    animal->damroll += a_level*3/4;
act_move.c:    animal->hitroll += a_level/3;
act_move.c:    animal->alignment = ch->alignment;
act_move.c:    animal->cabal = ch->cabal;
act_move.c:    char_to_room(animal,ch->in_room);
act_move.c:    animal->leader = ch;
act_move.c:    SET_BIT(animal->affected_by,AFF_CHARM);
act_move.c:    animal->hit = animal->max_hit;
act_move.c:    af.level = ch->level;
act_move.c:    || ch->level < skill_table[gsn_animal_call].skill_level[ch->Class()->GetIndex()])
act_move.c:	if (ch->level < 25)
act_move.c:	if (ch->level < 30)
act_move.c:	if (ch->level < 35)
act_move.c:    if (ch->mana < 50)
act_move.c:    for (mob = char_list; mob != NULL; mob = mob->next)
act_move.c:        && (mob->master == ch)
act_move.c:        && ( (mob->pIndexData->vnum == MOB_VNUM_FALCON)
act_move.c:        || (mob->pIndexData->vnum == MOB_VNUM_WOLF)
act_move.c:        || (mob->pIndexData->vnum == MOB_VNUM_BEAR)
act_move.c:        || (mob->pIndexData->vnum == MOB_VNUM_LION) ) )
act_move.c:    if ( (ch->in_room->sector_type != SECT_FOREST)
act_move.c:    && ( ch->in_room->sector_type != SECT_HILLS)
act_move.c:    && ( ch->in_room->sector_type != SECT_MOUNTAIN) )
act_move.c:    ch->mana -= 25;
act_move.c:    pRoomIndex = ch->in_room;
act_move.c:        ch->mana -= 25;
act_move.c:    animal2->dam_type = animal1->dam_type;
act_move.c:        animal1->armor[i] = 0;
act_move.c:        animal2->armor[i] = 0;
act_move.c:        animal1->max_hit = ch->max_hit/3;
act_move.c:        animal1->hit = ch->max_hit/3;
act_move.c:        animal2->max_hit = ch->max_hit/3;
act_move.c:        animal2->hit = ch->max_hit/3;
act_move.c:        animal1->damroll = (5 + ch->level/3);
act_move.c:        animal2->damroll = (5 + ch->level/3);
act_move.c:        animal1->hitroll = ch->level/3;
act_move.c:        animal2->hitroll = ch->level/3;
act_move.c:        animal1->max_hit = ch->max_hit/2;
act_move.c:        animal1->hit = ch->max_hit/2;
act_move.c:        animal2->max_hit = ch->max_hit/2;
act_move.c:        animal2->hit = ch->max_hit/2;
act_move.c:        animal1->damroll = (8 + ch->level/3);
act_move.c:        animal2->damroll = (8 + ch->level/3);
act_move.c:        animal1->hitroll = ch->level/3;
act_move.c:        animal2->hitroll = ch->level/3;
act_move.c:        animal1->max_hit = ch->max_hit;
act_move.c:        animal1->hit = ch->max_hit;
act_move.c:        animal2->max_hit = ch->max_hit;
act_move.c:        animal2->hit = ch->max_hit;
act_move.c:        animal1->damroll = (2*ch->level/3);
act_move.c:        animal2->damroll = (2*ch->level/3);
act_move.c:        animal1->hitroll = ch->level/3;
act_move.c:        animal2->hitroll = ch->level/3;
act_move.c:        animal1->max_hit = (3 * ch->max_hit / 4);
act_move.c:        animal1->hit = (3 * ch->max_hit / 4);
act_move.c:        animal2->max_hit = (3 * ch->max_hit / 4);
act_move.c:        animal2->hit = (3 * ch->max_hit / 4);
act_move.c:        animal1->damroll = (-2 + ch->level);
act_move.c:        animal2->damroll = (-2 + ch->level);
act_move.c:        animal1->hitroll = ch->level/3;
act_move.c:        animal2->hitroll = ch->level/3;
act_move.c:    ch->mana -= 25;
act_move.c:    animal1->level = ch->level;
act_move.c:    animal2->level = ch->level;
act_move.c:    ch->mana -= 50;
act_move.c:    SET_BIT(animal1->affected_by,AFF_CHARM);
act_move.c:    SET_BIT(animal2->affected_by,AFF_CHARM);
act_move.c:    animal1->leader = ch;
act_move.c:    animal2->leader = ch;
act_move.c:    animal1->master = ch;
act_move.c:    animal2->master = ch;
act_move.c:    animal1->cabal  = ch->cabal;
act_move.c:    animal2->cabal  = ch->cabal;
act_move.c:    af.level = ch->level;
act_move.c:	if (mob->in_room == NULL)
act_move.c:		if (mob->in_room->tracks[i] && mob->in_room->tracks[i]->prey == ch)	 {
act_move.c:	if (mob->in_room->tracks[i]->prey != ch)
act_move.c:    track_dir = mob->in_room->tracks[i]->direction;
act_move.c:    if(IS_SET(mob->act,ACT_SENTINEL))
act_move.c:    if (IS_SET(mob->off_flags,STATIC_TRACKING) || track_dir == -1)
act_move.c:	pexit = mob->in_room->exit[track_dir];
act_move.c:	if (!IS_NPC(mob) || !IS_SET(mob->act,ACT_SMARTTRACK))
act_move.c:	if(IS_SET(mob->act,ACT_SENTINEL) || IS_AFFECTED(ch, AFF_NOSHOW))
act_move.c:	if (IS_SET(mob->off_flags,STATIC_TRACKING))
act_move.c:	if (ch->in_room == mob->in_room)
act_move.c:    if (ch->in_room->area != mob->in_room->area)
act_move.c:	if (mob->fighting)
act_move.c:	mob->path = NULL;
act_move.c:	path->room = mob->in_room;
act_move.c:	path->steps = 0;
act_move.c:	mob->path = path;
act_move.c:	mob->in_room->path = path;
act_move.c:	find_path(mob->path, ch->in_room);
act_move.c:		bug ("Some weird tracking shit just happened with mob vnum %d.",mob->pIndexData->vnum);
act_move.c:	 	sprintf(buf,"MOB %s tracking from ROOM %d to ROOM %d -- %d iterations.\n\r",
act_move.c:			 mob->name, mob->in_room->vnum,
act_move.c:			 ch->in_room->vnum,iterations);
act_move.c:		if (!solve->prev->prev)
act_move.c:		solve = solve->prev;
act_move.c:	sprintf(buf,"MOB %s tracking from ROOM %d to ROOM %d -- %d iterations.\n\r",
act_move.c:		mob->name, mob->in_room->vnum, ch->in_room->vnum,iterations);
act_move.c:	move_char(mob,solve->dir_from,FALSE,TRUE);
act_move.c:	free_path(mob->path);
act_move.c:	for (room = room_list; room != NULL; room = room->next_room)
act_move.c:		if (room->path)
act_move.c:			room->path = NULL;
act_move.c:	if(IS_SET(mob->act,ACT_SENTINEL))
act_move.c:	if (mob->in_room == goal)
act_move.c:    if (mob->in_room->area != goal->area)
act_move.c:	if (mob->fighting)
act_move.c:	mob->path = NULL;
act_move.c:	path->room = mob->in_room;
act_move.c:	path->steps = 0;
act_move.c:	mob->path = path;
act_move.c:	mob->in_room->path = path;
act_move.c:	find_path(mob->path, goal);
act_move.c:		return bug ("Some weird tracking shit just happened with mob vnum %d.",mob->pIndexData->vnum);
act_move.c:		if (!solve->prev->prev)
act_move.c:		solve = solve->prev;
act_move.c:/*	sprintf(buf,"MOB %s walking from ROOM %d to ROOM %d -- %d iterations.\n\r",
act_move.c:		mob->name, mob->in_room->vnum, goal->vnum ,iterations);
act_move.c:	move_char(mob,solve->dir_from,FALSE,TRUE);
act_move.c:	free_path(mob->path);
act_move.c:	for (room = room_list; room != NULL; room = room->next_room)
act_move.c:		if (room->path)
act_move.c:			room->path = NULL;
act_move.c:	path->evaluated = TRUE;
act_move.c:	if (path->room == goal) {
act_move.c:		if (!best_path || best_path->steps > path->steps)
act_move.c:		if ((best_path && best_path->steps < 2)
act_move.c:			|| (path->room->exit[i]
act_move.c:			&& path->room->exit[i]->u1.to_room
act_move.c:			&& (path->room->exit[i]->u1.to_room->area == goal->area)
act_move.c:			&& !(path->room->exit[i]->u1.to_room->path
act_move.c:			&& path->room->exit[i]->u1.to_room->path->steps <= path->steps + 1
act_move.c:			&& path->room->exit[i]->u1.to_room->path->evaluated == TRUE)
act_move.c:			&& !(path->room->exit[i]->u1.to_room->path
act_move.c:			&& path->room->exit[i]->u1.to_room->path->steps < path->steps + 1
act_move.c:			&& path->room->exit[i]->u1.to_room->path->evaluated == FALSE)))
act_move.c:			path->dir_to[i] = NULL;
act_move.c:		if (!path->room->exit[i]
act_move.c:			|| !path->room->exit[i]->u1.to_room
act_move.c:			|| (path->room->exit[i]->u1.to_room->area != goal->area)
act_move.c:			|| (path->room->exit[i]->u1.to_room->path
act_move.c:			&& path->room->exit[i]->u1.to_room->path->steps <= path->steps + 1
act_move.c:			&& path->room->exit[i]->u1.to_room->path->evaluated == TRUE)
act_move.c:			|| (path->room->exit[i]->u1.to_room->path
act_move.c:			&& path->room->exit[i]->u1.to_room->path->steps < path->steps + 1
act_move.c:			&& path->room->exit[i]->u1.to_room->path->evaluated == FALSE))
act_move.c:		next_path->room		= path->room->exit[i]->u1.to_room;
act_move.c:		next_path->dir_from	= i;
act_move.c:		next_path->steps	= path->steps + 1;
act_move.c:		next_path->prev		= path;
act_move.c:		path->dir_to[i]		= next_path;
act_move.c:		path->room->exit[i]->u1.to_room->path = next_path;
act_move.c:		if (!path->room->exit[i]
act_move.c:			|| !path->dir_to[i]
act_move.c:			|| !path->room->exit[i]->u1.to_room
act_move.c:			|| (path->room->exit[i]->u1.to_room->area != goal->area)
act_move.c:			|| path->room->exit[i]->u1.to_room->path->evaluated == TRUE)
act_move.c:		find_path(path->dir_to[i], goal);
act_move.c:	|| ch->level < skill_table[gsn_aura_of_sustenance].skill_level[ch->Class()->GetIndex()])
act_move.c:    if (ch->mana < 40)
act_move.c:    af.level = ch->level;
act_move.c:    af.duration = ch->level;
act_move.c:    ch->pcdata->condition[COND_THIRST] = 1;
act_move.c:    ch->pcdata->condition[COND_HUNGER] = 1;
act_move.c:    ch->mana -= 40;
act_move.c:	|| ch->level < skill_table[gsn_vanish].skill_level[ch->Class()->GetIndex()])
act_move.c:    if (ch->mana < 20)
act_move.c:    if (number_percent() > (chance*.95) || IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL) || IS_SET(ch->in_room->room_flags, ROOM_NO_SUMMON_FROM))
act_move.c:    	ch->mana -= 10;
act_move.c:    ch->mana -= 20;
act_move.c:		if (pRoomIndex->area == ch->in_room->area
act_move.c:			&& !IS_SET(pRoomIndex->room_flags,ROOM_PRIVATE)
act_move.c:			&& (pRoomIndex->guild == 0)
act_move.c:			&& !IS_SET(pRoomIndex->room_flags,ROOM_SOLITARY)
act_move.c:			&& ch->in_room->vnum != 1212
act_move.c:			&& pRoomIndex->vnum != 1212) {
act_move.c:		ch->mana += 20;
act_move.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch_next)
act_move.c:		rch_next = rch->next_in_room;
act_move.c:		if (!IS_SET(rch->off_flags,SPAM_MURDER)) 	continue;
act_move.c:		if (rch->fighting != NULL)	continue;
act_move.c:		if (rch->last_fought != NULL)	continue;
act_move.c:		if (rch->level < (ch->level - 5))	continue;
act_move.c:		sprintf(buf,"Help! I'm being attacked by %s!",rch->short_descr);
act_move.c:    	|| ch->level < skill_table[gsn_door_bash].skill_level[ch->Class()->GetIndex()]))
act_move.c:	if (ch->move < 5)
act_move.c:    pexit = ch->in_room->exit[door];
act_move.c:	if (!IS_SET(pexit->exit_info,EX_CLOSED))
act_move.c:    if (!IS_SET(pexit->exit_info,EX_LOCKED)
act_move.c:		&& !IS_SET(pexit->exit_info,EX_JAMMED))
act_move.c:		chance += ch->carry_weight/10;
act_move.c:		if (!str_cmp(pc_race_table[ch->race].name,"planar")
act_move.c:			|| !str_cmp(pc_race_table[ch->race].name,"abyss")
act_move.c:			|| !str_cmp(pc_race_table[ch->race].name,"celestial"))
act_move.c:    if (number_percent() > chance || IS_SET(pexit->exit_info,EX_NOBASH) ) {
act_move.c:		if (pexit->u1.to_room->people)
act_move.c:			act("The door buckles as a heavy weight crashes against it from the other side!",pexit->u1.to_room->people,0,0,TO_ALL);
act_move.c:		damage_new(ch,ch,dice(ch->level,2),gsn_door_bash,DAM_BASH,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the impact*");
act_move.c:		ch->position = POS_RESTING;
act_move.c:    REMOVE_BIT(pexit->exit_info,EX_LOCKED);
act_move.c:    REMOVE_BIT(pexit->exit_info,EX_CLOSED);
act_move.c:	REMOVE_BIT(pexit->exit_info,EX_JAMMED);
act_move.c:    if ( ( (to_room = pexit->u1.to_room) != NULL)
act_move.c:    && ( pexit_rev = to_room->exit[rev_dir[door]] ) != NULL
act_move.c:    && pexit_rev->u1.to_room == ch->in_room) {
act_move.c:        REMOVE_BIT(pexit_rev->exit_info,EX_LOCKED);
act_move.c:        REMOVE_BIT(pexit_rev->exit_info,EX_CLOSED);
act_move.c:		REMOVE_BIT(pexit_rev->exit_info,EX_JAMMED);
act_move.c:    af.duration = -1;
act_move.c:    af.level = ch->level;
act_move.c:	if (ch->in_room->vnum != 0)//ROOM_VNUM_HOMETOWNS)
act_move.c:	cost = 50*(ch->level * ch->level);
act_move.c:				if (ch->hometown == i)
act_move.c:					sprintf(buf,"%-18s (Current hometown)\n\r",hometown_table[i].name);
act_move.c:					sprintf(buf,"%-18s %d gold.\n\r",hometown_table[i].name,cost);
act_move.c:		if (ch->gold < cost)
act_move.c:		if (hometown == ch->hometown)
act_move.c:			ch->hometown = hometown;
act_move.c:	for(blocker = ch->in_room->people; blocker != NULL; blocker = blocker->next_in_room) {
act_move.c:		if(IS_NPC(blocker) && blocker->pIndexData->barred_entry &&
act_move.c:			blocker->pIndexData->barred_entry->vnum == to_room->vnum) {
act_move.c:			if(blocker->pIndexData->barred_entry->type == BAR_CLASS)
act_move.c:				field = ch->Class()->GetIndex();
act_move.c:			if(blocker->pIndexData->barred_entry->type == BAR_CABAL)
act_move.c:				field = ch->cabal;
act_move.c:			if(blocker->pIndexData->barred_entry->type == BAR_SIZE)
act_move.c:				field = ch->size;
act_move.c:			if(blocker->pIndexData->barred_entry->type == BAR_LEVEL)
act_move.c:				field = ch->level;
act_move.c:			if(blocker->pIndexData->barred_entry->type == BAR_TATTOO) {
act_move.c:				if(!tattoo && blocker->pIndexData->barred_entry->value)
act_move.c:				field = tattoo->pIndexData->vnum;
act_move.c:			if(blocker->pIndexData->barred_entry->type == BAR_CLASS && 
act_move.c:				ch->Class()->GetIndex() == blocker->pIndexData->barred_entry->value &&
act_move.c:				IS_SET(blocker->act, ACT_GUILDGUARD)
act_move.c:				&& ch->pause > 0 && ch->ghost <= 0 && !IS_IMMORTAL(ch))
act_move.c:			if((blocker->pIndexData->barred_entry->comparison == BAR_EQUAL_TO
act_move.c:				&& field != blocker->pIndexData->barred_entry->value)
act_move.c:				|| (blocker->pIndexData->barred_entry->comparison == BAR_LESS_THAN
act_move.c:				&& field >= blocker->pIndexData->barred_entry->value)
act_move.c:				|| (blocker->pIndexData->barred_entry->comparison == BAR_GREATER_THAN
act_move.c:				&& field <= blocker->pIndexData->barred_entry->value))
act_move.c:	str = palloc_string(blocker->pIndexData->barred_entry->message);
act_move.c:	if(blocker->pIndexData->barred_entry->msg_type == BAR_SAY)
act_move.c:	if(blocker->pIndexData->barred_entry->msg_type == BAR_EMOTE)
act_move.c:	if(blocker->pIndexData->barred_entry->msg_type == BAR_ECHO)
act_move.c:		if(blocker->pIndexData->barred_entry->message_two)
act_move.c:			strtwo = palloc_string(blocker->pIndexData->barred_entry->message_two);
act_move.c:			if(!IS_IMMORTAL(ch) || ch->invis_level<LEVEL_HERO+1)
act_move.c:				sprintf(buf2,"%s",ch->name);
act_move.c:				sprintf(buf2,"%s",blocker->short_descr);
act_move.c:				sprintf(buf2,"%s",ch->in_room->name);
act_move.c:				sprintf(buf2,"%s",to_room->name);
act_move.c:	if (room->sector_type == SECT_WATER
act_move.c:		|| room->sector_type == SECT_UNDERWATER
act_move.c:		|| room->sector_type == SECT_AIR)
act_move.c:	if (room->tracks[0] == NULL)
act_move.c:	if (room->tracks[0]->prey != NULL) {
act_move.c:		for (i=MAX_TRACKS-1; i > 0; i--) {
act_move.c:			room->tracks[i]->prey = room->tracks[i-1]->prey;
act_move.c:			room->tracks[i]->time = room->tracks[i-1]->time;
act_move.c:			room->tracks[i]->direction = room->tracks[i-1]->direction;
act_move.c:			room->tracks[i]->flying = room->tracks[i-1]->flying;
act_move.c:			room->tracks[i]->sneaking = room->tracks[i-1]->sneaking;
act_move.c:			room->tracks[i]->bleeding = room->tracks[i-1]->bleeding;
act_move.c:			room->tracks[i]->legs = room->tracks[i-1]->legs;
act_move.c:	room->tracks[0]->prey = ch;
act_move.c:	room->tracks[0]->time = time_info;
act_move.c:	room->tracks[0]->direction = direction;
act_move.c:	room->tracks[0]->flying = (IS_AFFECTED(ch, AFF_FLYING));
act_move.c:	room->tracks[0]->sneaking = (IS_AFFECTED(ch, AFF_SNEAK));
act_move.c:	room->tracks[0]->bleeding = (is_affected(ch, gsn_bleeding));
act_move.c:	room->tracks[0]->legs = ch->legs;
act_move.c:	for (i=0; i<MAX_TRACKS - 1; i++) {
act_move.c:		room->tracks[i]->prey = NULL;
act_move.c:		room->tracks[i]->direction = -1;
act_move.c:		room->tracks[i]->flying = FALSE;
act_move.c:		room->tracks[i]->sneaking = FALSE;
act_move.c:		room->tracks[i]->bleeding = FALSE;
act_move.c:		room->tracks[i]->legs = -1;
act_obj.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
act_obj.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
act_obj.c:    if (obj->item_type == ITEM_CORPSE_PC && (!IS_NPC(ch) || IS_AFFECTED(ch,AFF_CHARM)))
act_obj.c:((ch->master == NULL) ? "Unknown mob" : ch->master->name) : ch->name,
act_obj.c:obj->short_descr);
act_obj.c:	ch->pause = 5;
act_obj.c:    if (obj->item_type != ITEM_CORPSE_PC)
act_obj.c:    if (!obj->owner || obj->owner == NULL)
act_obj.c:    if(!str_cmp(ch->true_name,obj->owner))
act_obj.c:    if(!IS_NPC(ch) && ch->pcdata->newbie==TRUE)
act_obj.c:    for ( wch = char_list; wch != NULL ; wch = wch->next )
act_obj.c:        if (!IS_NPC(wch) && obj->owner && !str_cmp(wch->true_name,obj->owner))
act_obj.c:    if (!str_cmp(ch->true_name,owner->true_name))
act_obj.c:    if (IS_SET(owner->act,PLR_CANLOOT))
act_obj.c:	if (obj->item_type == ITEM_CORPSE_PC && !IS_IMMORTAL(ch))
act_obj.c:    if ( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
act_obj.c:    if ((!obj->in_obj || obj->in_obj->carried_by != ch)
act_obj.c:    if (obj->in_room != NULL)
act_obj.c:		for (gch = obj->in_room->people; gch != NULL; gch = gch->next_in_room)
act_obj.c:	    	if (gch->on == obj)
act_obj.c:    	if (container->pIndexData->vnum == OBJ_VNUM_PIT
act_obj.c:	    	obj->timer = 0;	
act_obj.c:    if ( obj->item_type == ITEM_MONEY)
act_obj.c:		ch->gold += obj->value[1];
act_obj.c:        if (IS_SET(ch->act,PLR_AUTOSPLIT))
act_obj.c:    	  for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
act_obj.c:	  	if ( members > 1 && (obj->value[0] > 1 || obj->value[1]))
act_obj.c:	    	sprintf(buffer,"%d",obj->value[1]);
act_obj.c:		if (IS_SET(obj->progtypes,IPROG_GET))
act_obj.c:			(obj->pIndexData->iprogs->get_prog) (obj,ch);
act_obj.c:		if (ch->pcdata->death_status == HAS_DIED)
act_obj.c:	    	obj = get_obj_list( ch, arg1, ch->in_room->contents );
act_obj.c:	    	if ( obj == NULL || (IS_SET(obj->extra_flags, ITEM_NOSHOW) && !IS_IMMORTAL(ch)))
act_obj.c:				obj_to_room(obj,ch->in_room);
act_obj.c:	    	for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next ) {
act_obj.c:				obj_next = obj->next_content;
act_obj.c:				if(IS_SET(obj->extra_flags, ITEM_NOSHOW) && !IS_IMMORTAL(ch))
act_obj.c:				if ( ( arg1[3] == '\0' || is_name( &arg1[4], obj->name ) )
act_obj.c:						obj_to_room(obj,ch->in_room);
act_obj.c:		switch ( container->item_type ) {
act_obj.c:		if ( IS_SET_OLD(container->value[1], CONT_CLOSED) )
act_obj.c:   	 		return act( "The $d is closed.", ch, NULL, container->name, TO_CHAR );
act_obj.c:			obj = get_obj_list( ch, arg1, container->contains );
act_obj.c:	        if (IS_SET(container->progtypes,IPROG_LOOT))
act_obj.c:				if (((container->pIndexData->iprogs->loot_prog)
act_obj.c:				damage_new(ch,ch,dice(ch->level,2),gsn_noxious_ward,DAM_OTHER,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the noxious ward*");
act_obj.c:			obj_to_room(obj,ch->in_room);
act_obj.c:		    for ( obj = container->contains; obj != NULL; obj = obj_next )
act_obj.c:				obj_next = obj->next_content;
act_obj.c:				if ( ( arg1[3] == '\0' || is_name( &arg1[4], obj->name ) )
act_obj.c:					if (IS_SET(container->progtypes,IPROG_LOOT))
act_obj.c:						if (((container->pIndexData->iprogs->loot_prog)
act_obj.c:						obj_to_room(obj,ch->in_room);
act_obj.c:    if ( container->item_type != ITEM_CONTAINER )
act_obj.c:    if ( IS_SET_OLD(container->value[1], CONT_CLOSED) )
act_obj.c:		return act( "The $d is closed.", ch, NULL, container->name, TO_CHAR );
act_obj.c:	if (obj->pIndexData->limtotal > 0 && container->pIndexData->vnum != 31 )
act_obj.c:    if (WEIGHT_MULT(obj) != 100  && container->pIndexData->vnum != 31)
act_obj.c:	if ((get_contents_number(container)) >= container->value[0] ||
act_obj.c:		(get_contents_weight(container) + get_true_weight(obj) > container->value[3]))
act_obj.c:	if (container->pIndexData->vnum == OBJ_VNUM_PIT
act_obj.c:	        obj->timer = number_range(100,200);
act_obj.c:			if(IS_SET_OLD(container->value[1],CONT_PUT_ON)) {
act_obj.c:			if(IS_SET_OLD(container->value[1],CONT_PUT_ON))
act_obj.c:		if (IS_SET_OLD(container->value[1],CONT_PUT_ON))
act_obj.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
act_obj.c:	    obj_next = obj->next_content;
act_obj.c:	    if ( ( arg1[3] == '\0' || is_name( &arg1[4], obj->name ) )
act_obj.c:	    &&   obj->wear_loc == WEAR_NONE
act_obj.c:	    &&   obj->pIndexData->limtotal <= 0
act_obj.c:            && (get_contents_number(container)) < container->value[0]
act_obj.c:            &&  (get_contents_weight(container) + get_true_weight(obj) <= container->value[3])
act_obj.c:	    	if (container->pIndexData->vnum == OBJ_VNUM_PIT
act_obj.c:	    	    	obj->timer = number_range(100,200);
act_obj.c:		if (IS_SET_OLD(container->value[1],CONT_PUT_ON))
act_obj.c:	    if (ch->gold < amount)
act_obj.c:	    ch->gold -= amount;
act_obj.c:	for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
act_obj.c:	    obj_next = obj->next_content;
act_obj.c:	    switch ( obj->pIndexData->vnum )
act_obj.c:		gold += obj->value[1];
act_obj.c:		gold += obj->value[1];
act_obj.c:	obj_to_room( create_money( gold ), ch->in_room );
act_obj.c:	obj_to_room( obj, ch->in_room );
act_obj.c:	if (IS_SET(obj->progtypes,IPROG_DROP))
act_obj.c:		(obj->pIndexData->iprogs->drop_prog) (obj,ch);
act_obj.c:	if (IS_SET(ch->in_room->progtypes, RPROG_DROP))
act_obj.c:		(ch->in_room->rprogs->drop_prog) (ch->in_room, ch, obj);
act_obj.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
act_obj.c:	    obj_next = obj->next_content;
act_obj.c:	    if ( ( arg[3] == '\0' || is_name( &arg[4], obj->name ) )
act_obj.c:	    &&   obj->wear_loc == WEAR_NONE
act_obj.c:		obj_to_room( obj, ch->in_room );
act_obj.c:		if (IS_SET(obj->progtypes,IPROG_DROP))
act_obj.c:			(obj->pIndexData->iprogs->drop_prog) (obj,ch);
act_obj.c:		if (IS_SET(ch->in_room->progtypes, RPROG_DROP))
act_obj.c:			(ch->in_room->rprogs->drop_prog) (ch->in_room, ch, obj);
act_obj.c:	if (ch->gold < amount)
act_obj.c:	    ch->gold		-= amount;
act_obj.c:	    victim->gold	+= amount;
act_obj.c:        if (IS_SET(victim->progtypes,MPROG_BRIBE))
act_obj.c:          (victim->pIndexData->mprogs->bribe_prog) (victim,ch,amount);
act_obj.c:	if(amount>999 && ch->cabal==CABAL_BOUNTY)
act_obj.c:		sprintf(buf,"%s gives %d gold to %s.",ch->name,amount,victim->true_name);
act_obj.c:    if ( obj->wear_loc != WEAR_NONE )
act_obj.c:    if ((IS_NPC(victim) && victim->pIndexData->pShop != NULL) && !IS_SET(victim->progtypes, MPROG_GIVE) )
act_obj.c:    if ( victim->carry_number + get_obj_number( obj ) > can_carry_n( victim ) )
act_obj.c:    if (IS_SET(obj->progtypes,IPROG_GIVE))
act_obj.c:        if((obj->pIndexData->iprogs->give_prog) (obj,ch,victim) == TRUE);
act_obj.c:    if (IS_SET(victim->progtypes,MPROG_GIVE))
act_obj.c:      	(victim->pIndexData->mprogs->give_prog) (victim,ch,obj);
act_obj.c:	|| (ch->level < skill_table[gsn_skin].skill_level[ch->Class()->GetIndex()]) )
act_obj.c:    if (ch->mana < 25)
act_obj.c:    for (find_corpse = ch->carrying; find_corpse != NULL; find_corpse = find_corpse->next_content)
act_obj.c:	if (find_corpse->wear_loc == WEAR_NONE && (can_see_obj(ch,find_corpse) )
act_obj.c:    	    && ( arg1[0] == '\0' || is_name(arg1,find_corpse->name)) )
act_obj.c:    if ((corpse->item_type != ITEM_CORPSE_NPC) && (corpse->item_type != ITEM_CORPSE_PC))
act_obj.c:   if (number_percent() > ch->pcdata->learned[gsn_skin])
act_obj.c:	ch->mana -= 25;
act_obj.c:    name = corpse->short_descr;
act_obj.c:    for (obj = corpse->contains; obj != NULL; obj = obj_next)
act_obj.c:	obj_next = obj->next_content;
act_obj.c:	obj_to_room(obj,ch->in_room);
act_obj.c:    sack->level = corpse->level;
act_obj.c:    free_pstring(sack->short_descr);
act_obj.c:    free_pstring(sack->description);
act_obj.c:    sack->short_descr = palloc_string(buf1);
act_obj.c:    sack->description = palloc_string(buf2);
act_obj.c:    ch->mana -= 25;
act_obj.c:    af.level = ch->level;
act_obj.c:	|| (ch->level < skill_table[gsn_butcher].skill_level[ch->Class()->GetIndex()]) )
act_obj.c:    for (find_corpse = ch->in_room->contents;  find_corpse != NULL; find_corpse = find_corpse->next_content)
act_obj.c:    	    && ( arg1[0] == '\0' || is_name(arg1,find_corpse->name)) )
act_obj.c:    if ((corpse->item_type != ITEM_CORPSE_NPC) && (corpse->item_type != ITEM_CORPSE_PC))
act_obj.c:   if (number_percent() > ch->pcdata->learned[gsn_butcher])
act_obj.c:    name = corpse->short_descr;
act_obj.c:    for (obj = corpse->contains; obj != NULL; obj = obj_next)
act_obj.c:	obj_next = obj->next_content;
act_obj.c:	obj_to_room(obj,ch->in_room);
act_obj.c:    steak->level = corpse->level;
act_obj.c:    free_pstring(steak->short_descr);
act_obj.c:    free_pstring(steak->description);
act_obj.c:    steak->short_descr = palloc_string(buf1);
act_obj.c:    steak->description = palloc_string(buf2);
act_obj.c:    obj_to_room(steak,ch->in_room);
act_obj.c:    obj =  get_obj_list(ch,argument,ch->carrying);
act_obj.c:    if (obj->item_type == ITEM_FOOD || obj->item_type == ITEM_DRINK_CON)
act_obj.c:	    if (!obj->value[3])
act_obj.c:		obj->value[3] = 1;
act_obj.c:	if (!obj->value[3])
act_obj.c:    if (obj->item_type == ITEM_WEAPON)
act_obj.c:	if (obj->value[3] < 0
act_obj.c:	||  attack_table[obj->value[3]].damage == DAM_BASH)
act_obj.c:            oaf.level     = ch->level * percent / 100;
act_obj.c:            oaf.duration  = ch->level/2 * percent / 100;
act_obj.c:    for ( fountain = ch->in_room->contents; fountain != NULL;
act_obj.c:	fountain = fountain->next_content )
act_obj.c:	if ( fountain->item_type == ITEM_FOUNTAIN )
act_obj.c:    if ( obj->item_type != ITEM_DRINK_CON )
act_obj.c:    if ( obj->value[1] != 0 && obj->value[2] != fountain->value[2] )
act_obj.c:    if ( obj->value[1] >= obj->value[0] )
act_obj.c:	liq_table[fountain->value[2]].liq_name);
act_obj.c:	liq_table[fountain->value[2]].liq_name);
act_obj.c:    obj->value[2] = fountain->value[2];
act_obj.c:    obj->value[1] = obj->value[0];
act_obj.c:/* new pour - dio */
act_obj.c:	if (out->item_type != ITEM_DRINK_CON)
act_obj.c:	if (out->value[1] == 0)
act_obj.c:		out->value[1] = 0;
act_obj.c:		out->value[3] = 0;
act_obj.c:		sprintf(buf,"You invert $p, spilling %s all over the ground.", liq_table[out->value[2]].liq_name);
act_obj.c:		sprintf(buf,"$n inverts $p, spilling %s all over the ground.", liq_table[out->value[2]].liq_name);
act_obj.c:		if (out->value[2] != LIQ_WATER) {
act_obj.c:			sprintf(buf, "%s evaporates rapidly and is gone.",liq_table[out->value[2]].liq_name);
act_obj.c:		} else if (IS_GROUND(ch->in_room)) {
act_obj.c:			puddle = create_object(get_obj_index(OBJ_VNUM_PUDDLE),ch->level);
act_obj.c:			obj_to_room(puddle,ch->in_room);
act_obj.c:	amount = liq_table[out->value[2]].liq_affect[4] * 3;
act_obj.c:	amount = UMIN(amount, out->value[1]);
act_obj.c:	out->value[1] -= amount;
act_obj.c:    	sprintf(buf,"You pour %s from $p onto $P.",liq_table[out->value[2]].liq_name);
act_obj.c:    	sprintf(buf,"$n pours %s from $p onto $P.",liq_table[out->value[2]].liq_name);
act_obj.c:	for ( obj = ch->in_room->contents; obj; obj = obj->next_content )
act_obj.c:	    if ( obj->item_type == ITEM_FOUNTAIN )
act_obj.c:    if (ch->fighting != NULL)
act_obj.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 20 )
act_obj.c:    switch ( obj->item_type )
act_obj.c:        if ( ( liquid = obj->value[2] )  < 0 )
act_obj.c:	liquid, obj->short_descr);
act_obj.c:            liquid = obj->value[2] = 0;
act_obj.c:	if ( obj->value[1] <= 0 )
act_obj.c:	if ( ( liquid = obj->value[2] )  < 0 )
act_obj.c:	liquid, obj->short_descr);
act_obj.c:	    liquid = obj->value[2] = 0;
act_obj.c:        amount = UMIN(amount, obj->value[1]);
act_obj.c:	-(amount * liq_table[liquid].liq_affect[COND_THIRST] / 3) );
act_obj.c:	-(amount * liq_table[liquid].liq_affect[COND_HUNGER] / 3) );
act_obj.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK]  > 10 )
act_obj.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_THIRST] < 5 )
act_obj.c:    if ( obj->value[3] != 0 )
act_obj.c:		af.modifier  = -5;
act_obj.c:    if (obj->value[0] > 0)
act_obj.c:        obj->value[1] -= amount;
act_obj.c:    if (ch->fighting != NULL)
act_obj.c:	if ( obj->item_type != ITEM_FOOD && obj->item_type != ITEM_PILL )
act_obj.c:	if ( !IS_NPC(ch) && ch->pcdata->condition[COND_HUNGER] < 5 )
act_obj.c:    switch ( obj->item_type )
act_obj.c:	    condition = ch->pcdata->condition[COND_HUNGER];
act_obj.c:	    gain_condition( ch, COND_HUNGER, -(obj->value[1]*3));
act_obj.c:	    if (ch->pcdata->condition[COND_HUNGER] < COND_HUNGRY && condition > COND_HUNGRY)
act_obj.c:	    else if ( ch->pcdata->condition[COND_HUNGER] < 5 )
act_obj.c:	if ( obj->value[3] != 0 )
act_obj.c:	   	 	af.level 	 = number_fuzzy(obj->value[0]);
act_obj.c:	   	 	af.duration  = 2 * obj->value[0];
act_obj.c:	   	 	af.modifier  = -5;
act_obj.c:	obj_cast_spell( obj->value[1], obj->value[0], ch, ch, NULL );
act_obj.c:	obj_cast_spell( obj->value[2], obj->value[0], ch, ch, NULL );
act_obj.c:	obj_cast_spell( obj->value[3], obj->value[0], ch, ch, NULL );
act_obj.c:    if ( IS_SET(obj->extra_flags, ITEM_NOREMOVE) ) {
act_obj.c:	for(revealed = ch->carrying; revealed; revealed = revealed->next_content)
act_obj.c:			if(IS_SET(revealed->extra_flags, ITEM_UNDER_CLOTHES))
act_obj.c:				if(revealed->wear_flags[0] - pow(2, ITEM_WEAR_COSMETIC) == obj->wear_flags[0])
act_obj.c:		for(paf = obj->affected; paf != NULL; paf=paf->next)
act_obj.c:			if(paf->type == gsn_arms_of_light
act_obj.c:				|| paf->type == gsn_arms_of_wrath
act_obj.c:				|| paf->type == gsn_arms_of_purity
act_obj.c:				|| paf->type == gsn_arms_of_judgement)
act_obj.c:			if(paf && paf->owner != ch)
act_obj.c:				obj_to_room(obj, ch->in_room);
act_obj.c:        for(pObj = ch->carrying; pObj; pObj = pObj->next_content)
act_obj.c:                if(pObj->wear_loc == WEAR_COSMETIC)
act_obj.c:	if (!str_cmp(race_table[ch->race].name,"minotaur") && !IS_SET(obj->pIndexData->restrict_flags, MINOTAUR_ONLY)) {
act_obj.c:		sprintf(buf,"Your horns prevent you from donning %s.\n\r",obj->short_descr);
act_obj.c:		if (!str_cmp(race_table[ch->race].name,"minotaur") && !IS_SET(obj->pIndexData->restrict_flags, MINOTAUR_ONLY)) {
act_obj.c:			sprintf(buf,"Your hooves do not allow you to wear %s.\n\r",obj->short_descr);
act_obj.c:    if (weapon != NULL && (ch->size < SIZE_LARGE
act_obj.c:	|| weapon->value[0]==WEAPON_STAFF
act_obj.c:	|| weapon->value[0]==WEAPON_POLEARM
act_obj.c:	|| weapon->value[0]==WEAPON_SPEAR)))
act_obj.c:	if (obj->item_type == ITEM_POTION && ch->fighting != NULL) {
act_obj.c:    if (weapon != NULL && ((ch->size < SIZE_LARGE
act_obj.c:	|| weapon->value[0]==WEAPON_STAFF
act_obj.c:	|| weapon->value[0]==WEAPON_POLEARM
act_obj.c:	|| weapon->value[0]==WEAPON_SPEAR))
act_obj.c:    if (obj->item_type == ITEM_LIGHT)
act_obj.c:    if (weapon != NULL && ch->size < SIZE_LARGE
act_obj.c:	|| weapon->value[0]==WEAPON_STAFF
act_obj.c:	|| weapon->value[0]==WEAPON_POLEARM
act_obj.c:	|| weapon->value[0]==WEAPON_SPEAR))
act_obj.c:	if (ch->level < skill_table[gsn_dual_wield].skill_level[ch->Class()->GetIndex()]
act_obj.c:	if (ch->size < SIZE_LARGE && IS_WEAPON_STAT(obj,WEAPON_TWO_HANDS))
act_obj.c:	if (primary != NULL && ch->size < SIZE_LARGE
act_obj.c:	if (primary != NULL && ch->size < SIZE_LARGE
act_obj.c:	if (obj != NULL && (obj->value[0]==WEAPON_SPEAR ||
act_obj.c:		obj->value[0]==WEAPON_STAFF ||
act_obj.c:		obj->value[0]==WEAPON_POLEARM))
act_obj.c:	if (primary != NULL && (primary->value[0]==WEAPON_SPEAR ||
act_obj.c:		primary->value[0]==WEAPON_STAFF ||
act_obj.c:		primary->value[0]==WEAPON_POLEARM))
act_obj.c:	   if (obj->weight <= primary->weight
act_obj.c:	    || obj->weight < 5)
act_obj.c:	switch(obj->value[0])
act_obj.c:        default :               sn = -1;                break;
act_obj.c:	else if (obj->weight < secondary->weight)
act_obj.c:	switch(obj->value[0])
act_obj.c:        default :               sn = -1;                break;
act_obj.c:	    if (ch->size < SIZE_LARGE
act_obj.c:		|| obj->value[0]==WEAPON_STAFF
act_obj.c:		|| obj->value[0]==WEAPON_POLEARM
act_obj.c:		|| obj->value[0]==WEAPON_SPEAR)
act_obj.c:		&& ch->arms < 2)
act_obj.c:	  if (secondary->weight < 0.75 * obj->weight
act_obj.c:	    || secondary->weight < 5)
act_obj.c:	if ((ch->size < SIZE_LARGE && IS_WEAPON_STAT(obj,WEAPON_TWO_HANDS))
act_obj.c:	    || obj->value[0]==WEAPON_SPEAR
act_obj.c:	    || obj->value[0]==WEAPON_STAFF
act_obj.c:	    || obj->value[0]==WEAPON_POLEARM)
act_obj.c:		for(pObj = ch->carrying; pObj; pObj = pObj->next_content)
act_obj.c:				if(pObj->wear_loc == WEAR_COSMETIC)
act_obj.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
act_obj.c:	    obj_next = obj->next_content;
act_obj.c:	    if (obj->wear_loc == WEAR_NONE && can_see_obj( ch, obj ) )
act_obj.c:		!IS_SET(obj->pIndexData->wear_flags, ITEM_WEAR_WIELD) &&
act_obj.c:		!IS_SET(obj->pIndexData->wear_flags, ITEM_WEAR_SHIELD) &&
act_obj.c:		!IS_SET(obj->pIndexData->wear_flags, ITEM_WEAR_HOLD))
act_obj.c:		for ( obj = ch->carrying; obj != NULL; obj = obj_next ) {
act_obj.c:		    obj_next = obj->next_content;
act_obj.c:				if ( obj->wear_loc != WEAR_NONE
act_obj.c:       	   		    && obj->wear_loc != WEAR_BRAND )
act_obj.c:					remove_obj( ch, obj->wear_loc, TRUE );
act_obj.c:	if (obj->wear_loc == WEAR_COSMETIC)
act_obj.c:    if (obj->wear_loc == WEAR_BRAND && !IS_IMMORTAL(ch))
act_obj.c:    remove_obj( ch, obj->wear_loc, TRUE );
act_obj.c:	if (!IS_NPC(ch) && ch->pcdata->death_status == HAS_DIED)
act_obj.c:    if ( arg[0] == '\0' || !str_cmp( arg, ch->name ) )
act_obj.c:    obj = get_obj_list( ch, arg, ch->in_room->contents );
act_obj.c:    if ( obj->item_type == ITEM_CORPSE_PC )
act_obj.c:    if (obj->in_room != NULL)
act_obj.c:		for (gch = obj->in_room->people; gch != NULL; gch = gch->next_in_room)
act_obj.c:			if (gch->on == obj)
act_obj.c:    if (IS_SET(obj->progtypes,IPROG_SAC))
act_obj.c:  	if ( (obj->pIndexData->iprogs->sac_prog) (obj,ch) )
act_obj.c:    if ((obj->item_type == ITEM_CORPSE_NPC || obj->item_type == ITEM_CONTAINER) && obj->contains)
act_obj.c:            for (ibj = obj->contains ; ibj != NULL ; ibj = ibj_next)
act_obj.c:                ibj_next = ibj->next_content;
act_obj.c:                obj_to_room(ibj, obj->in_room);
act_obj.c:    if(!IS_NPC(ch) && (ch->Class()->name == "necromancer" ||
act_obj.c:		ch->Class()->name == "sorcerer" ||
act_obj.c:		ch->Class()->name == "anti-paladin"))
act_obj.c:	/* Can quaff held potions, even in combat! -- Eladrian */
act_obj.c:			if (obj->item_type == ITEM_POTION)
act_obj.c:					RS.Queue.AddToQueue(nDelay, 5, (void *)quaff_potion,ch,(void*)obj->value[0],
act_obj.c:						(void*)obj->value[1],(void*)obj->value[2],(void*)obj->value[3]);
act_obj.c:    if ( obj->item_type != ITEM_POTION )
act_obj.c:    if ( ch->fighting != NULL )
act_obj.c:  	  RS.Queue.AddToQueue(nDelay, 5, (void *)quaff_potion,ch,(void*)obj->value[0],
act_obj.c:                 (void*)obj->value[1],(void*)obj->value[2],(void*)obj->value[3]);
act_obj.c:    if ( scroll->item_type != ITEM_SCROLL )
act_obj.c:	if (scroll->pIndexData->vnum == OBJ_VNUM_SCRIBE && ch->cabal != CABAL_SCION && !IS_IMMORTAL(ch))
act_obj.c:    if ( ch->level < scroll->level)
act_obj.c:    if (ch->fighting != NULL)
act_obj.c:			obj_cast_spell( scroll->value[1], scroll->value[0], ch, victim, obj );
act_obj.c:    		obj_cast_spell( scroll->value[2], scroll->value[0], ch, victim, obj );
act_obj.c:    		obj_cast_spell( scroll->value[3], scroll->value[0], ch, victim, obj );
act_obj.c:    if ( staff->item_type != ITEM_STAFF )
act_obj.c:    if ( ( sn = staff->value[3] ) < 0
act_obj.c:    if ( staff->value[2] > 0 )
act_obj.c:	if ( ch->level < staff->level
act_obj.c:		for ( vch = ch->in_room->people; vch; vch = vch_next )
act_obj.c:	    vch_next	= vch->next_in_room;
act_obj.c:		if (vch->invis_level >= LEVEL_HERO)
act_obj.c:	    obj_cast_spell( staff->value[3], staff->value[0], ch, vch, NULL );
act_obj.c:    if ( --staff->value[2] <= 0 )
act_obj.c:    if ( arg[0] == '\0' && ch->fighting == NULL )
act_obj.c:    if ( wand->item_type != ITEM_WAND )
act_obj.c:	if ( ch->fighting != NULL )
act_obj.c:	    victim = ch->fighting;
act_obj.c:    if ( wand->value[2] > 0 )
act_obj.c: 	if (ch->level < wand->level
act_obj.c:			obj_cast_spell( wand->value[3], wand->value[0], ch, victim, obj );
act_obj.c:    if ( --wand->value[2] <= 0 )
act_obj.c:		|| ch->level<skill_table[gsn_steal].skill_level[ch->Class()->GetIndex()])
act_obj.c:    if (victim->fighting != NULL)
act_obj.c:	chance += 5 * (get_curr_stat(ch,STAT_DEX) - 20);
act_obj.c:		chance -= 5 * (victim->level - ch->level);
act_obj.c:		chance -= 2 * (victim->level - ch->level);
act_obj.c:		chance -= 25;
act_obj.c:		chance -= 10;
act_obj.c:		chance -= 2 * (get_curr_stat(victim,STAT_DEX) - 15);
act_obj.c:	if (ch->Class()->name == "anti-paladin")
act_obj.c:    if(IS_NPC(victim) && victim->pIndexData->pShop)
act_obj.c:	REMOVE_BIT(ch->affected_by,AFF_SNEAK);
act_obj.c:		RS.SQL.Insert("theft(ch, victim, obj, success) values('%s','%s','none',0)", ch->true_name, victim->true_name);
act_obj.c:				PERS(ch,victim),(ch->sex == 2) ? "her" : "his");
act_obj.c:			sprintf(buf,"$N tried to steal from %s.",victim->name);
act_obj.c:		if(victim->gold <= 100)
act_obj.c:			gold = victim->gold;
act_obj.c:			gold = number_range((int)(victim->gold / 8), victim->gold);
act_obj.c:		ch->gold += gold;
act_obj.c:		victim->gold -= gold;
act_obj.c:			RS.SQL.Insert("theft(ch, victim, obj, success) values('%s','%s','%d',1)", ch->true_name, victim->true_name, gold);
act_obj.c:		if(IS_NPC(victim) && !victim->stolen_from)
act_obj.c:			victim->stolen_from = TRUE;
act_obj.c:		||   IS_SET(obj->extra_flags, ITEM_INVENTORY))
act_obj.c:    if ( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
act_obj.c:    if ( ch->carry_weight + get_obj_weight( obj ) > can_carry_w( ch ) )
act_obj.c:				ch->true_name,
act_obj.c:				victim->true_name,
act_obj.c:				obj->short_descr);
act_obj.c:    for ( keeper = ch->in_room->people; keeper; keeper = keeper->next_in_room )
act_obj.c:	if ( IS_NPC(keeper) && (pShop = keeper->pIndexData->pShop) != NULL )
act_obj.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_KILLER) )
act_obj.c:	sprintf( buf, "%s the KILLER is over here!\n\r", ch->name );
act_obj.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_THIEF) )
act_obj.c:	sprintf( buf, "%s the THIEF is over here!\n\r", ch->name );
act_obj.c:    if ( time_info.hour < pShop->open_hour && pShop->open_hour != pShop->close_hour)
act_obj.c:    if ( time_info.hour > pShop->close_hour && pShop->open_hour != pShop->close_hour)
act_obj.c:    for (t_obj = ch->carrying; t_obj != NULL; t_obj = t_obj_next)
act_obj.c:	t_obj_next = t_obj->next_content;
act_obj.c:	if (obj->pIndexData == t_obj->pIndexData
act_obj.c:	&&  !str_cmp(obj->short_descr,t_obj->short_descr))
act_obj.c:	    obj->cost = t_obj->cost; /* keep it standard */
act_obj.c:	obj->next_content = ch->carrying;
act_obj.c:	ch->carrying = obj;
act_obj.c:	obj->next_content = t_obj->next_content;
act_obj.c:	t_obj->next_content = obj;
act_obj.c:    obj->carried_by      = ch;
act_obj.c:    obj->in_room         = NULL;
act_obj.c:    obj->in_obj          = NULL;
act_obj.c:    ch->carry_number    += get_obj_number( obj );
act_obj.c:    ch->carry_weight    += get_obj_weight( obj );
act_obj.c:    for ( obj = keeper->carrying; obj != NULL; obj = obj->next_content )
act_obj.c:        if (obj->wear_loc == WEAR_NONE
act_obj.c:        &&  is_name( arg, obj->name ) )
act_obj.c:	    while (obj->next_content != NULL
act_obj.c:	    && obj->pIndexData == obj->next_content->pIndexData
act_obj.c:	    && !str_cmp(obj->short_descr,obj->next_content->short_descr))
act_obj.c:		obj = obj->next_content;
act_obj.c:    if ( obj == NULL || ( pShop = keeper->pIndexData->pShop ) == NULL )
act_obj.c:    cost = obj->cost * calculate_inflation();
act_obj.c:	    if ( obj->item_type == pShop->buy_type[itype] )
act_obj.c:		cost = (obj->cost * pShop->profit_sell / 100) * calculate_inflation();
act_obj.c:	    for ( obj2 = keeper->carrying; obj2; obj2 = obj2->next_content )
act_obj.c:	    	if ( obj->pIndexData == obj2->pIndexData
act_obj.c:		&&   !str_cmp(obj->short_descr,obj2->short_descr) )
act_obj.c:    if ( obj->item_type == ITEM_STAFF || obj->item_type == ITEM_WAND )
act_obj.c:	if (obj->value[1] == 0)
act_obj.c:	    cost = cost * obj->value[2] / obj->value[1];
act_obj.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_PET_SHOP) )
act_obj.c:	    pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
act_obj.c:	    bug( "Do_buy: bad pet shop at vnum %d.", ch->in_room->vnum );
act_obj.c:	in_room     = ch->in_room;
act_obj.c:	ch->in_room = pRoomIndexNext;
act_obj.c:	ch->in_room = in_room;
act_obj.c:	if ( pet == NULL || !IS_SET(pet->act, ACT_PET) )
act_obj.c:	if ( ch->pet != NULL )
act_obj.c: 	cost = 10 * pet->level * pet->level;
act_obj.c:	if ( (ch->gold) < cost )
act_obj.c:	if ( ch->level < pet->level )
act_obj.c:	    cost -= cost / 2 * roll / 100;
act_obj.c:	pet			= create_mobile( pet->pIndexData );
act_obj.c:	SET_BIT(pet->act, ACT_PET);
act_obj.c:	SET_BIT(pet->affected_by, AFF_CHARM);
act_obj.c:	SET_BIT(pet->comm, COMM_NOTELL);
act_obj.c:	SET_BIT(pet->comm, COMM_NOSHOUT);
act_obj.c:	SET_BIT(pet->comm, COMM_NOCHANNELS);
act_obj.c:	    sprintf( buf, "%s %s", pet->name, arg );
act_obj.c:	    free_pstring( pet->name );
act_obj.c:	    pet->name = palloc_string( buf );
act_obj.c:	    pet->description, ch->name );
act_obj.c:	free_pstring( pet->description );
act_obj.c:	pet->description = palloc_string( buf );
act_obj.c:	char_to_room (pet, ch->in_room );
act_obj.c:	pet->leader = ch;
act_obj.c:	ch->pet = pet;
act_obj.c:	    sprintf(buf,"%s I don't sell that, try 'list'ing to see what I do sell.",ch->name);
act_obj.c:	    for (t_obj = obj->next_content;
act_obj.c:	     	 t_obj = t_obj->next_content)
act_obj.c:	    	if (t_obj->pIndexData == obj->pIndexData
act_obj.c:	    	&&  !str_cmp(t_obj->short_descr,obj->short_descr))
act_obj.c:	    	ch->reply = keeper;
act_obj.c:	if ( ch->gold < cost * number )
act_obj.c:	    ch->reply = keeper;
act_obj.c:	if ( obj->level > ch->level )
act_obj.c:	    ch->reply = keeper;
act_obj.c:	if (ch->carry_number +  number * get_obj_number(obj) > can_carry_n(ch))
act_obj.c:	if ( ch->carry_weight + number * get_obj_weight(obj) > can_carry_w(ch))
act_obj.c:	    cost -= obj->cost / 2 * roll / 100;
act_obj.c:	    if ( IS_SET( obj->extra_flags, ITEM_INVENTORY ) ) {
act_obj.c:	    	t_obj = create_object( obj->pIndexData, obj->level );
act_obj.c:			if(obj->item_type == ITEM_CONTAINER && obj->contains) {
act_obj.c:				for(c_obj = obj->contains; c_obj != NULL; c_obj = c_obj->next_content) {
act_obj.c:					d_obj = create_object(get_obj_index(c_obj->pIndexData->vnum),c_obj->level);
act_obj.c:		obj = obj->next_content;
act_obj.c:	    if (t_obj->timer > 0)
act_obj.c:	    	t_obj->timer = 0;
act_obj.c:	    if (cost < t_obj->cost)
act_obj.c:	    	t_obj->cost = cost;
act_obj.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_PET_SHOP) )
act_obj.c:        if (ch->in_room->vnum == 9621)
act_obj.c:            pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
act_obj.c:	    bug( "Do_list: bad pet shop at vnum %d.", ch->in_room->vnum );
act_obj.c:	for ( pet = pRoomIndexNext->people; pet; pet = pet->next_in_room )
act_obj.c:	    if ( IS_SET(pet->act, ACT_PET) )
act_obj.c:		sprintf( buf, "[%2d] %8d - %s\n\r",
act_obj.c:		    pet->level,
act_obj.c:		    10 * pet->level * pet->level,
act_obj.c:		    pet->short_descr );
act_obj.c:	for ( obj = keeper->carrying; obj; obj = obj->next_content )
act_obj.c:	    if ( obj->wear_loc == WEAR_NONE
act_obj.c: 	       ||  is_name(arg,obj->name) ))
act_obj.c:		    sprintf(buf,"[%2d %5d -- ] %s\n\r",
act_obj.c:			obj->level,cost,obj->short_descr);
act_obj.c:		    while (obj->next_content != NULL
act_obj.c:		    && obj->pIndexData == obj->next_content->pIndexData
act_obj.c:		    && !str_cmp(obj->short_descr,
act_obj.c:			        obj->next_content->short_descr))
act_obj.c:			obj = obj->next_content;
act_obj.c:			obj->level,cost,count,obj->short_descr);
act_obj.c:        cost += obj->cost / 2 * roll / 100;
act_obj.c:	cost = UMIN(cost,(keeper->gold));
act_obj.c:    ch->gold     += cost/100;
act_obj.c:    if ( keeper->gold < 0 )
act_obj.c:	keeper->gold = 0;
act_obj.c:    if ( obj->item_type == ITEM_TRASH || IS_OBJ_STAT(obj,ITEM_SELL_EXTRACT))
act_obj.c:	obj->timer = number_range(50,100);
act_obj.c:	ch->reply = keeper;
act_obj.c:    ch->reply = keeper;
act_obj.c:	sprintf(buf2,"Help! I'm being attacked by %s!",victim->short_descr);
act_obj.c:	sprintf(buf2, "Help! I'm being attacked by %s!",victim->short_descr);
act_obj.c:        sprintf(buf2,"Help! I'm being attacked by %s!", victim->short_descr);
act_obj.c:    if ( (obj = get_obj_list(victim, i_name, victim->carrying)) == NULL)
act_obj.c:    if ((victim->level >= (ch->level + 8) && victim->level < 58) ||
act_obj.c:    	(victim->level >= 59 && ch->level < 51))
act_obj.c:    if (ch->move < obj->level || ch->hit < (ch->max_hit*3/7))
act_obj.c:    if ((is_worn(obj) && IS_SET(obj->extra_flags, ITEM_NOREMOVE)) || IS_SET(obj->extra_flags, ITEM_NODROP))
act_obj.c:    if ( ch->carry_weight + get_obj_weight(obj)  > can_carry_w(ch) )
act_obj.c:    if ( ch->carry_number + 1 > can_carry_n(ch) )
act_obj.c:    if (obj->wear_loc != WEAR_NONE)
act_obj.c:	if (IS_SET(obj->progtypes,IPROG_GIVE))
act_obj.c:		(obj->pIndexData->iprogs->give_prog) (obj,ch,victim);
act_obj.c:  if (IS_SET(victim->progtypes,MPROG_GIVE))
act_obj.c:    (victim->pIndexData->mprogs->give_prog) (victim,ch,obj);
act_obj.c:af.level = ch->level;
act_obj.c:    ch->move -= obj->level;
act_obj.c:    ch->hit -= obj->level;
act_obj.c:	count -= ch->arms - 2;
act_obj.c:    || ch->level < skill_table[gsn_embalm].skill_level[ch->Class()->GetIndex()])
act_obj.c:    if (corpse->item_type != ITEM_CORPSE_NPC)
act_obj.c:    if (corpse->value[4] == 1)
act_obj.c:    if (number_percent() > ch->pcdata->learned[gsn_embalm])
act_obj.c:    corpse->timer += ch->level/2;
act_obj.c:    corpse->value[4] = 1;
act_obj.c:	for (ch = char_list; ch != NULL; ch = ch->next)
act_obj.c:        if (ch->cabal == cabal)
act_obj.c:			if (IS_SET(ch->comm,COMM_ANSI) && itemloss)
act_obj.c:			else if (IS_SET(ch->comm,COMM_ANSI) && !itemloss) 
act_obj.c:    int objvnum = cabal_table[ch->cabal].item_vnum;
act_obj.c:	for (obj = object_list; obj != NULL; obj = obj->next)
act_obj.c:        if (obj->pIndexData->vnum == objvnum)
act_obj.c:    if(!obj || !obj->carried_by || !IS_NPC(obj->carried_by))
act_obj.c:    if(obj->carried_by->cabal && obj->carried_by->cabal != cabal)
act_obj.c:    if (str_cmp(obj->owner,"none") && !is_owner(ch,obj))
act_obj.c:    race = race_table[ch->race].name;
act_obj.c:	copy_vector(restrict, obj->pIndexData->restrict_flags);
act_obj.c:		if(!strstr(race_table[ch->race].name, restrict_table[i].value) && (str_cmp(restrict_table[i].value,"titan") 
act_obj.c:		    ||  (str_cmp(race_table[ch->race].name,"abyss") && str_cmp(race_table[ch->race].name,"celestial") && 
act_obj.c:		        str_cmp(race_table[ch->race].name,"planar"))))
act_obj.c:		if(str_cmp(ch->Class()->name, restrict_table[i].value))
act_obj.c:		if(str_cmp(cabal_table[ch->cabal].name, restrict_table[i].value))
act_obj.c:		if(!str_cmp(restrict_table[i].name,"mage_only") && ch->Class()->GetIndex() != CLASS_NECROMANCER &&
act_obj.c:				ch->Class()->GetIndex() != CLASS_SHAPESHIFTER && ch->Class()->GetIndex() != CLASS_SORCERER)
act_obj.c:		if(!str_cmp(restrict_table[i].name,"male_only") && ch->pcdata->true_sex != SEX_MALE)
act_obj.c:		if(!str_cmp(restrict_table[i].name,"female_only") && ch->pcdata->true_sex != SEX_FEMALE)
act_obj.c:    chance = ch->pcdata->learned[gsn_demand];
act_obj.c:    || ch->level < skill_table[gsn_demand].skill_level[ch->Class()->GetIndex()])
act_obj.c:    vlevel = victim->level;
act_obj.c:    chance += (3*ch->level);
act_obj.c:    chance -= 2*vlevel;
act_obj.c:        chance -= 4*vlevel;
act_obj.c:        chance -= 2*vlevel;
act_obj.c:        chance -= 3*vlevel;
act_obj.c:    if ((obj = get_obj_list(victim, i_name, victim->carrying)) == NULL)
act_obj.c:    if (vlevel > ch->level
act_obj.c:        sprintf(buf2,"Help! I'm being attacked by %s!",victim->short_descr);
act_obj.c:    if (obj->level > ch->level + 8)
act_obj.c:        sprintf(buf1,"Help! I'm being attacked by %s!",victim->short_descr);
act_obj.c:    if (ch->move < obj->level)
act_obj.c:        sprintf(buf1,"Help! I'm being attacked by %s!",victim->short_descr);
act_obj.c:    if (ch->hit < (ch->max_hit*3/7))
act_obj.c:        sprintf(buf1,"Help! I'm being attacked by %s!",victim->short_descr);
act_obj.c:    if (ch->mana < 30)
act_obj.c:    if ((obj->wear_loc != WEAR_NONE) && IS_SET(obj->extra_flags, ITEM_NOREMOVE) )
act_obj.c:    if (IS_SET(obj->extra_flags,ITEM_NODROP) )
act_obj.c:    if ( ch->carry_weight + get_obj_weight(obj)  > can_carry_w(ch) )
act_obj.c:    if ( ch->carry_number + 1 > can_carry_n(ch) )
act_obj.c:    if (obj->wear_loc != WEAR_NONE)
act_obj.c:    ch->mana -= 30;
act_obj.c:    ch->hit -= 30;
act_obj.c:    if (obj->item_type != ITEM_WEAPON)
act_obj.c:        sprintf(buf,"report_weapon_skill: Bad obj->type, %d, vnum %d, carried by %s.",
act_obj.c:        obj->item_type, obj->pIndexData->vnum,ch->name);
act_obj.c:    if (obj->value[0] == WEAPON_DAGGER)
act_obj.c:    else if (obj->value[0] == WEAPON_SWORD)
act_obj.c:    else if (obj->value[0] == WEAPON_MACE)
act_obj.c:    else if (obj->value[0] == WEAPON_SPEAR)
act_obj.c:    else if (obj->value[0] == WEAPON_AXE)
act_obj.c:    else if (obj->value[0] == WEAPON_FLAIL)
act_obj.c:    else if (obj->value[0] == WEAPON_STAFF)
act_obj.c:	sn = -1;
act_obj.c:    if (sn == -1)
act_obj.c:        skill = ch->level * 3;
act_obj.c:        skill = ch->pcdata->learned[sn];
act_obj.c:af.duration = -1;
act_obj.c:		for (obj = object_list; obj != NULL; obj = obj->next)
act_obj.c:			if(obj->pIndexData->vnum == vnum)
act_obj.c:				(obj->carried_by && IS_NPC(obj->carried_by) && IS_CABAL_GUARD(obj->carried_by)) ?
act_obj.c:				obj->carried_by->pIndexData->vnum : 0);
act_obj.c:	fprintf(fp,"-1");
act_obj.c:	if (!str_cmp(ch->true_name,corpse->owner)) {
act_obj.c:	if (obj->item_type != ITEM_DICE)
act_obj.c:	if (ch->fighting)
act_obj.c:	if (!IS_GROUND(ch->in_room))
act_obj.c:	number = obj->value[0];
act_obj.c:	sides = obj->value[1];
act_obj.c:	obj_to_room(obj,ch->in_room);
act_obj.c:	if (ch->fighting)
act_obj.c:		if (!IS_GROUND(ch->in_room))
act_obj.c:		if (number_percent() < ((get_curr_stat(ch,STAT_DEX) * 10) - 150)) {
act_obj.c:			act("You attempt an ill-advised backflip, and crash awkwardly to the ground!",ch,0,0,TO_CHAR);
act_obj.c:			ch->position = POS_RESTING;
act_obj.c:	if (ch->gold <= 0)
act_obj.c:		obj_to_room(coin,ch->in_room);
act_obj.c:		ch->gold--;
act_obj.c:	for (obj = ch->carrying; obj; obj = obj->next_content) {
act_obj.c:		if (obj->pIndexData->vnum == vnum)
act_obj.c:		for (cont = obj->contains; cont; cont = cont->next_content)
act_obj.c:			if (cont->pIndexData->vnum == vnum)
act_obj.c:	for(obj = ch->carrying; obj; obj = obj->next_content)
act_obj.c:		if(obj->item_type == ITEM_BOAT)
act_wiz.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
act_wiz.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
act_wiz.c:      	if (IS_SET(ch->wiznet,WIZ_ON))
act_wiz.c:            REMOVE_BIT(ch->wiznet,WIZ_ON);
act_wiz.c:            SET_BIT(ch->wiznet,WIZ_ON);
act_wiz.c:	SET_BIT(ch->wiznet,WIZ_ON);
act_wiz.c:	REMOVE_BIT(ch->wiznet,WIZ_ON);
act_wiz.c:	if (!IS_SET(ch->wiznet,WIZ_ON))
act_wiz.c:	    if (IS_SET(ch->wiznet,wiznet_table[flag].flag))
act_wiz.c:    if (flag == -1 || get_trust(ch) < wiznet_table[flag].level)
act_wiz.c:    if (IS_SET(ch->wiznet,wiznet_table[flag].flag))
act_wiz.c:	REMOVE_BIT(ch->wiznet,wiznet_table[flag].flag);
act_wiz.c:    	SET_BIT(ch->wiznet,wiznet_table[flag].flag);
act_wiz.c:    for ( d = descriptor_list; d != NULL; d = d->next )
act_wiz.c:        if (d->connected == CON_PLAYING
act_wiz.c:		&&  d->character
act_wiz.c:		&&  IS_IMMORTAL(d->character)
act_wiz.c:		&&  IS_SET(d->character->wiznet,WIZ_ON)
act_wiz.c:		&&  (!flag || IS_SET(d->character->wiznet,flag))
act_wiz.c:		&&  (!flag_skip || !IS_SET(d->character->wiznet,flag_skip))
act_wiz.c:		&&  get_trust(d->character) >= min_level
act_wiz.c:		&&  d->character != ch)
act_wiz.c:	    if (IS_SET(d->character->wiznet,WIZ_PREFIX))
act_wiz.c:	  	send_to_char("--> ",d->character);
act_wiz.c:	    sprintf(str,"%s%s%s",get_char_color(d->character,"wiznet"),string,END_COLOR(d->character));
act_wiz.c:            act_new(str,d->character,obj,ch,TO_CHAR,POS_DEAD);
act_wiz.c:    if (ch->level < 54 || IS_NPC(ch))
act_wiz.c:    if (victim->pcdata->induct == CABAL_LEADER)
act_wiz.c:        sprintf(buf, "You have taken away %s's power to induct.\n\r",victim->name);
act_wiz.c:        victim->pcdata->induct = 0;
act_wiz.c:		sprintf(buf,"AUTO: %s removed leadership.\n\r",ch->true_name);
act_wiz.c:        sprintf(buf, "You have given %s the power to induct.\n\r",victim->name);
act_wiz.c:        victim->pcdata->induct = CABAL_LEADER;
act_wiz.c:		sprintf(buf,"AUTO: %s gave leadership.\n\r",ch->true_name);
act_wiz.c:	RS.SQL.Update("players SET induct=%d WHERE name = '%s'", ch->pcdata->induct, ch->true_name);
act_wiz.c:    victim->hit /= 2;
act_wiz.c:-Ceran
act_wiz.c:    if ((ch->level < 54 && ch->pcdata->induct != CABAL_LEADER)
act_wiz.c:	|| IS_NPC(ch) || (ch->cabal == CABAL_HORDE && !IS_IMMORTAL(ch)))
act_wiz.c:			send_to_char("--------------------------\n\r",ch);
act_wiz.c:            	sprintf(buf, "%-12s %-4d / %s\n\r",
act_wiz.c:			send_to_char("--------------------------\n\r",ch);
act_wiz.c:        for (i = 1; i < (MAX_CABAL -1); i++)
act_wiz.c:        sprintf(buf,"%s.\n\r",cabal_table[MAX_CABAL -1].name);
act_wiz.c:        if (ch->cabal != victim->cabal && get_trust(ch) < 56)
act_wiz.c:        	if (!victim->cabal)
act_wiz.c:		cabal = victim->cabal;
act_wiz.c:		cabal_members[victim->cabal]--;
act_wiz.c:        victim->cabal = 0;
act_wiz.c:		victim->pcdata->cabal_level = 0;
act_wiz.c:		sprintf(buf,"AUTO: Uninducted from %s by %s.\n\r",cabal ? capitalize(cabal_table[cabal].name) : "-",ch->true_name);
act_wiz.c:    if ( victim->cabal != 0 )
act_wiz.c:    if ((cabal = cabal_lookup(arg2)) != ch->cabal && get_trust(ch)<54)
act_wiz.c:    sprintf(buf,"%s has been inducted into the %s.", victim->name, cabal_table[cabal].long_name);
act_wiz.c:    victim->cabal = cabal;
act_wiz.c:    sprintf(tstr,"%s into %s.",victim->name, capitalize(cabal_table[cabal].name));
act_wiz.c:	sprintf(buf,"AUTO: Inducted into %s by %s.\n\r",capitalize(cabal_table[cabal].name),ch->true_name);
act_wiz.c:				ch->true_name,
act_wiz.c:				victim->true_name,
act_wiz.c:				ch->pcdata->host,
act_wiz.c:				victim->pcdata->host);
act_wiz.c:    if(str_cmp(cabal_table[victim->cabal].extitle,""))
act_wiz.c:		set_extitle(victim,cabal_table[victim->cabal].extitle);
act_wiz.c:	victim->pcdata->cabal_level = cabal_table[victim->cabal].start_level;
act_wiz.c:	if(ch->level > 15 && !IS_IMMORTAL(ch))
act_wiz.c:	ch->pcdata->condition[COND_THIRST] = 1;
act_wiz.c:	ch->pcdata->condition[COND_HUNGER] = 1;
act_wiz.c:	if(ch->Class()->GetIndex() == CLASS_SORCERER || ch->Class()->GetIndex() == CLASS_NECROMANCER)
act_wiz.c:/*	if (IS_NPC(ch) || ch->pcdata->newbie!=TRUE)
act_wiz.c:	obj->cost = 0;
act_wiz.c:	obj->cost = 0;
act_wiz.c:	obj->cost = 0;
act_wiz.c:	obj->cost = 0;
act_wiz.c:	obj->cost = 0;
act_wiz.c:	obj->cost = 0;
act_wiz.c:	obj->cost = 0;
act_wiz.c:	obj->cost = 0;
act_wiz.c:	obj->cost = 0;
act_wiz.c:	obj->cost = 0;
act_wiz.c:	obj->cost = 0;
act_wiz.c:	obj->cost = 0;
act_wiz.c:	    if (ch->Class()->GetIndex() == CLASS_WARRIOR && ch->pcdata->start_weapon == i)
act_wiz.c:	    else if (ch->pcdata->learned[sn] <
act_wiz.c:		ch->pcdata->learned[*weapon_table[i].gsn])
act_wiz.c:	  	obj->cost = 0;
act_wiz.c:		obj->cost = 0;
act_wiz.c:		obj->cost = 0;
act_wiz.c:	obj->cost = 0;
act_wiz.c:	obj->cost = 0;
act_wiz.c:	af.level=ch->level;
act_wiz.c:    if ( ch->level <= victim->level )
act_wiz.c:    if ( IS_SET(victim->comm, COMM_NOCHANNELS) )
act_wiz.c:        REMOVE_BIT(victim->comm, COMM_NOCHANNELS);
act_wiz.c:	sprintf(buf,"$N restores channels to %s",victim->name);
act_wiz.c:        SET_BIT(victim->comm, COMM_NOCHANNELS);
act_wiz.c:	sprintf(buf,"$N revokes %s's channels.",victim->name);
act_wiz.c:    if ( !IS_NPC(ch) && IS_SET(ch->comm, COMM_NOEMOTE) )
act_wiz.c:    if (strstr(argument,ch->name) == NULL && !IS_NPC(ch))
act_wiz.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
act_wiz.c:        if (vch->desc == NULL || vch == ch)
act_wiz.c:        if ((letter = strstr(argument,vch->name)) == NULL)
act_wiz.c:        temp[strlen(argument) - strlen(letter)] = '\0';
act_wiz.c:        name = vch->name;
act_wiz.c:            if (*letter == '\'' && matches == strlen(vch->name))
act_wiz.c:            if (*letter == 's' && matches == strlen(vch->name))
act_wiz.c:            if (matches == strlen(vch->name))
act_wiz.c:                if (matches == strlen(vch->name))
act_wiz.c:                    name = vch->name;
act_wiz.c:            name = vch->name;
act_wiz.c:	    sprintf(buf,"Your poofin is %s\n\r",ch->pcdata->bamfin);
act_wiz.c:	if ( strstr(argument,ch->name) == NULL)
act_wiz.c:	free_pstring( ch->pcdata->bamfin );
act_wiz.c:	ch->pcdata->bamfin = palloc_string( argument );
act_wiz.c:        sprintf(buf,"Your poofin is now %s\n\r",ch->pcdata->bamfin);
act_wiz.c:            sprintf(buf,"Your poofout is %s\n\r",ch->pcdata->bamfout);
act_wiz.c:        if ( strstr(argument,ch->name) == NULL)
act_wiz.c:        free_pstring( ch->pcdata->bamfout );
act_wiz.c:        ch->pcdata->bamfout = palloc_string( argument );
act_wiz.c:        sprintf(buf,"Your poofout is now %s\n\r",ch->pcdata->bamfout);
act_wiz.c:    SET_BIT(victim->act, PLR_DENY);
act_wiz.c:    sprintf(buf,"$N denies access to %s",victim->name);
act_wiz.c:    victim->pause = 0;
act_wiz.c:    if(victim->desc)
act_wiz.c:    	sprintf(query,"UPDATE sitetracker SET denials=denials+1 WHERE '%s' RLIKE site_name",victim->desc->host);
act_wiz.c:    sprintf(buf,"AUTO: Denied by %s.\n\r",ch->true_name);
act_wiz.c:    cname	= palloc_string(victim->true_name);
act_wiz.c:    	for ( d = descriptor_list; d != NULL; d = d->next )
act_wiz.c:            if ( d->descriptor == desc )
act_wiz.c:	if(ch->level <= get_trust(victim))
act_wiz.c:    if ( victim->desc == NULL )
act_wiz.c:    for ( d = descriptor_list; d != NULL; d = d->next )
act_wiz.c:	if ( d == victim->desc )
act_wiz.c:	if ( IS_SET(victim->act, PLR_KILLER) )
act_wiz.c:	    REMOVE_BIT( victim->act, PLR_KILLER );
act_wiz.c:	if ( IS_SET(victim->act, PLR_THIEF) )
act_wiz.c:	    REMOVE_BIT( victim->act, PLR_THIEF );
act_wiz.c:    for ( d = descriptor_list; d; d = d->next )
act_wiz.c:	if ( d->connected == CON_PLAYING )
act_wiz.c:	    colorconv(buffer, argument, d->character);
act_wiz.c:	    if (get_trust(d->character) >= get_trust(ch))
act_wiz.c:		send_to_char(ch->name,d->character);
act_wiz.c:		send_to_char( " globals: ",d->character);
act_wiz.c:	    send_to_char( buffer, d->character );
act_wiz.c:	    send_to_char( "\n\r",   d->character );
act_wiz.c:	for ( d = descriptor_list; d; d = d->next )
act_wiz.c:		if ( d->connected == CON_PLAYING && (d->character->level > 51))
act_wiz.c:			colorconv(buffer, argument, d->character);
act_wiz.c:			send_to_char( buffer, d->character );
act_wiz.c:			send_to_char( "\n\r",   d->character );
act_wiz.c:    for ( d = descriptor_list; d; d = d->next )
act_wiz.c:	if ( d->connected == CON_PLAYING
act_wiz.c:	&&   d->character->in_room == ch->in_room )
act_wiz.c:            colorconv(buffer, argument, d->character);
act_wiz.c:            if (get_trust(d->character) >= get_trust(ch) && !IS_NPC(ch))
act_wiz.c:                send_to_char( "local> ",d->character);
act_wiz.c:	    send_to_char( buffer, d->character );
act_wiz.c:	    send_to_char( "\n\r",   d->character );
act_wiz.c:    for (d = descriptor_list; d; d = d->next)
act_wiz.c:	if (d->connected == CON_PLAYING
act_wiz.c:	&&  d->character->in_room != NULL && ch->in_room != NULL
act_wiz.c:	&&  d->character->in_room->area == ch->in_room->area)
act_wiz.c:		colorconv(buffer, argument, d->character);
act_wiz.c:	    if (get_trust(d->character) >= get_trust(ch) && !IS_NPC(ch))
act_wiz.c:		send_to_char("zone> ",d->character);
act_wiz.c:	    send_to_char(buffer,d->character);
act_wiz.c:	    send_to_char("\n\r",d->character);
act_wiz.c:	return victim->in_room;
act_wiz.c:	return obj->in_room;
act_wiz.c:	for ( d = descriptor_list; d != NULL; d = d->next )
act_wiz.c:	    if ( d->connected == CON_PLAYING
act_wiz.c:	    &&   d->character != ch
act_wiz.c:	    &&   d->character->in_room != NULL
act_wiz.c:	    &&   can_see( ch, d->character ) )
act_wiz.c:		sprintf( buf, "%s %s", d->character->name, arg2 );
act_wiz.c:	location = ch->in_room;
act_wiz.c:    if (IS_SET(location->room_flags, ROOM_IMP_ONLY) && ch->level<60)
act_wiz.c:	&&  ch->level < MAX_LEVEL)
act_wiz.c:    if ( victim->in_room == NULL )
act_wiz.c:    if (get_trust(victim) >= get_trust(ch) && !IS_NPC(victim) && ch->level!=60)
act_wiz.c:    if ( victim->fighting != NULL )
act_wiz.c:    &&  ch->level < MAX_LEVEL)
act_wiz.c:    if (IS_SET(location->room_flags, ROOM_IMP_ONLY) && ch->level<60)
act_wiz.c:    original = ch->in_room;
act_wiz.c:    on = ch->on;
act_wiz.c:    for ( wch = char_list; wch != NULL; wch = wch->next )
act_wiz.c:	    ch->on = on;
act_wiz.c:    for ( rch = location->people; rch != NULL; rch = rch->next_in_room )
act_wiz.c:    &&  (count > 1 || ch->level < MAX_LEVEL))
act_wiz.c:    if (IS_SET(location->room_flags, ROOM_IMP_ONLY) && get_trust(ch)<60)
act_wiz.c:    if ( ch->fighting != NULL )
act_wiz.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
act_wiz.c:	if (get_trust(rch) >= ch->invis_level)
act_wiz.c:		if (get_trust(rch) == LEVEL_HERO && ch->invis_level == LEVEL_HERO && !IS_HEROIMM(rch))
act_wiz.c:	    if (ch->pcdata != NULL && ch->pcdata->bamfout[0] != '\0' && !IS_SWITCHED(ch))
act_wiz.c:		act("$t",ch,ch->pcdata->bamfout,rch,TO_VICT);
act_wiz.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
act_wiz.c:        if (get_trust(rch) >= ch->invis_level)
act_wiz.c:		if (get_trust(rch) == LEVEL_HERO && ch->invis_level == LEVEL_HERO && !IS_HEROIMM(rch))
act_wiz.c:            if (ch->pcdata != NULL && ch->pcdata->bamfin[0] != '\0' && !IS_SWITCHED(ch))
act_wiz.c:                act("$t",ch,ch->pcdata->bamfin,rch,TO_VICT);
act_wiz.c:    if ( ch->fighting != NULL )
act_wiz.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
act_wiz.c:        if (get_trust(rch) >= ch->invis_level)
act_wiz.c:		if (get_trust(rch) == LEVEL_HERO && ch->invis_level == LEVEL_HERO && !IS_HEROIMM(rch))
act_wiz.c:            if (ch->pcdata != NULL && ch->pcdata->bamfout[0] != '\0')
act_wiz.c:                act("$t",ch,ch->pcdata->bamfout,rch,TO_VICT);
act_wiz.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
act_wiz.c:        if (get_trust(rch) >= ch->invis_level)
act_wiz.c:            if (ch->pcdata != NULL && ch->pcdata->bamfin[0] != '\0')
act_wiz.c:                act("$t",ch,ch->pcdata->bamfin,rch,TO_VICT);
act_wiz.c:    location = ( arg[0] == '\0' ) ? ch->in_room : find_location( ch, arg );
act_wiz.c:    if (!is_room_owner(ch,location) && ch->in_room != location
act_wiz.c:	location->name,
act_wiz.c:	location->area->name );
act_wiz.c:	location->vnum,
act_wiz.c:	capitalize(sect_table[sect_numlookup(location->sector_type)].name),
act_wiz.c:	location->heal_rate,
act_wiz.c:    location->mana_rate );
act_wiz.c:	location->description );
act_wiz.c:    if ( location->extra_descr != NULL )
act_wiz.c:	for ( ed = location->extra_descr; ed; ed = ed->next )
act_wiz.c:	    send_to_char( ed->keyword, ch );
act_wiz.c:	    if ( ed->next != NULL )
act_wiz.c:    for ( rch = location->people; rch; rch = rch->next_in_room )
act_wiz.c:	    one_argument( rch->name, buf );
act_wiz.c:    for ( obj = location->contents; obj; obj = obj->next_content )
act_wiz.c:	one_argument( obj->name, buf );
act_wiz.c:	if ( ( pexit = location->exit[door] ) != NULL )
act_wiz.c:		if(IS_SET(pexit->exit_info,exit_flags[i].bit))
act_wiz.c:		(pexit->u1.to_room == NULL ? -1 : pexit->u1.to_room->vnum),
act_wiz.c:	    	pexit->key,
act_wiz.c:	    	pexit->keyword,
act_wiz.c:	    	pexit->description[0] != '\0' ? pexit->description : "(none).\n\r" );
act_wiz.c:		if (location->tracks[i] && location->tracks[i]->prey)
act_wiz.c:			time = (time_info.hour >= location->tracks[i]->time.hour) ?
act_wiz.c:				(time_info.hour - location->tracks[i]->time.hour) :
act_wiz.c:				(24 +  time_info.hour - location->tracks[i]->time.hour) +
act_wiz.c:				(time_info.day >= location->tracks[i]->time.day) ?
act_wiz.c:				24 * (time_info.day - location->tracks[i]->time.day) :
act_wiz.c:				24 * (30 + time_info.day - location->tracks[i]->time.day) +
act_wiz.c:				(time_info.month >= location->tracks[i]->time.month) ?
act_wiz.c:				24*30*(time_info.month - location->tracks[i]->time.month) :
act_wiz.c:				24*30*(12 + time_info.month - location->tracks[i]->time.month)+
act_wiz.c:				24*30*12*(time_info.year - location->tracks[i]->time.year);
act_wiz.c:			direction = (char *)flag_name_lookup(location->tracks[i]->direction,direction_table);
act_wiz.c:				location->tracks[i]->prey->name, direction, time);
act_wiz.c:    if ( ( obj = get_obj_world( ch, argument ) ) == NULL || (obj && obj->carried_by && !can_see(ch,obj->carried_by)))
act_wiz.c:    sprintf( buf, "Name(s): %s\n\r", obj->name );
act_wiz.c:	obj->pIndexData->vnum, obj->pIndexData->new_format ? "new" : "old",
act_wiz.c:        item_name(obj->item_type), obj->pIndexData->reset_num );
act_wiz.c:	obj->short_descr, obj->description );
act_wiz.c:	sprintf( buf, "Owner: %s\n\r", obj->owner);
act_wiz.c:	wear_bit_name(obj->wear_flags), extra_bit_name( obj->extra_flags ) );
act_wiz.c:	restrict_bit_name(obj->pIndexData->restrict_flags));
act_wiz.c:	obj->weight, get_obj_weight( obj ),get_true_weight(obj), obj->material,
act_wiz.c:	obj->pIndexData->material_index );
act_wiz.c:	obj->level, obj->cost, obj->condition, obj->timer);
act_wiz.c:	obj->in_room    == NULL    ?        0 : obj->in_room->vnum,
act_wiz.c:	obj->in_obj     == NULL    ? "(none)" : obj->in_obj->short_descr,
act_wiz.c:	obj->carried_by == NULL    ? "(none)" :
act_wiz.c:	    can_see(ch,obj->carried_by) ? obj->carried_by->name
act_wiz.c:	obj->wear_loc );
act_wiz.c:	obj->value[0], obj->value[1], obj->value[2], obj->value[3],
act_wiz.c:	obj->value[4] );
act_wiz.c:    sprintf( buf, "COUNT_DATA: Limit is %d, Count is %d -->%s.\n\r",obj->pIndexData->limtotal,obj->pIndexData->limcount,
act_wiz.c:(obj->pIndexData->limcount < obj->pIndexData->limtotal) ? "Not maxxed" : (obj->pIndexData->limtotal == 0) ? "Non-limited" : "Maxxed");
act_wiz.c:    switch ( obj->item_type )
act_wiz.c:	    sprintf( buf, "Level %d spells of:", obj->value[0] );
act_wiz.c:	    if ( obj->value[1] >= 0 && obj->value[1] < MAX_SKILL )
act_wiz.c:	    	send_to_char( skill_table[obj->value[1]].name, ch );
act_wiz.c:	    if ( obj->value[2] >= 0 && obj->value[2] < MAX_SKILL )
act_wiz.c:	    	send_to_char( skill_table[obj->value[2]].name, ch );
act_wiz.c:	    if ( obj->value[3] >= 0 && obj->value[3] < MAX_SKILL )
act_wiz.c:	    	send_to_char( skill_table[obj->value[3]].name, ch );
act_wiz.c:	    if (obj->value[4] >= 0 && obj->value[4] < MAX_SKILL)
act_wiz.c:		send_to_char(skill_table[obj->value[4]].name,ch);
act_wiz.c:	    	obj->value[1], obj->value[2], obj->value[0] );
act_wiz.c:	    if ( obj->value[3] >= 0 && obj->value[3] < MAX_SKILL )
act_wiz.c:	    	send_to_char( skill_table[obj->value[3]].name, ch );
act_wiz.c:	    sprintf(buf,"It holds %s-colored %s.\n\r",
act_wiz.c:		liq_table[obj->value[2]].liq_color,
act_wiz.c:		liq_table[obj->value[2]].liq_name);
act_wiz.c:	    switch (obj->value[0])
act_wiz.c:	    if (obj->pIndexData->new_format)
act_wiz.c:		    obj->value[1],obj->value[2],
act_wiz.c:		    (1 + obj->value[2]) * obj->value[1] / 2);
act_wiz.c:	    	    obj->value[1], obj->value[2],
act_wiz.c:	    	    ( obj->value[1] + obj->value[2] ) / 2 );
act_wiz.c:		(obj->value[3] > 0 && obj->value[3] < MAX_DAMAGE_MESSAGE) ?
act_wiz.c:		    attack_table[obj->value[3]].noun : "undefined");
act_wiz.c:	    if (obj->value[4])  /* weapon flags */
act_wiz.c:		    weapon_bit_name(obj->value[4]));
act_wiz.c:	        obj->value[0], obj->value[1], obj->value[2], obj->value[3] );
act_wiz.c:		obj->ohp,
act_wiz.c:		obj->owner,
act_wiz.c:		obj->talked);
act_wiz.c:                obj->value[0], obj->value[3], cont_bit_name(obj->value[1]));
act_wiz.c:	if ( obj->pIndexData->notes) {
act_wiz.c:		sprintf(buf,"NOTES: %s\n\r",obj->pIndexData->notes);
act_wiz.c:    if ( obj->extra_descr != NULL || obj->pIndexData->extra_descr != NULL )
act_wiz.c:	for ( ed = obj->extra_descr; ed != NULL; ed = ed->next )
act_wiz.c:	    send_to_char( ed->keyword, ch );
act_wiz.c:	    if ( ed->next != NULL )
act_wiz.c:	for ( ed = obj->pIndexData->extra_descr; ed != NULL; ed = ed->next )
act_wiz.c:		for (ed2 = obj->extra_descr; ed2; ed2 = ed2->next)
act_wiz.c:			if (!str_cmp(ed->keyword,ed2->keyword))
act_wiz.c:	    send_to_char( ed->keyword, ch );
act_wiz.c:	    if ( ed->next != NULL )
act_wiz.c:if ( obj->pIndexData->progtypes != 0 )  {
act_wiz.c:    if ( IS_SET(obj->progtypes, IPROG_WEAR ) ) {
act_wiz.c:	sprintf(buf, "Item has wear prog: %s\n\r", obj->pIndexData->iprogs->wear_name);
act_wiz.c:    if ( IS_SET(obj->progtypes, IPROG_REMOVE ) ) {
act_wiz.c:	sprintf(buf, "Item has remove prog: %s\n\r", obj->pIndexData->iprogs->remove_name);
act_wiz.c:    if ( IS_SET(obj->progtypes, IPROG_GET ) ) {
act_wiz.c:	sprintf(buf, "Item has get prog: %s\n\r", obj->pIndexData->iprogs->get_name);
act_wiz.c:    if ( IS_SET(obj->progtypes, IPROG_DROP ) ) {
act_wiz.c:	sprintf(buf, "Item has drop prog: %s\n\r", obj->pIndexData->iprogs->drop_name);
act_wiz.c:    if ( IS_SET(obj->progtypes, IPROG_SAC ) ) {
act_wiz.c:	sprintf(buf, "Item has sacrifice prog: %s\n\r", obj->pIndexData->iprogs->sac_name);
act_wiz.c:    if ( IS_SET(obj->progtypes, IPROG_GIVE ) ) {
act_wiz.c:	sprintf(buf, "Item has give prog: %s\n\r", obj->pIndexData->iprogs->give_name);
act_wiz.c:    if ( IS_SET(obj->progtypes, IPROG_FIGHT ) ) {
act_wiz.c:	sprintf(buf, "Item has fight prog: %s\n\r", obj->pIndexData->iprogs->fight_name);
act_wiz.c:    if ( IS_SET(obj->progtypes, IPROG_DEATH ) ) {
act_wiz.c:	sprintf(buf, "Item has death prog: %s\n\r", obj->pIndexData->iprogs->death_name);
act_wiz.c:    if ( IS_SET(obj->progtypes, IPROG_SPEECH ) ) {
act_wiz.c:	sprintf(buf, "Item has speech prog: %s\n\r", obj->pIndexData->iprogs->speech_name);
act_wiz.c:    if ( IS_SET(obj->progtypes, IPROG_PULSE ) ) {
act_wiz.c:	sprintf(buf, "Item has pulse prog: %s\n\r", obj->pIndexData->iprogs->pulse_name);
act_wiz.c:    if ( IS_SET(obj->progtypes, IPROG_ENTRY ) ) {
act_wiz.c:        sprintf(buf, "Item has entry prog: %s\n\r", obj->pIndexData->iprogs->entry_name);
act_wiz.c:    if ( IS_SET(obj->progtypes, IPROG_INVOKE) ) {
act_wiz.c:        sprintf(buf, "Item has invoke prog: %s\n\r", obj->pIndexData->iprogs->invoke_name);
act_wiz.c:    if ( IS_SET(obj->progtypes, IPROG_GREET) ) {
act_wiz.c:        sprintf(buf, "Item has greet prog: %s\n\r", obj->pIndexData->iprogs->greet_name);
act_wiz.c:	if ( IS_SET(obj->progtypes, IPROG_VERB) ) {
act_wiz.c:		sprintf(buf, "Item has verb prog: %s\n\r", obj->pIndexData->iprogs->verb_name);
act_wiz.c:	if(obj->pIndexData->spec_prog.func)
act_wiz.c:			if(ispec_table[i].spec_func == obj->pIndexData->spec_prog.func)
act_wiz.c:if(obj->pIndexData->wear_echo[0]!=NULL)
act_wiz.c:	sprintf(buf,"Item echos to wearer: %s\n\r", obj->pIndexData->wear_echo[0]);
act_wiz.c:if(obj->pIndexData->wear_echo[1]!=NULL)
act_wiz.c:	sprintf(buf,"Item echos to room on wear: %s\n\r", obj->pIndexData->wear_echo[1]);
act_wiz.c:if(obj->pIndexData->remove_echo[0]!=NULL)
act_wiz.c:        sprintf(buf,"Item echos to remover: %s\n\r", obj->pIndexData->remove_echo[0]);
act_wiz.c:if(obj->pIndexData->remove_echo[1]!=NULL)
act_wiz.c:        sprintf(buf,"Item echos to room on remove: %s\n\r", obj->pIndexData->remove_echo[1]);
act_wiz.c:if(obj->pIndexData->wear_loc_name!=NULL)
act_wiz.c:		sprintf(buf,"Item has cosmetic wear location: worn \"%s\"\n\r",obj->pIndexData->wear_loc_name);
act_wiz.c:	for ( app = obj->apply; app; app = app->next) {
act_wiz.c:			affect_loc_name(app->location),	app->modifier );
act_wiz.c:	if ( !IS_ZERO_VECTOR(obj->imm_flags)) {
act_wiz.c:		sprintf(buf, "Grants immunity to: %s\n\r",imm_bit_name(obj->imm_flags));
act_wiz.c:	if ( !IS_ZERO_VECTOR(obj->res_flags)) {
act_wiz.c:			imm_bit_name(obj->res_flags));
act_wiz.c:	if ( !IS_ZERO_VECTOR(obj->vuln_flags)) {
act_wiz.c:			imm_bit_name(obj->vuln_flags));
act_wiz.c:	if(obj->wear_loc_name)
act_wiz.c:		sprintf(buf,"Item is <worn %s>.\n\r",obj->wear_loc_name);
act_wiz.c:	for ( paf2 = obj->charaffs; paf2; paf2 = paf2->next )
act_wiz.c:		if (paf2->bitvector) {
act_wiz.c:				affect_bit_name(paf2->bitvector));
act_wiz.c:    for ( paf = obj->affected; paf != NULL; paf = paf->next )
act_wiz.c:		if (paf->aftype == AFT_SKILL)
act_wiz.c:		else if (paf->aftype == AFT_POWER)
act_wiz.c:		else if (paf->aftype == AFT_COMMUNE)
act_wiz.c:		else if (paf->aftype == AFT_RUNE)
act_wiz.c:			"%s: '%s' modifies %s by %d for %d%s hours with %s-bits %s, owner %s, level %d.\n\r",
act_wiz.c:			skill_table[(int)paf->type].name,
act_wiz.c:			(paf->where == TO_OBJ_AFFECTS) ?
act_wiz.c:			str_cmp(oaffect_loc_name(paf->location),"none") ?
act_wiz.c:			oaffect_loc_name(paf->location) : (paf->where == TO_OBJ_APPLY) ?
act_wiz.c:			affect_loc_name(paf->location) :
act_wiz.c:			apply_locations[paf->location].name : "none",
act_wiz.c:			paf->modifier,
act_wiz.c:			(paf->duration == -1) ? -1 : (paf->duration/2) + 1,
act_wiz.c:			(paf->duration == 0) ? "" : (paf->duration == -1) ? "" : ".5",
act_wiz.c:			(paf->where == TO_OBJ_AFFECTS) ? "aff" :
act_wiz.c:			(paf->where == TO_OBJ_APPLY) ? "apply" : "?",
act_wiz.c:			oaffect_bit_name(paf->bitvector),
act_wiz.c:			(paf->owner) ? paf->owner->name : "none",
act_wiz.c:			paf->level
act_wiz.c:	area = ch->in_room->area;
act_wiz.c:	sprintf( buf, "Area Name: %s\n\r", area->name);
act_wiz.c:	sprintf( buf, "Author: %s\n\r", area->credits);
act_wiz.c:	sprintf( buf, "Filename: %s\n\r", area->file_name);
act_wiz.c:	sprintf( buf, "Vnum range: %d to %d\n\r", area->min_vnum, area->max_vnum);
act_wiz.c:	sprintf( buf, "Recommended levels: %d to %d\n\r", area->low_range,
act_wiz.c:		area->high_range);
act_wiz.c:	sprintf( buf, "Area 'age': %d  [Area repops when age = 30, or 6 if empty.]\n\r", area->age);
act_wiz.c:	sprintf( buf, "Number of players in area: %d\n\r", area->nplayer);
act_wiz.c:	sprintf( buf, "Climate: %s\n\r", climate_table[area->climate].name);
act_wiz.c:	switch (area->temp) {
act_wiz.c:	switch(area->wind) {
act_wiz.c:	switch(area->sky) {
act_wiz.c:	for (pArea = area_first; pArea; pArea = pArea->next) {
act_wiz.c:			send_to_char(pArea->name,ch);
act_wiz.c:	if (area->affected) {
act_wiz.c:		for (paf = area->affected; paf; paf = paf->next) {
act_wiz.c:			if (paf->aftype == AFT_SKILL)
act_wiz.c:				sprintf( buf, "Skill: '%s' ",skill_table[paf->type].name);
act_wiz.c:			else if (paf->aftype == AFT_POWER)
act_wiz.c:				sprintf( buf, "Power: '%s' ",skill_table[paf->type].name);
act_wiz.c:			else if (paf->aftype == AFT_COMMUNE)
act_wiz.c:				sprintf( buf, "Commune: '%s' ",skill_table[paf->type].name);
act_wiz.c:				sprintf( buf, "Spell: '%s' ",skill_table[paf->type].name);
act_wiz.c:			sprintf(buf,"modifies %s by %d for %d hours with %s-bits %s, owner %s, level %d.\n\r",
act_wiz.c:				aaffect_loc_name(paf->location),
act_wiz.c:				paf->modifier,
act_wiz.c:				(paf->duration == -1) ? paf->duration : paf->duration/2,
act_wiz.c:				paf->owner != NULL ? paf->owner->name : "none",
act_wiz.c:				paf->level);
act_wiz.c:		sprintf(buf, "Vnum:   %-12d", victim->pIndexData->vnum);
act_wiz.c:    else if(str_cmp(victim->name, victim->true_name))
act_wiz.c:		sprintf(buf, "True Name: %-10s",  victim->true_name);
act_wiz.c:	if(IS_NPC(victim) || str_cmp(victim->name, victim->true_name))
act_wiz.c:	sprintf( buf, "Name: %s%s (%s)\n\r", !IS_NPC(victim) ? "  " : "", victim->name, IS_NPC(victim) ? "NPC" : "PC");
act_wiz.c:    send_to_char("-----------------------------------------------------------------------------------------\n\r",ch);
act_wiz.c:		victim->perm_stat[STAT_STR], get_curr_stat(victim,STAT_STR),
act_wiz.c:		victim->perm_stat[STAT_INT], get_curr_stat(victim,STAT_INT),
act_wiz.c:		victim->perm_stat[STAT_WIS], get_curr_stat(victim,STAT_WIS),
act_wiz.c:		victim->perm_stat[STAT_DEX], get_curr_stat(victim,STAT_DEX),
act_wiz.c:		victim->perm_stat[STAT_CON], get_curr_stat(victim,STAT_CON));
act_wiz.c:	if(victim->Class()->GetIndex() == CLASS_NECROMANCER)
act_wiz.c:		sprintf(tbuf," (%d Souls)", victim->pcdata->souls);
act_wiz.c:    sprintf(buf, "Level:  %-11d Race:   %-10s  Sex:    %-10s Room: %-9d Class: %s\n\r", victim->level, 
act_wiz.c:		race_table[victim->race].name, sex_table[victim->sex].name, !victim->in_room ? 0 : victim->in_room->vnum,
act_wiz.c:		(RSTR)victim->Class()->name);
act_wiz.c:   	sprintf(buf, "HP:     %-5d/%-5d Mana:   %-5d/%-5d Move:   %-5d/%-5dHit:  %-9d Dam:   %-11d\n\r",
act_wiz.c:				victim->hit, victim->max_hit, victim->mana, victim->max_mana, victim->move, victim->max_move,
act_wiz.c:	sprintf(buf, "Align:  %-11s Ethos:  %-10s  Gold:   %-10ld Size: %-9s Pos:   %s\n\r",
act_wiz.c:		   		victim->alignment > ALIGN_NEUTRAL ? "good" : victim->alignment < ALIGN_NEUTRAL ? "evil" : "neutral",
act_wiz.c:				IS_NPC(victim) ? "neutral" : victim->pcdata->ethos > ETHOS_NEUTRAL ? "lawful" : 
act_wiz.c:				victim->pcdata->ethos < ETHOS_NEUTRAL ? "chaotic" : "neutral",
act_wiz.c:				victim->gold, size_table[victim->size].name, position_table[victim->position].name); 
act_wiz.c:	sprintf(buf, "Saves:  %-11d Dammod: %-8.4f%%   Hunt:   %-10s Fight: %-11s\n\r",
act_wiz.c:				victim->saving_throw, victim->dam_mod, !victim->hunting ? "(none)" : victim->hunting->name, !victim->fighting ? "(none)"
act_wiz.c:				: victim->fighting->name);
act_wiz.c:	sprintf(buf, "Master: %-11s Leader: %-10s  Pet:    %-10s Reply: %s\n\r",
act_wiz.c:			victim->master      ? victim->master->name   : "(none)",
act_wiz.c:			victim->leader      ? victim->leader->name   : "(none)",
act_wiz.c:			victim->pet         ? victim->pet->name      : "(none)",
act_wiz.c:			victim->reply       ? victim->reply->name    : "(none)");
act_wiz.c:	sprintf(buf, "Pierce: %-10d  Bash:   %-8d    Slash:  %-8d   Exotic: %-10d\n\r",
act_wiz.c:    send_to_char("-----------------------------------------------------------------------------------------\n\r",ch);
act_wiz.c:		sprintf(buf,"Count:  %-10d  XPMod:  %d%%%-5s   Wealth: %-8s   Damage: %2dd%2d+%-1d Attack: %s\n\r",
act_wiz.c:			victim->pIndexData->count, victim->pIndexData->xp_mod, "", wealth_lookup(victim->pIndexData->wealth),
act_wiz.c:			victim->damage[DICE_NUMBER],victim->damage[DICE_TYPE], GET_DAMROLL(victim), attack_table[victim->dam_type].noun);
act_wiz.c:		sprintf(buf,"Short:  %-30s  ", victim->short_descr);
act_wiz.c:		if(victim->last_fought != NULL)
act_wiz.c:        	sprintf(buf,"Tracking: Player %s.  Remaining Timer: %d\n\r",victim->last_fought->name,victim->tracktimer);
act_wiz.c:		sprintf(buf,"Hours:  %-10d  Age:    %-10d  XP:     %-8d   XPTNL:  %-6d  LLevel: %d\n\r",
act_wiz.c:		(int) (victim->played + current_time - victim->logon) / 3600, get_age(victim),
act_wiz.c:		victim->exp, victim->level * exp_per_level(victim) - victim->exp, victim->pcdata->last_level);
act_wiz.c:		sprintf(buf,"Pracs:  %-10d  Trains: %-10d  Beauty: %-8s   Wimpy:  %-6d  Home:   %s\n\r",
act_wiz.c:			victim->practice, victim->train, victim->sex == 2 ? beauty_table[victim->pcdata->beauty].female : beauty_table[victim->pcdata->beauty].male,
act_wiz.c:			victim->wimpy, hometown_table[victim->hometown].name);
act_wiz.c:		sprintf(buf,"Items:  %-10d  Weight: %-10ld  Thirst: %-8d   Hunger: %-6d  Drunk:  %d\n\r",
act_wiz.c:				victim->carry_number, get_carry_weight(victim), victim->pcdata->condition[COND_THIRST],
act_wiz.c:				victim->pcdata->condition[COND_HUNGER], victim->pcdata->condition[COND_DRUNK]);
act_wiz.c:		sprintf(cred,"%d", victim->pcdata->bounty_credits);
act_wiz.c:		sprintf(buf,"Limbs:  %-2d/%-2d       DefMod: %-3d%%        Cabal:  %-9s  CLevel: %-7d %s %s%s%s\n\r",
act_wiz.c:				victim->arms, victim->legs, victim->defense_mod,
act_wiz.c:				cabal_table[victim->cabal].name,
act_wiz.c:				victim->pcdata->cabal_level,
act_wiz.c:				victim->pcdata->tribe ? "Tribe: " : "",
act_wiz.c:				victim->pcdata->tribe ?
act_wiz.c:				tribe_table[victim->pcdata->tribe].name : "",
act_wiz.c:				(victim->pcdata->bounty_credits > 0) ? "Credits: " : "",
act_wiz.c:				(victim->pcdata->bounty_credits > 0) ? cred : "");
act_wiz.c:		sprintf(buf, "PKDs:   %-4.1f (%-2d)   MobDs:  %-10d  PKWins: %.1f(%-3d)   G/N/E:  %.1f(%-2d)/%.1f(%-2d)/%.1f(%-2d)\n\r",
act_wiz.c:			victim->pcdata->fragged, victim->pcdata->killed[PK_KILLED], victim->pcdata->killed[MOB_KILLED],
act_wiz.c:			victim->pcdata->frags[PK_KILLS], victim->pcdata->kills[PK_KILLS], victim->pcdata->frags[PK_GOOD],
act_wiz.c:			victim->pcdata->kills[PK_GOOD], victim->pcdata->frags[PK_NEUTRAL], victim->pcdata->kills[PK_NEUTRAL],
act_wiz.c:			victim->pcdata->frags[PK_EVIL], victim->pcdata->kills[PK_EVIL]);
act_wiz.c:		if(victim->ghost > 0)
act_wiz.c:			sprintf(buf,"Ghost:   %-2d hours\n\r", victim->ghost);
act_wiz.c:		if(victim->Class()->GetIndex() == CLASS_ANTI_PALADIN)
act_wiz.c:	send_to_char("-----------------------------------------------------------------------------------------\n\r",ch);
act_wiz.c:    sprintf(buf, "%s: %s\n\r",IS_NPC(victim) ? "Act" : "Plr", act_bit_name(victim->act));
act_wiz.c:    if (victim->comm[0]) {
act_wiz.c:        sprintf(buf,"Comm: %s\n\r",comm_bit_name(victim->comm));
act_wiz.c:    if(!IS_NPC(victim) && victim->trust)
act_wiz.c:		IS_SET(victim->pcdata->trust,TRUST_GROUP) ? "group " : "",
act_wiz.c:		IS_SET(victim->pcdata->trust,TRUST_CABAL) ? "cabal " : "",
act_wiz.c:		ch->pcdata->trusting ? ch->pcdata->trusting->true_name : "");
act_wiz.c:    if (IS_NPC(victim) && victim->off_flags) {
act_wiz.c:        sprintf(buf, "Offense: %s\n\r",off_bit_name(victim->off_flags));
act_wiz.c:    if (victim->imm_flags[0]) {
act_wiz.c:        sprintf(buf, "Immune: %s\n\r",imm_bit_name(victim->imm_flags));
act_wiz.c:    if (victim->res_flags[0]) {
act_wiz.c:        sprintf(buf, "Resist: %s\n\r", imm_bit_name(victim->res_flags));
act_wiz.c:    if (victim->vuln_flags[0]) {
act_wiz.c:        sprintf(buf, "Vulnerable: %s\n\r", imm_bit_name(victim->vuln_flags));
act_wiz.c:			form_bit_name(victim->form), part_bit_name(victim->parts));
act_wiz.c:    	if (victim->affected_by[0])
act_wiz.c:			affect_bit_name(victim->affected_by));
act_wiz.c:			victim->last_fight_name!=NULL ? victim->last_fight_name : "(none)",
act_wiz.c:			victim->last_fight_time ? (int)(current_time -
act_wiz.c:			victim->last_fight_time) : -1);
act_wiz.c:	if(!IS_NPC(victim) && victim->Class()->GetIndex() == CLASS_SORCERER)
act_wiz.c:		sprintf(buf,"Major Focus: %s\tPara-Elemental Focus: %s\n\r",
act_wiz.c:			sphere_table[victim->pcdata->ele_major].name,
act_wiz.c:			sphere_table[victim->pcdata->ele_para].name);
act_wiz.c:	if(!IS_NPC(victim) && victim->pcdata->styles[0]) {
act_wiz.c:			if(IS_SET(victim->pcdata->styles, style_table[i].bit)) {
act_wiz.c:	if (IS_NPC(victim) && victim->pIndexData->styles[0]) {
act_wiz.c:			if (IS_SET(victim->pIndexData->styles, style_table[i].bit)) {
act_wiz.c:	if (!IS_NPC(victim) && victim->pcdata->security)
act_wiz.c:		sprintf( buf, "Security: %d\n\r", victim->pcdata->security ); /* OLC */
act_wiz.c:	if (IS_NPC(victim) && victim->pIndexData->notes) {
act_wiz.c:		sprintf(buf,"NOTES: %s\n\r",victim->pIndexData->notes);
act_wiz.c:	if(IS_NPC(victim) && victim->pIndexData->spec_prog.func)
act_wiz.c:			if(mspec_table[i].spec_func == victim->pIndexData->spec_prog.func)
act_wiz.c:    if (IS_NPC(victim) && victim->pIndexData->progtypes != 0 )
act_wiz.c:    if ( IS_SET(victim->progtypes, MPROG_ATTACK ) ) 
act_wiz.c:				victim->pIndexData->mprogs->attack_name);
act_wiz.c:    if ( IS_SET(victim->progtypes, MPROG_BRIBE ) ) {
act_wiz.c:        sprintf(buf, "Mobile has bribe prog: %s\n\r", victim->pIndexData->mprogs->bribe_name);
act_wiz.c:    if ( IS_SET(victim->progtypes, MPROG_ENTRY ) ) {
act_wiz.c:        sprintf(buf, "Mobile has entry prog: %s\n\r", victim->pIndexData->mprogs->entry_name);
act_wiz.c:    if ( IS_SET(victim->progtypes, MPROG_GREET ) ) {
act_wiz.c:        sprintf(buf, "Mobile has greet prog: %s\n\r", victim->pIndexData->mprogs->greet_name);
act_wiz.c:    if ( IS_SET(victim->progtypes, MPROG_GIVE ) ) {
act_wiz.c:        sprintf(buf, "Mobile has give prog: %s\n\r", victim->pIndexData->mprogs->give_name);
act_wiz.c:    if ( IS_SET(victim->progtypes, MPROG_FIGHT ) ) {
act_wiz.c:        sprintf(buf, "Mobile has fight prog: %s\n\r", victim->pIndexData->mprogs->fight_name);
act_wiz.c:    if ( IS_SET(victim->progtypes, MPROG_DEATH ) ) {
act_wiz.c:        sprintf(buf, "Mobile has death prog: %s\n\r", victim->pIndexData->mprogs->death_name);
act_wiz.c:    if ( IS_SET(victim->progtypes, MPROG_PULSE ) ) {
act_wiz.c:        sprintf(buf, "Mobile has pulse prog: %s\n\r", victim->pIndexData->mprogs->pulse_name);
act_wiz.c:    if ( IS_SET(victim->progtypes, MPROG_SPEECH ) ) {
act_wiz.c:        sprintf(buf, "Mobile has speech prog: %s\n\r", victim->pIndexData->mprogs->speech_name);
act_wiz.c:    if ( IS_SET(victim->progtypes, MPROG_MOVE) ) {
act_wiz.c:        sprintf(buf, "Mobile has movement prog: %s\n\r", victim->pIndexData->mprogs->move_name);
act_wiz.c:    if(IS_NPC(victim) && IS_SET(victim->act, ACT_WARD_MOB) && IS_SET(victim->progtypes, MPROG_PULSE) 
act_wiz.c:	&& victim->pIndexData->mprogs->pulse_prog == pulse_prog_area_echo_ward)
act_wiz.c:	colorconv(tbuf,victim->short_descr,ch);
act_wiz.c:	sprintf(buf, "Ward does the following area echo every %d seconds between %d%s and %d%s to the vnum range %d-%d:\n\r%s",
act_wiz.c:		victim->level, victim->armor[2] % 12 > 0 ? victim->armor[2] % 12 : 12, 
act_wiz.c:		victim->armor[2] >= 12 ? "pm" : "am", victim->armor[3] % 12 > 0 ? victim->armor[3] % 12 : 12, 
act_wiz.c:		victim->armor[3] >= 12 ? "pm" : "am", victim->armor[0], victim->armor[1], tbuf);
act_wiz.c:	if(victim->pIndexData->cast_spell[i]==NULL)
act_wiz.c:	sprintf(buf,"Mobile casts spell '%s'.\n\r",victim->pIndexData->cast_spell[i]);
act_wiz.c:    if(IS_NPC(victim) && victim->pIndexData->barred_entry)
act_wiz.c:	barred 	= get_room_index(victim->pIndexData->barred_entry->vnum);
act_wiz.c:	i	= victim->pIndexData->barred_entry->comparison;
act_wiz.c:	barred->name,
act_wiz.c:	barred->vnum,
act_wiz.c:	criterion_flags[victim->pIndexData->barred_entry->type].name,
act_wiz.c:	victim->pIndexData->barred_entry->value);
act_wiz.c:	i	= victim->pIndexData->barred_entry->msg_type;
act_wiz.c:	victim->pIndexData->barred_entry->message,
act_wiz.c:	if(i == BAR_ECHO && victim->pIndexData->barred_entry->message_two)
act_wiz.c:		victim->pIndexData->barred_entry->message_two);
act_wiz.c:    if(IS_NPC(victim) && victim->pIndexData->pShop)
act_wiz.c:	i = victim->pIndexData->pShop->open_hour;
act_wiz.c:	x = victim->pIndexData->pShop->close_hour;
act_wiz.c:		i > 12 ? i - 12 : i, i > 12 ? "pm" : "am", x > 12 ? x - 12 : x, x > 12 ? "pm" : "am",
act_wiz.c:		direction_table[victim->pIndexData->pShop->direction].name);
act_wiz.c:	if ( IS_NPC(victim) && victim->pIndexData->restrict_low != -1) {
act_wiz.c:			victim->pIndexData->restrict_low,
act_wiz.c:			victim->pIndexData->restrict_high);
act_wiz.c:	for ( paf = victim->affected; paf != NULL; paf = paf->next )
act_wiz.c:	if (paf->aftype == AFT_SPELL)
act_wiz.c:	else if (paf->aftype == AFT_SKILL)
act_wiz.c:	else if (paf->aftype == AFT_POWER)
act_wiz.c:	else if (paf->aftype == AFT_MALADY)
act_wiz.c:	else if (paf->aftype == AFT_COMMUNE)
act_wiz.c:	else if (paf->aftype == AFT_INVIS)
act_wiz.c:	else if (paf->aftype == AFT_RUNE)
act_wiz.c:	else if (paf->aftype == AFT_TIMER)
act_wiz.c:	"%s: '%s' %s%s%smodifies %s by %d for %d%s hours with %s-bits %s, owner %s, level %d.\n\r",
act_wiz.c:	skill_table[(int) paf->type].name,
act_wiz.c:	paf->name ? "(" : "", paf->name ? paf->name : "", paf->name ? ") " : "",
act_wiz.c:	str_cmp(affect_loc_name( paf->location ), "none") ? affect_loc_name(paf->location) :
act_wiz.c:		apply_locations[paf->location].name,
act_wiz.c:	paf->modifier,
act_wiz.c:	(paf->duration == -1) ? -1 : (paf->duration/2) + 1,
act_wiz.c:	(paf->duration % 2 == 0) ? "" : (paf->duration == -1) ? "" : ".5",
act_wiz.c:	paf->where == TO_IMMUNE ? "imm" : paf->where == TO_RESIST ? "res" : paf->where == TO_VULN ? "vuln" : "aff",
act_wiz.c:	paf->where == TO_IMMUNE || paf->where == TO_RESIST || paf->where == TO_VULN ? imm_bit_name(paf->bitvector) :
act_wiz.c:	affect_bit_name( paf->bitvector ),
act_wiz.c:	paf->owner != NULL ? paf->owner->true_name : "none",
act_wiz.c:	paf->level
act_wiz.c:			victim->pcdata->command[1],victim->pcdata->command[0]);
act_wiz.c:			//sprintf(buf,"Queue %d: '%s'.\n\r", i, victim->pcdata->queue[i]);
act_wiz.c:     * -- Furey
act_wiz.c:	    if ( fAll || is_name( argument, pMobIndex->player_name ) )
act_wiz.c:		    pMobIndex->vnum, pMobIndex->short_descr );
act_wiz.c:     * -- Furey
act_wiz.c:	    if ( fAll || is_name( argument, pObjIndex->name ) )
act_wiz.c:		    pObjIndex->vnum, pObjIndex->short_descr );
act_wiz.c:    for ( obj = object_list; obj != NULL; obj = obj->next )
act_wiz.c:        if ( !can_see_obj( ch, obj ) || !is_name( argument, obj->name )
act_wiz.c:        ||   ch->level < obj->level)
act_wiz.c:        for ( in_obj = obj; in_obj->in_obj != NULL; in_obj = in_obj->in_obj )
act_wiz.c:        if ( in_obj->carried_by != NULL && can_see(ch,in_obj->carried_by)
act_wiz.c:	&&   in_obj->carried_by->in_room != NULL)
act_wiz.c:                number, obj->short_descr,PERS(in_obj->carried_by, ch),
act_wiz.c:		in_obj->carried_by->in_room->vnum );
act_wiz.c:        else if (in_obj->in_room != NULL && can_see_room(ch,in_obj->in_room))
act_wiz.c:                number, obj->short_descr,in_obj->in_room->name,
act_wiz.c:	   	in_obj->in_room->vnum);
act_wiz.c:		number--;
act_wiz.c:	for (d = descriptor_list; d != NULL; d = d->next)
act_wiz.c:	    if (d->character != NULL && d->connected == CON_PLAYING
act_wiz.c:	    &&  d->character->in_room != NULL && can_see(ch,d->character)
act_wiz.c:	    &&  can_see_room(ch,d->character->in_room))
act_wiz.c:		victim = d->character;
act_wiz.c:		if (d->original != NULL)
act_wiz.c:			count, d->original->true_name,victim->short_descr,
act_wiz.c:			victim->in_room->name,victim->in_room->vnum);
act_wiz.c:			count, IS_NPC(victim) ? victim->name : victim->true_name,victim->in_room->name,
act_wiz.c:			victim->in_room->vnum);
act_wiz.c:    for ( victim = char_list; victim != NULL; victim = victim->next )
act_wiz.c:	if ( victim->in_room != NULL
act_wiz.c:	&&   is_name( argument, victim->name ) )
act_wiz.c:	    sprintf( buf, "%3d) [%5d] %-28s [%5d] %s\n\r", count,
act_wiz.c:		IS_NPC(victim) ? victim->pIndexData->vnum : 0,
act_wiz.c:		IS_NPC(victim) ? victim->short_descr : victim->name,
act_wiz.c:		victim->in_room->vnum,
act_wiz.c:		victim->in_room->name );
act_wiz.c:	for ( obj = object_list; obj != NULL; obj = obj->next )
act_wiz.c:		if(obj->item_type != ITEM_CORPSE_PC || !obj->contains)
act_wiz.c:		for(owner=char_list;owner!=NULL;owner=owner->next)
act_wiz.c:			if(!IS_NPC(owner) && !str_cmp(owner->true_name,obj->owner))
act_wiz.c:				for (t_obj = obj->contains; t_obj != NULL; t_obj = t_obj->next_content)
act_wiz.c:					if(t_obj->item_type==ITEM_MONEY)
act_wiz.c:						owner->gold += t_obj->value[1];
act_wiz.c:		d_next = d->next;
act_wiz.c:		vch = d->original ? d->original : d->character;
act_wiz.c:		if (vch != NULL && d->connected == 0)
act_wiz.c:	if(reboot_num == -1)
act_wiz.c:			reboot_num--;
act_wiz.c:	for( pArea = area_first; pArea != NULL; pArea = pArea->next )
act_wiz.c:		if ( IS_SET(pArea->area_flags, AREA_CHANGED) || IS_SET(pArea->area_flags, AREA_ADDED))
act_wiz.c:			sprintf(area,"%s%24s\n\r", area, pArea->name);
act_wiz.c:	if(rebooting && mins != -1)
act_wiz.c:	else if(mins == -1)
act_wiz.c:		sprintf(send,"{R%s has cancelled the reboot.{x", ch->true_name);
act_wiz.c:		reboot_num = -1;
act_wiz.c:	TOGGLE_BIT(ch->in_room->room_flags, ROOM_IMP_ONLY);
act_wiz.c:    if (IS_SET(victim->comm,COMM_SNOOP_PROOF))
act_wiz.c:	act_new("$N is no longer snoop-proof.",ch,NULL,victim,TO_CHAR,POS_DEAD);
act_wiz.c:	/*send_to_char("Your snoop-proofing was just removed.\n\r",victim);*/
act_wiz.c:	REMOVE_BIT(victim->comm,COMM_SNOOP_PROOF);
act_wiz.c:	act_new("$N is now snoop-proof.",ch,NULL,victim,TO_CHAR,POS_DEAD);
act_wiz.c:	SET_BIT(victim->comm,COMM_SNOOP_PROOF);
act_wiz.c:    if ( victim->desc == NULL )
act_wiz.c:	for ( d = descriptor_list; d != NULL; d = d->next )
act_wiz.c:	    if ( d->snoop_by == ch->desc )
act_wiz.c:		d->snoop_by = NULL;
act_wiz.c:    if ( victim->desc->snoop_by != NULL )
act_wiz.c:    if (IS_SET(victim->in_room->room_flags, ROOM_IMP_ONLY) && ch->level<60)
act_wiz.c:    if (!is_room_owner(ch,victim->in_room) && ch->in_room != victim->in_room
act_wiz.c:    &&  room_is_private(victim->in_room) && ch->level<60)
act_wiz.c:    if ( victim->level >= ch->level
act_wiz.c:    ||   IS_SET(victim->comm,COMM_SNOOP_PROOF))
act_wiz.c:    if ( ch->desc != NULL )
act_wiz.c:	for ( d = ch->desc->snoop_by; d != NULL; d = d->snoop_by )
act_wiz.c:	    if ( d->character == victim || d->original == victim )
act_wiz.c:    victim->desc->snoop_by = ch->desc;
act_wiz.c:	(IS_NPC(ch) ? victim->short_descr : victim->name));
act_wiz.c:    if ( ch->desc == NULL )
act_wiz.c:    if ( ch->desc->original != NULL )
act_wiz.c:    if (!is_room_owner(ch,victim->in_room) && ch->in_room != victim->in_room
act_wiz.c:    &&  room_is_private(victim->in_room) && !IS_TRUSTED(ch,IMPLEMENTOR))
act_wiz.c:    if ( victim->desc != NULL )
act_wiz.c:    sprintf(buf,"$N switches into %s.",victim->short_descr);
act_wiz.c:    ch->desc->character = victim;
act_wiz.c:    ch->desc->original  = ch;
act_wiz.c:    victim->desc        = ch->desc;
act_wiz.c:    victim->pcdata	= ch->pcdata;
act_wiz.c:    ch->desc            = NULL;
act_wiz.c://    if (ch->prompt != NULL)
act_wiz.c://        victim->prompt = palloc_string(ch->prompt);
act_wiz.c:    copy_vector(victim->comm, ch->comm);
act_wiz.c:    victim->lines = ch->lines;
act_wiz.c:    if ( ch->desc == NULL )
act_wiz.c:    if ( ch->desc->original == NULL )
act_wiz.c:    if (ch->prompt != NULL)
act_wiz.c:	free_pstring(ch->prompt);
act_wiz.c:	ch->prompt = NULL;
act_wiz.c:    sprintf(buf,"$N returns from %s.",ch->short_descr);
act_wiz.c:    wiznet(buf,ch->desc->original,0,WIZ_SWITCHES,WIZ_SECURE,get_trust(ch));
act_wiz.c:    ch->pcdata		      = NULL;
act_wiz.c:    ch->desc->character       = ch->desc->original;
act_wiz.c:    ch->desc->original        = NULL;
act_wiz.c:    ch->desc->character->desc = ch->desc;
act_wiz.c:    ch->desc                  = NULL;
act_wiz.c:	|| (IS_TRUSTED(ch,IMMORTAL) && obj->level <= 20 && obj->cost <= 1000)
act_wiz.c:	|| (IS_TRUSTED(ch,DEMI)	    && obj->level <= 10 && obj->cost <= 500)
act_wiz.c:	|| (IS_TRUSTED(ch,ANGEL)    && obj->level <=  5 && obj->cost <= 250)
act_wiz.c:	|| (IS_TRUSTED(ch,AVATAR)   && obj->level ==  0 && obj->cost <= 100))
act_wiz.c:    for (c_obj = obj->contains; c_obj != NULL; c_obj = c_obj->next_content)
act_wiz.c:	    t_obj = create_object(c_obj->pIndexData,0);
act_wiz.c:	clone = create_object(obj->pIndexData,0);
act_wiz.c:	if (obj->carried_by != NULL)
act_wiz.c:	    obj_to_room(clone,ch->in_room);
act_wiz.c:	if ((mob->level > 20 && !IS_TRUSTED(ch,GOD))
act_wiz.c:	||  (mob->level > 10 && !IS_TRUSTED(ch,IMMORTAL))
act_wiz.c:	||  (mob->level >  5 && !IS_TRUSTED(ch,DEMI))
act_wiz.c:	||  (mob->level >  0 && !IS_TRUSTED(ch,ANGEL))
act_wiz.c:	clone = create_mobile(mob->pIndexData);
act_wiz.c:	for (obj = mob->carrying; obj != NULL; obj = obj->next_content)
act_wiz.c:		new_obj = create_object(obj->pIndexData,0);
act_wiz.c:		new_obj->wear_loc = obj->wear_loc;
act_wiz.c:	char_to_room(clone,ch->in_room);
act_wiz.c:	sprintf(buf,"$N clones %s.",clone->short_descr);
act_wiz.c:    char_to_room( victim, ch->in_room );
act_wiz.c:    act( "$n has created $N!", ch, NULL, victim, ch->invis_level > 50 ? TO_IMMINROOM : TO_ROOM );
act_wiz.c:    sprintf(buf,"$N loads %s.",victim->short_descr);
act_wiz.c:	obj_to_room( obj, ch->in_room );
act_wiz.c:    act( "$n has created $p!", ch, obj, NULL, ch->invis_level > 50 ? TO_IMMINROOM : TO_ROOM );
act_wiz.c:		for ( victim = ch->in_room->people; victim != NULL; victim = vnext )
act_wiz.c:	    	vnext = victim->next_in_room;
act_wiz.c:	    	if ( IS_NPC(victim) && !IS_SET(victim->act,ACT_NOPURGE)
act_wiz.c:	for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
act_wiz.c:	    obj_next = obj->next_content;
act_wiz.c:	  sprintf(buf,"%s tried to purge you!\n\r",ch->name);
act_wiz.c:    	if (victim->level > 1)
act_wiz.c:    	d = victim->desc;
act_wiz.c:     *   -- Swiftest
act_wiz.c:    if ( level <= victim->level )
act_wiz.c:	temp_prac = victim->practice;
act_wiz.c:	victim->level    = 1;
act_wiz.c:    	victim->exp      = exp_per_level(victim);
act_wiz.c:	victim->max_hit  = 10;
act_wiz.c:    	victim->max_mana = 100;
act_wiz.c:	victim->max_move = 100;
act_wiz.c:	victim->pcdata->perm_hit = 10;
act_wiz.c:    	victim->pcdata->perm_mana = 100;
act_wiz.c:	victim->pcdata->perm_move = 100;
act_wiz.c:	victim->practice = 0;
act_wiz.c:	victim->train 	 = 0;
act_wiz.c:	victim->hit      = victim->max_hit;
act_wiz.c:    	victim->mana     = victim->max_mana;
act_wiz.c:	victim->move     = victim->max_move;
act_wiz.c:    for ( iLevel = victim->level ; iLevel < level; iLevel++ )
act_wiz.c:	victim->level += 1;
act_wiz.c:    sprintf(buf,"You are now level %d.\n\r",victim->level);
act_wiz.c:    if(victim->level >= 52)
act_wiz.c:		res = RS.SQL.Delete("players WHERE name = '%s'",victim->true_name);
act_wiz.c:	victim->exp   = exp_per_level(victim) * UMAX( 1, victim->level );
act_wiz.c:    victim->trust = level;
act_wiz.c:        for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
act_wiz.c:            vch->hit 	= vch->max_hit;
act_wiz.c:            vch->mana   = vch->max_mana;
act_wiz.c:            vch->move	= vch->max_move;
act_wiz.c:        sprintf(buf,"$N restored room %d.",ch->in_room->vnum);
act_wiz.c:    if ( get_trust(ch) >=  MAX_LEVEL - 2 && !str_cmp(arg,"all"))
act_wiz.c:        for (d = descriptor_list; d != NULL; d = d->next)
act_wiz.c:	    victim = d->character;
act_wiz.c:            victim->hit 	= victim->max_hit;
act_wiz.c:            victim->mana    = victim->max_mana;
act_wiz.c:            victim->move	= victim->max_move;
act_wiz.c:	    if (victim->in_room != NULL)
act_wiz.c:    victim->hit  = victim->max_hit;
act_wiz.c:    victim->mana = victim->max_mana;
act_wiz.c:    victim->move = victim->max_move;
act_wiz.c:	IS_NPC(victim) ? victim->short_descr : victim->name);
act_wiz.c:    if ( IS_SET(victim->act, PLR_FREEZE) )
act_wiz.c:	REMOVE_BIT(victim->act, PLR_FREEZE);
act_wiz.c:	sprintf(buf,"$N thaws %s.",victim->name);
act_wiz.c:	SET_BIT(victim->act, PLR_FREEZE);
act_wiz.c:	sprintf(buf,"$N puts %s in the deep freeze.",victim->name);
act_wiz.c:    if ( IS_SET(victim->act, PLR_LOG) )
act_wiz.c:	REMOVE_BIT(victim->act, PLR_LOG);
act_wiz.c:	SET_BIT(victim->act, PLR_LOG);
act_wiz.c:    if ( IS_SET(victim->comm, COMM_NOEMOTE) )
act_wiz.c:	REMOVE_BIT(victim->comm, COMM_NOEMOTE);
act_wiz.c:	sprintf(buf,"$N restores emotes to %s.",victim->name);
act_wiz.c:	SET_BIT(victim->comm, COMM_NOEMOTE);
act_wiz.c:	sprintf(buf,"$N revokes %s's emotes.",victim->name);
act_wiz.c:    if ( IS_SET(victim->comm, COMM_NOSHOUT) )
act_wiz.c:	REMOVE_BIT(victim->comm, COMM_NOSHOUT);
act_wiz.c:	sprintf(buf,"$N restores shouts to %s.",victim->name);
act_wiz.c:	SET_BIT(victim->comm, COMM_NOSHOUT);
act_wiz.c:	sprintf(buf,"$N revokes %s's shouts.",victim->name);
act_wiz.c:    if ( IS_SET(victim->comm, COMM_NOTELL) )
act_wiz.c:	REMOVE_BIT(victim->comm, COMM_NOTELL);
act_wiz.c:	sprintf(buf,"$N restores tells to %s.",victim->name);
act_wiz.c:	SET_BIT(victim->comm, COMM_NOTELL);
act_wiz.c:	sprintf(buf,"$N revokes %s's tells.",victim->name);
act_wiz.c:    for ( rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room )
act_wiz.c:	if ( rch->fighting != NULL )
act_wiz.c:	if (IS_NPC(rch) && IS_SET(rch->act,ACT_AGGRESSIVE))
act_wiz.c:	    REMOVE_BIT(rch->act,ACT_AGGRESSIVE);
act_wiz.c:	    rch->last_fought = NULL;
act_wiz.c:	send_to_char( "Game un-wizlocked.\n\r", ch );
act_wiz.c:/* RT anti-newbie code */
act_wiz.c:	if(gn != -1)
act_wiz.c:		if(ch->pcdata->group_known[gn] == TRUE)
act_wiz.c:			ch->pcdata->group_known[gn] = FALSE;
act_wiz.c:			ch->pcdata->group_known[gn] = TRUE;
act_wiz.c:					sprintf(mesg,"%s now has the elemental sphere %s.\n\r",victim->name,sphere_table[i].name);
act_wiz.c:					SET_BIT(ch->pcdata->ele_sphere, sphere_table[i].element);
act_wiz.c:    if ( (value < 0 || value > 100) && (value != -2) )
act_wiz.c:	send_to_char( "Value range is 0 to 100 (-2 for permanent strip).\n\r", ch );
act_wiz.c:				victim->pcdata->learned[sn]	= value;
act_wiz.c:		victim->pcdata->learned[sn] = value;
act_wiz.c:    victim->zone = NULL;
act_wiz.c:    value = is_number( arg3 ) ? atoi( arg3 ) : -1;
act_wiz.c:			victim->pcdata->beauty = value;
act_wiz.c:	if(value>-1 && value <= SIZE_IMMENSE)
act_wiz.c:		victim->size=value;
act_wiz.c:	victim->exp = value;
act_wiz.c:	victim->hometown = hometown_lookup(arg3);
act_wiz.c:	victim->pcdata->sp = value;
act_wiz.c:	victim->perm_stat[STAT_STR] = value;
act_wiz.c:		send_to_char( "Valid security is 0-10 only.\n\r", ch );
act_wiz.c:		victim->pcdata->security = value;
act_wiz.c:        victim->perm_stat[STAT_INT] = value;
act_wiz.c:	victim->perm_stat[STAT_WIS] = value;
act_wiz.c:	victim->perm_stat[STAT_DEX] = value;
act_wiz.c:	victim->perm_stat[STAT_CON] = value;
act_wiz.c:	victim->sex = value;
act_wiz.c:	    victim->pcdata->true_sex = value;
act_wiz.c:	if ( sclass == -1 )
act_wiz.c:            	    strcat( buf, CClass::GetClass(sclass)->name );
act_wiz.c:	victim->SetClass(sclass);
act_wiz.c:	victim->level = value;
act_wiz.c:	victim->gold = value;
act_wiz.c:	if ( value < -10 || value > 30000 )
act_wiz.c:	    send_to_char( "Hp range is -10 to 30,000 hit points.\n\r", ch );
act_wiz.c:	victim->max_hit = value;
act_wiz.c:            victim->pcdata->perm_hit = value;
act_wiz.c:    victim->max_mana = value;
act_wiz.c:            victim->pcdata->perm_mana = value;
act_wiz.c:	victim->max_move = value;
act_wiz.c:            victim->pcdata->perm_move = value;
act_wiz.c:	victim->practice = value;
act_wiz.c:	victim->train = value;
act_wiz.c:	if ( value < -1000 || value > 1000 )
act_wiz.c:	    send_to_char( "Alignment range is -1000 to 1000.\n\r", ch );
act_wiz.c:	victim->alignment = value;
act_wiz.c:	if ( value < -1000 || value > 1000 )
act_wiz.c:	    send_to_char( "Ethos range is -1000 to 1000.\n\r", ch );
act_wiz.c:	    victim->pcdata->ethos = value;
act_wiz.c:	if ( value < -1 || value > 100 )
act_wiz.c:	    send_to_char( "Thirst range is -1 to 100.\n\r", ch );
act_wiz.c:	victim->pcdata->condition[COND_THIRST] = value;
act_wiz.c:	if ( value < -1 || value > 100 )
act_wiz.c:	    send_to_char( "Drunk range is -1 to 100.\n\r", ch );
act_wiz.c:	victim->pcdata->condition[COND_DRUNK] = value;
act_wiz.c:        if ( value < -1 || value > 100 )
act_wiz.c:            send_to_char( "Full range is -1 to 100.\n\r", ch );
act_wiz.c:        victim->pcdata->condition[COND_HUNGER] = value;
act_wiz.c:	victim->race = race;
act_wiz.c:	victim->size = pc_race_table[race].size;
act_wiz.c:	victim->group = value;
act_wiz.c:	victim->dam_mod = atoi(arg3);
act_wiz.c:	sprintf(buf,"%s's dam_mod set to %f%%.\n\r",IS_NPC(victim) ? victim->short_descr : victim->name, victim->dam_mod);
act_wiz.c:	victim->pcdata->tribe	= i;
act_wiz.c:	sprintf(buf,"%s is now in the %s tribe.\n\r",victim->name,capitalize(tribe_table[i].name));
act_wiz.c:	victim->pcdata->special = atoi(arg3);
act_wiz.c:	sprintf(buf,"%s now has %d specializations.\n\r",victim->name,victim->pcdata->special);
act_wiz.c:	victim->pause = atoi(arg3);
act_wiz.c:	sprintf(buf,"%s's pause set to %d.\n\r", victim->true_name, victim->pause);
act_wiz.c:	victim->zone = NULL;
act_wiz.c:	    free_pstring( victim->name );
act_wiz.c:	    victim->name = palloc_string( arg3 );
act_wiz.c:    	    free_pstring(victim->description);
act_wiz.c:    	    victim->description = palloc_string(arg3);
act_wiz.c:	    free_pstring( victim->short_descr );
act_wiz.c:	    victim->short_descr = palloc_string( arg3 );
act_wiz.c:	    free_pstring( victim->long_descr );
act_wiz.c:	    victim->long_descr = palloc_string( arg3 );
act_wiz.c:	    free_pstring( obj->name );
act_wiz.c:	    obj->name = palloc_string( arg3 );
act_wiz.c:	    free_pstring( obj->short_descr );
act_wiz.c:	    obj->short_descr = palloc_string( arg3 );
act_wiz.c:	    free_pstring( obj->description );
act_wiz.c:	    obj->description = palloc_string( arg3 );
act_wiz.c:	    ed->keyword		= palloc_string( arg3     );
act_wiz.c:	    ed->description	= palloc_string( argument );
act_wiz.c:	    ed->next		= obj->extra_descr;
act_wiz.c:	    obj->extra_descr	= ed;
act_wiz.c:	send_to_char("    value0 value1 value2 value3 value4 (v1-v4)\n\r",	ch );
act_wiz.c:/*	obj->value[0] = UMIN(50,value); */
act_wiz.c:	obj->value[0] = value;
act_wiz.c:	obj->value[1] = value;
act_wiz.c:	obj->value[2] = value;
act_wiz.c:	obj->value[3] = value;
act_wiz.c:	obj->value[4] = value;
act_wiz.c:	obj->level = value;
act_wiz.c:	obj->weight = value;
act_wiz.c:	obj->cost = value;
act_wiz.c:	obj->timer = value;
act_wiz.c:    if (!is_room_owner(ch,location) && ch->in_room != location
act_wiz.c:	location->sector_type	= value;
act_wiz.c:    for ( d = descriptor_list; d != NULL; d = d->next )
act_wiz.c:	if ( d->character != NULL && ((!d->original && can_see( ch, d->character )) || (d->original && can_see(ch,d->original)) )
act_wiz.c:	&& (!IS_SET(d->character->comm, COMM_NOSOCKET) || get_trust(ch) == MAX_LEVEL) && (arg[0] == '\0' ||
act_wiz.c:		is_name(arg,d->character->true_name) || bDis))
act_wiz.c:		d->descriptor,
act_wiz.c:	d->connected == (CON_PLAYING) ? "Playing" :
act_wiz.c:	d->connected == (CON_GET_NAME) ? "Getting name" :
act_wiz.c:	d->connected == (CON_GET_OLD_PASSWORD) ? "Getting password" :
act_wiz.c:	d->connected == (CON_CONFIRM_NEW_NAME) ? "Confirming name" :
act_wiz.c:	d->connected == (CON_GET_NEW_PASSWORD) ? "Getting new pwd" :
act_wiz.c:	d->connected == (CON_CONFIRM_NEW_PASSWORD) ? "Confirm new pwd" :
act_wiz.c:	d->connected == (CON_GET_NEW_RACE) ? "Getting race" :
act_wiz.c:	d->connected == (CON_GET_NEW_SEX) ? "Getting sex" :
act_wiz.c:	d->connected == (CON_GET_NEW_CLASS) ? "Getting class" :
act_wiz.c:	d->connected == (CON_ALLOCATE_STATS) ? "Allocating stats" :
act_wiz.c:    	d->connected == (CON_DEFAULT_CHOICE) ? "Get hometown" :
act_wiz.c:	d->connected == (CON_GET_ALIGNMENT) ? "Getting alignment" :
act_wiz.c:	d->connected == (CON_GET_ETHOS) ? "Getting ethos" :
act_wiz.c:	d->connected == (CON_READ_IMOTD) ? "Getting Imotd":
act_wiz.c:	d->connected == (CON_READ_MOTD) ? "Getting motd" :
act_wiz.c:	d->connected == (CON_CHOOSE_WEAPON) ? "Choosing weapon" :
act_wiz.c:	d->connected == (CON_GET_CABAL) ? "Getting cabal" : "null",
act_wiz.c:	(int)((current_time - d->character->logon) / 60 ) ,
act_wiz.c:		d->original  ? (d->original->true_name) ?
act_wiz.c:		d->original->true_name : d->original->name  :
act_wiz.c:		d->character ? (d->character->true_name) ?
act_wiz.c:		d->character->true_name : d->character->name : "(none)",
act_wiz.c:	bDis && get_trust(ch)>58 ? d->host : "unknown");
act_wiz.c:    return strcmp(get_end_host(d1->des->host),get_end_host(d2->des->host));
act_wiz.c:      for(d=descriptor_list;d!=NULL;d=d->next) {
act_wiz.c:	if(d->character!=NULL&&can_see(ch,d->character)) {
act_wiz.c:    for(j=0;j<i-1;j++) {
act_wiz.c:/*      if((!strcmp(get_end_host(CHARLIST[j].des->host),
act_wiz.c:         	get_end_host(CHARLIST[j+1].des->host))) ||
act_wiz.c:		(j!=0&&!strcmp(get_end_host(CHARLIST[j].des->host),
act_wiz.c:		get_end_host(CHARLIST[j-1].des->host)))) {*/
act_wiz.c:	if(!strcmp(CHARLIST[j].des->host,CHARLIST[j+1].des->host) ||
act_wiz.c:		(j!=0 && !strcmp(CHARLIST[j].des->host, CHARLIST[j-1].des->host))) {
act_wiz.c:                CHARLIST[j].des->descriptor,
act_wiz.c:                CHARLIST[j].des->connected,
act_wiz.c:                CHARLIST[j].des->original  ?
act_wiz.c:		CHARLIST[j].des->original->true_name ?
act_wiz.c:		CHARLIST[j].des->original->true_name :
act_wiz.c:		CHARLIST[j].des->original->name  :
act_wiz.c:                CHARLIST[j].des->character ?
act_wiz.c:		CHARLIST[j].des->character->true_name ?
act_wiz.c:		CHARLIST[j].des->character->true_name :
act_wiz.c:		CHARLIST[j].des->character->name : "(none)",
act_wiz.c:                (get_trust(ch) >= 55) ? CHARLIST[j].des->host : "unknown"
act_wiz.c://    if(!strcmp(get_end_host(CHARLIST[j].des->host),
act_wiz.c://		get_end_host(CHARLIST[j-1].des->host))) {
act_wiz.c:      if(!strcmp(CHARLIST[j].des->host,CHARLIST[j-1].des->host)) {
act_wiz.c:		CHARLIST[j].des->descriptor, CHARLIST[j].des->connected,
act_wiz.c:		CHARLIST[j].des->original ? CHARLIST[j].des->original->name :
act_wiz.c:		CHARLIST[j].des->character ? CHARLIST[j].des->character->name : "(none)",
act_wiz.c:		(get_trust(ch) >= 55) ? CHARLIST[j].des->host : "unknown");
act_wiz.c:	if (get_trust(ch) < MAX_LEVEL - 3 && str_cmp(arg2,"save"))
act_wiz.c:	    vch_next = vch->next;
act_wiz.c:        if (get_trust(ch) < MAX_LEVEL - 2)
act_wiz.c:            vch_next = vch->next;
act_wiz.c:	    &&	 vch->level < LEVEL_HERO)
act_wiz.c:        if (get_trust(ch) < MAX_LEVEL - 2)
act_wiz.c:            vch_next = vch->next;
act_wiz.c:            &&   vch->level >= LEVEL_HERO)
act_wiz.c://	if(victim->desc == NULL)
act_wiz.c:    	if (!is_room_owner(ch,victim->in_room)
act_wiz.c:	&&  ch->in_room != victim->in_room
act_wiz.c:        &&  room_is_private(victim->in_room) && !IS_TRUSTED(ch,IMPLEMENTOR))
act_wiz.c:	if ( !IS_NPC(victim) && get_trust(ch) < MAX_LEVEL -3)
act_wiz.c:      if ( ch->invis_level)
act_wiz.c:	  ch->invis_level = 0;
act_wiz.c:		ch->invis_level = get_trust(ch);
act_wiz.c:	  ch->reply = NULL;
act_wiz.c:ch->invis_level = level;
act_wiz.c:      if ( ch->incog_level)
act_wiz.c:          ch->incog_level = 0;
act_wiz.c:          ch->incog_level = get_trust(ch);
act_wiz.c:          ch->reply = NULL;
act_wiz.c:          ch->incog_level = level;
act_wiz.c:    if ( IS_SET(ch->act, PLR_HOLYLIGHT) )
act_wiz.c:	REMOVE_BIT(ch->act, PLR_HOLYLIGHT);
act_wiz.c:	SET_BIT(ch->act, PLR_HOLYLIGHT);
act_wiz.c:	if (ch->prefix[0] == '\0')
act_wiz.c:	free_pstring(ch->prefix);
act_wiz.c:	ch->prefix = palloc_string("");
act_wiz.c:    if (ch->prefix[0] != '\0')
act_wiz.c:	free_pstring(ch->prefix);
act_wiz.c:    ch->prefix = palloc_string(argument);
act_wiz.c:            for ( af = victim->affected; af != NULL; af = af_next )
act_wiz.c:		af_next=af->next;
act_wiz.c:		if(IS_SET(af->bitvector,AFF_PERMANENT))
act_wiz.c:    sprintf(buf,"Obj vnum %d,Max: %d, Count %d.",vnum, pObjIndex->limtotal,
act_wiz.c:pObjIndex->limcount);
act_wiz.c:		sprintf(buf,"%s ", (RSTR)CClass::GetClass(iClass)->name);
act_wiz.c:    location = ( arg[0] == '\0' ) ? ch->in_room : find_location( ch, arg );
act_wiz.c:    sprintf(buf,"Room %d flags (%s):\n\r",location->vnum,location->name);
act_wiz.c:    if (IS_SET(location->area->area_flags, AREA_EXPLORE))
act_wiz.c:    if (IS_SET(location->area->area_flags, AREA_NO_NEWBIES))
act_wiz.c:    if (IS_SET(location->area->area_flags, AREA_UNGHOST))
act_wiz.c:	if(IS_SET(location->room_flags,room_flags[i].bit))
act_wiz.c:    if(location->room_flags==0 && location->area->area_flags==0)
act_wiz.c:		    sprintf(buf,"Your death message is %s\n\r",ch->pcdata->imm_death);
act_wiz.c:		if ( strstr(argument,ch->name) == NULL)
act_wiz.c:		free_pstring( ch->pcdata->imm_death );
act_wiz.c:		ch->pcdata->imm_death = palloc_string( argument );
act_wiz.c:        sprintf(buf,"Your death message is now %s\n\r",ch->pcdata->imm_death);
act_wiz.c:	if (pobj->limtotal == 0)
act_wiz.c:	o_next = obj->next;
act_wiz.c:	if (obj->pIndexData->vnum == pobj->vnum)
act_wiz.c:    if (pobj->limcount >= pobj->limtotal )
act_wiz.c:	pobj->limcount = pobj->limtotal;
act_wiz.c:		for (paf = obj->charaffs; paf; paf = paf_next) {
act_wiz.c:	    	paf_next = paf->next;
act_wiz.c:		obj->charaffs = NULL;
act_wiz.c:		for (app = obj->apply; app; app = app_next) {
act_wiz.c:			app_next = app->next;
act_wiz.c:		obj->apply = NULL;
act_wiz.c:		app->location = location;
act_wiz.c:		app->modifier = modifier;
act_wiz.c:		app->next = obj->apply;
act_wiz.c:		obj->apply = app;
act_wiz.c:		if (af.type == -1)
act_wiz.c:		af.level = obj->level;
act_wiz.c:		af.duration = -1;
act_wiz.c:    	strtime[strlen(strtime)-1] = '\0';	
act_wiz.c:			fprintf(fp,"%s: LOAD- %s is loading %s.\n",strtime,ch->name,argument);
act_wiz.c:			fprintf(fp,"%s: SET- %s is setting %s.\n",strtime,ch->name,argument);
act_wiz.c:			fprintf(fp,"%s: STRING- %s is stringing %s.\n",strtime,ch->name,argument);
act_wiz.c:			fprintf(fp,"%s: INDUCT- %s is inducting %s.\n",strtime,ch->name,argument);
act_wiz.c:    char_to_room( victim, ch->in_room );
act_wiz.c:    sprintf( buf, "%s", victim->name );
act_wiz.c:	            if ( is_name( argument, pObjIndex->name ) )
act_wiz.c:    pObjIndex->limcount--;
act_wiz.c:    obj_to_room( obj, ch->in_room );
act_wiz.c:    sprintf( buf, "%s", obj->name );
act_wiz.c:    pObjIndex->limcount++;
act_wiz.c:		send_to_char("        history <character> -        = remove the last line from the temporary buffer\n\r", ch);
act_wiz.c:	if(victim->level>=ch->level && get_trust(ch)<60)
act_wiz.c:		victim->pcdata->history_buffer=NULL;
act_wiz.c:		if (victim->pcdata->temp_history_buffer == NULL || victim->pcdata->temp_history_buffer[0] == '\0')
act_wiz.c:			add_history(ch,victim,victim->pcdata->temp_history_buffer);
act_wiz.c:			free_pstring(victim->pcdata->temp_history_buffer);
act_wiz.c:			victim->pcdata->temp_history_buffer = NULL;
act_wiz.c:			if (victim->pcdata->temp_history_buffer) {
act_wiz.c:			strcat(obuf,victim->pcdata->temp_history_buffer);
act_wiz.c:			free_pstring(victim->pcdata->temp_history_buffer);
act_wiz.c:			victim->pcdata->temp_history_buffer = palloc_string(obuf);
act_wiz.c:	if (!strcmp(arg2,"-"))
act_wiz.c:		if (victim->pcdata->temp_history_buffer == NULL || victim->pcdata->temp_history_buffer[0] == '\0')
act_wiz.c:		strcpy(obuf,victim->pcdata->temp_history_buffer);
act_wiz.c:		for (len = strlen(obuf); len > 0; len--)
act_wiz.c:						len--;
act_wiz.c:					free_pstring(victim->pcdata->temp_history_buffer);
act_wiz.c:					victim->pcdata->temp_history_buffer = palloc_string(obuf);
act_wiz.c:		free_pstring(victim->pcdata->temp_history_buffer);
act_wiz.c:		victim->pcdata->temp_history_buffer = palloc_string(obuf);
act_wiz.c:	if (victim->pcdata->history_buffer)
act_wiz.c:		sprintf(buf,victim->pcdata->history_buffer);
act_wiz.c:		ch ? ch->name : "AUTO", strtime, (int)((victim->played + current_time - victim->logon) / 3600));
act_wiz.c:	free_pstring(victim->pcdata->history_buffer);
act_wiz.c:	victim->pcdata->history_buffer = palloc_string(buf);
act_wiz.c:	send_to_char(victim->name,ch);
act_wiz.c:	if (victim->pcdata->temp_history_buffer == NULL || victim->pcdata->temp_history_buffer[0] == '\0')
act_wiz.c:		add_buf(output,victim->pcdata->temp_history_buffer);
act_wiz.c:	send_to_char(victim->name,ch);
act_wiz.c:	if (victim->pcdata->history_buffer == NULL || victim->pcdata->history_buffer[0] == '\0') {
act_wiz.c:		add_buf(output,victim->pcdata->history_buffer);
act_wiz.c:	if (IS_SET(ch->comm, COMM_AFK))
act_wiz.c:		REMOVE_BIT(ch->comm, COMM_AFK);
act_wiz.c:		SET_BIT(ch->comm, COMM_AFK);
act_wiz.c:		if (IS_SET(victim->act, PLR_EMPOWERED))
act_wiz.c:        	REMOVE_BIT(victim->act, PLR_EMPOWERED);
act_wiz.c:			sprintf(buf,"$N revokes %s's empowerment.",victim->name);
act_wiz.c:			sprintf(buf,"AUTO: Unempowered by %s.\n\r",ch->true_name);
act_wiz.c:		if (!IS_SET(victim->act, PLR_EMPOWERED))
act_wiz.c:        	SET_BIT(victim->act, PLR_EMPOWERED);
act_wiz.c:			sprintf(buf,"$N empowers %s.",victim->name);
act_wiz.c:			sprintf(buf,"AUTO: Empowered by %s.\n\r",ch->true_name);
act_wiz.c:	if (ch->in_room->affected != NULL)
act_wiz.c:		for (paf = ch->in_room->affected; paf != NULL; paf = paf->next)
act_wiz.c:			if (paf->aftype == AFT_SPELL)
act_wiz.c:				sprintf( buf, "Spell: '%s' ", skill_table[paf->type].name);
act_wiz.c:			if (paf->aftype == AFT_SKILL)
act_wiz.c:				sprintf( buf, "Skill: '%s' ", skill_table[paf->type].name);
act_wiz.c:			if (paf->aftype == AFT_POWER)
act_wiz.c:				sprintf( buf, "Power: '%s' ", skill_table[paf->type].name);
act_wiz.c:			if (paf->aftype == AFT_COMMUNE)
act_wiz.c:				sprintf( buf, "Commune: '%s' ", skill_table[paf->type].name);
act_wiz.c:			if (paf->aftype != AFT_SPELL && paf->aftype!=AFT_SKILL && paf->aftype!=AFT_POWER && paf->aftype!=AFT_MALADY && paf->aftype!=AFT_COMMUNE)
act_wiz.c:				sprintf( buf, "Spell: '%s' ", skill_table[paf->type].name);
act_wiz.c:			sprintf(buf,"modifies %s by %d for %d hours with %s-bits %s, owner %s, level %d.\n\r",
act_wiz.c:			raffect_loc_name(paf->location),
act_wiz.c:			paf->modifier,
act_wiz.c:			paf->duration/2,
act_wiz.c:			paf->where == TO_ROOM_FLAGS ? "flag" : paf->where == TO_ROOM_CONST? "const" : "aff",
act_wiz.c:        		paf->owner != NULL ? paf->owner->name : "none",
act_wiz.c:			paf->level
act_wiz.c:	if(ch->in_room->has_rune)
act_wiz.c:		for(rune = ch->in_room->rune; rune; rune = rune->next_content)
act_wiz.c:				skill_table[rune->type].name,
act_wiz.c:				!IS_NPC(rune->owner) ? rune->owner->true_name : rune->owner->name,
act_wiz.c:				rune->level, rune->duration);
act_wiz.c:		if(ch->in_room->exit[i] && ch->in_room->exit[i]->has_rune == TRUE)
act_wiz.c:			rune = ch->in_room->exit[i]->rune;
act_wiz.c:			skill_table[rune->type].name, direction_table[i].name,
act_wiz.c:			!IS_NPC(rune->owner) ? rune->owner->true_name : rune->owner->name,
act_wiz.c:			rune->level, rune->duration);
act_wiz.c:		location = ch->in_room;
act_wiz.c:	for (af = location->affected; af != NULL; af = af_next)
act_wiz.c:		af_next = af->next;
act_wiz.c:	act("All affects stripped from '$t'.",ch,location->name,0,TO_CHAR);
act_wiz.c:	AREA_DATA *area = ch->in_room->area;
act_wiz.c:	for (af = area->affected; af; af= af_next) {
act_wiz.c:		af_next = af->next;
act_wiz.c:	act("All affects stripped from '$t'.",ch,area->name,0,TO_CHAR);
act_wiz.c:	for (af = obj->affected; af != NULL; af = af_next) {
act_wiz.c:		af_next = af->next;
act_wiz.c:		if (IS_SET(af->bitvector, AFF_PERMANENT))
act_wiz.c:	sprintf(temp,"Log added: %s receives %d experience from %s.\n\r",victim->name,xp,ch->name);
act_wiz.c:	sprintf(temp,"AUTO: %s gave %d experience.\n\r",ch->true_name,xp);
act_wiz.c:		victim->pcdata->paladin_path = PALADIN_PROTECTOR;
act_wiz.c:		victim->pcdata->paladin_path = PALADIN_CRUSADER;
act_wiz.c:		victim->pcdata->devildata[i] = FAVOR_NONE;
act_wiz.c:		victim->pcdata->greaterdata[i] = FAVOR_NONE;
act_wiz.c:		victim->pcdata->lesserdata[i] = FAVOR_NONE;
act_wiz.c:		sprintf( buf, "%-18s %3d  ", skill_table[sn].name, sn );
act_wiz.c:	if(!IS_SET(ch->comm, COMM_SWITCHSKILLS))
act_wiz.c:		SET_BIT(ch->comm, COMM_SWITCHSKILLS);
act_wiz.c:		REMOVE_BIT(ch->comm, COMM_SWITCHSKILLS);
act_wiz.c:		send_to_char("Syntax:  buglist <number>                          - detailed information about bug <number>\n\r",ch);
act_wiz.c:		send_to_char("         buglist last <number>                     - list <number> most recent bugs\n\r",ch);
act_wiz.c:		send_to_char("         buglist add <brief one line summary>      - report bug (it prompts for detailed description)\n\r",ch);
act_wiz.c:		send_to_char("         buglist done <number>                     - mark bug <number> as resolved\n\r",ch);
act_wiz.c:		sprintf(query,"Added by: %-15s Date: %-15s\n\rStatus: %s\n\rSummary: %s\n\rDescription: %s\n\r",
act_wiz.c:		ch->pcdata->temp_str = palloc_string(argument);
act_wiz.c:		send_to_char("---   ---------   ------------\n\r",ch);
act_wiz.c:	                sprintf(query,"%-5s %-11s %s %s\n\r",
act_wiz.c:		ch->true_name, log_time(), ch->pcdata->temp_str, argument);
act_wiz.c:	free_pstring(ch->pcdata->temp_str);
act_wiz.c:	fp = fopen("/home/rift/code/climate-dump.txt","w");
act_wiz.c:				sprintf(buf,"(FORM) %d-%d = %ld\n\r", race, i, (long int)pow(2, race_table[race].parts[i]));
act_wiz.c:				sprintf(buf,"(PARTS) %d-%d = %ld\n\r", race, i, (long int)pow(2, race_table[race].parts[i]));
alias.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
alias.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
alias.c:    ch = d->original ? d->original : d->character;
alias.c:    if (IS_NPC(ch) || ch->pcdata->alias[0] == NULL
alias.c:	interpret(d->character,argument);
alias.c:	if (ch->pcdata->alias[alias] == NULL)
alias.c:	if (!str_prefix(ch->pcdata->alias[alias],argument))
alias.c:	    if (!strcmp(ch->pcdata->alias[alias],name))
alias.c:		strcat(buf,ch->pcdata->alias_sub[alias]);
alias.c:		buf[MAX_INPUT_LENGTH -1] = '\0';
alias.c:    interpret(d->character,buf);
alias.c:    if (ch->desc == NULL)
alias.c:	rch = ch->desc->original ? ch->desc->original : ch;
alias.c:	if (rch->pcdata->alias[0] == NULL)
alias.c:	    if (rch->pcdata->alias[pos] == NULL
alias.c:	    ||	rch->pcdata->alias_sub[pos] == NULL)
alias.c:	    sprintf(buf,"    %s:  %s\n\r",rch->pcdata->alias[pos],
alias.c:		    rch->pcdata->alias_sub[pos]);
alias.c:	    if (rch->pcdata->alias[pos] == NULL
alias.c:	    ||	rch->pcdata->alias_sub[pos] == NULL)
alias.c:	    if (!str_cmp(arg,rch->pcdata->alias[pos]))
alias.c:		sprintf(buf,"%s aliases to '%s'.\n\r",rch->pcdata->alias[pos],
alias.c:			rch->pcdata->alias_sub[pos]);
alias.c:	if (rch->pcdata->alias[pos] == NULL)
alias.c:	if (!str_cmp(arg,rch->pcdata->alias[pos])) /* redefine an alias */
alias.c:	    free_pstring(rch->pcdata->alias_sub[pos]);
alias.c:	    rch->pcdata->alias_sub[pos] = palloc_string(argument);
alias.c:     rch->pcdata->alias[pos]		= palloc_string(arg);
alias.c:     rch->pcdata->alias_sub[pos]	= palloc_string(argument);
alias.c:    if (ch->desc == NULL)
alias.c:	rch = ch->desc->original ? ch->desc->original : ch;
alias.c:	if (rch->pcdata->alias[pos] == NULL)
alias.c:	    rch->pcdata->alias[pos-1]		= rch->pcdata->alias[pos];
alias.c:	    rch->pcdata->alias_sub[pos-1]	= rch->pcdata->alias_sub[pos];
alias.c:	    rch->pcdata->alias[pos]			= NULL;
alias.c:	    rch->pcdata->alias_sub[pos]		= NULL;
alias.c:	if(!strcmp(arg,rch->pcdata->alias[pos]))
alias.c:	    free_pstring(rch->pcdata->alias[pos]);
alias.c:	    free_pstring(rch->pcdata->alias_sub[pos]);
alias.c:	    rch->pcdata->alias[pos] = NULL;
alias.c:	    rch->pcdata->alias_sub[pos] = NULL;
ap.c:	int level = ch->level;
ap.c:	af_old = affect_find(ch->affected,gsn_bloodlust);
ap.c:		af_old->duration += UMIN(288,af_old->duration + 96);
ap.c:	if (IS_SET(victim->imm_flags,IMM_MAGIC))
ap.c:	leeched = UMIN(victim->hit/100,number_range(8,12));
ap.c:	if(victim->hit <= leeched)
ap.c:	victim->hit -= leeched;
ap.c:	ch->hit += leeched;
ap.c:	chance = get_skill(ch,skill_lookup("taunt")) - 20;	
ap.c:		&& IS_SET(victim->in_room->room_flags,ROOM_LAW))
ap.c:		chance -= 50;
ap.c:	chance += 4*(get_curr_stat(ch,STAT_INT) - get_curr_stat(victim,STAT_INT));
ap.c:		do_murder(victim,ch->name);
ap.c:	af.duration = ch->level/15;
ap.c:	af.modifier = -1;
ap.c:	af.modifier = -1;
ap.c:	if(number_percent() > (4 * get_curr_stat(ch,STAT_CON) - 5)) {
ap.c:		af->modifier-= 2;
ap.c:		&& IS_SET(victim->in_room->room_flags,ROOM_LAW))
ap.c:		level-=15;
ap.c:			sprintf(buf,"Die, %s, you sorcerous dog!",ch->name);
ap.c:	if (ch->fighting || !IS_AWAKE(ch))
ap.c:	for(victim = ch->in_room->people; victim; victim = victim->next_in_room) {
ap.c:		for(steal = victim->carrying; steal; steal=steal->next_content) {
ap.c:			if(steal->wear_loc != WEAR_NONE
ap.c:				sprintf(buf,"%s tried to steal from me!",ch->name);
ap.c:	sprintf(buf,"Your lusty senses find %s at %s.\n\r",victim->name,victim->in_room->name);
ap.c:	sprintf(buf2,"%s is wearing:\n\r",victim->name);
ap.c:	if(corpse->item_type != ITEM_CORPSE_PC && corpse->item_type != ITEM_CORPSE_NPC)
ap.c:	if(corpse->item_type == ITEM_CORPSE_PC && corpse->contains != NULL)
ap.c:	if(corpse->item_type == ITEM_CORPSE_NPC && (ch->level - corpse->level > 9))
ap.c:		ch->hit += dice(corpse->level,2);
ap.c:	af.duration		=	-1;
ap.c:	if (victim != ch->fighting)
ap.c:	if (!(af = affect_find(ch->affected,gsn_baals_mastery)))
ap.c:	if (weapon->value[0] != af->modifier)
ap.c:	switch (af->modifier) {
ap.c:				af2.level		=	ch->level;
ap.c:				af2.modifier	=	-4;
ap.c:		ch->wait = 0;
ap.c:		ch->mana += 150;
ap.c:		ch->wait = 0;
ap.c:		ch->mana += 150;
ap.c:		ch->hit /= 2;
ap.c:	if (saves_spell(level + 20 - get_curr_stat(victim,STAT_INT),victim,DAM_CHARM)) {
ap.c:		sprintf(buf,"Die, %s you sorcerous dog!",ch->name);
ap.c:	victim->pcdata->command[0] = palloc_string(arg2);
ap.c:	victim->pcdata->command[1] = palloc_string(target_name);
ap.c:	af.duration		=	-1;
ap.c:	if (ch->position < POS_FIGHTING)
ap.c:	if (ch->position < POS_FIGHTING)
ap.c:	sprintf(buf,"An irresistible urge forces you to '%s'.\n\r",ch->pcdata->command[1]);
ap.c:	RS.Queue.AddToQueue(1, 2, command_execute_delay, ch, ch->pcdata->command[1]);
ap.c:	free_pstring(ch->pcdata->command[0]);
ap.c:	free_pstring(ch->pcdata->command[1]);
ap.c:		return send_to_char("Even great self-loathing has its limits.\n\r",ch);
ap.c:	if (weapon->item_type != ITEM_WEAPON)
ap.c:	if ((ch = obj->carried_by) == NULL)
ap.c:	if (ch != af->owner) {
ap.c:		if (number_percent() < 7 && af->location == APPLY_DAMROLL)
ap.c:	if (!ch->fighting && af->modifier == 0) {
ap.c:		if (number_percent() < 4 && af->location == APPLY_DAMROLL) {
ap.c:					sprintf(buf,"%sBlood... give me blood, %s, lest I feast upon thine....%s\n\r",get_char_color(ch,"red"),ch->name,END_COLOR(ch));
ap.c:	if (!ch->fighting && number_percent() <= 33) {
ap.c:		af2->where		=	af->where;
ap.c:		af2->aftype		=	af->aftype;
ap.c:		af2->type		=	af->type;
ap.c:		af2->owner		=	af->owner;
ap.c:		af2->level		=	af->level;
ap.c:		af2->location	=	af->location;
ap.c:		af2->modifier	=	af->modifier;
ap.c:		af2->duration	=	af->duration;
ap.c:		af2->end_fun	=	af->end_fun;
ap.c:		af2->pulse_fun	=	af->pulse_fun;
ap.c:		af2->modifier--;
ap.c:		af2->modifier = UMAX(0,af2->modifier);
ap.c:	} else if (!ch->fighting)
ap.c:	if (!(obj->wear_loc == WEAR_WIELD || obj->wear_loc == WEAR_DUAL_WIELD))
ap.c:	if (IS_NPC(ch->fighting) && number_percent() > 5)
ap.c:	af2->where		=	af->where;
ap.c:	af2->aftype		=	af->aftype;
ap.c:	af2->type		=	af->type;
ap.c:	af2->owner		=	af->owner;
ap.c:	af2->level		=	af->level;
ap.c:	af2->location	=	af->location;
ap.c:	af2->modifier	=	af->modifier;
ap.c:	af2->duration	=	af->duration;
ap.c:	af2->end_fun	=	af->end_fun;
ap.c:	af2->pulse_fun	=	af->pulse_fun;
ap.c:	if (IS_NPC(ch->fighting) && af2->modifier <= 15) {
ap.c:		af2->modifier++;
ap.c:		af2->modifier = UMIN(af2->modifier, 15);
ap.c:	} else if (IS_NPC(ch->fighting)) {
ap.c:		af2->modifier -= 2;
ap.c:		af2->modifier++;
ap.c:		af2->modifier = UMIN(af2->modifier,50);
ap.c:	if (number_percent() < 10 && af2->location == APPLY_DAMROLL) {
ap.c:	if (af->location == APPLY_HITROLL)
ap.c:	if (!obj->carried_by)
ap.c:		obj->carried_by,obj,0,TO_CHAR);
ap.c:	if (!af->owner) {
ap.c:	if (!is_same_group(ch,af->owner) && af->duration == -1) {
ap.c:		af->duration = 10;
ap.c:	int devil = -1;
ap.c:	for(check = char_list; check != NULL; check=check->next) {
ap.c:		if(IS_NPC(check) && check->leader == ch) {
ap.c:		if (ch->pcdata->devildata[i] > 0) {
ap.c:	if (devil == -1)
ap.c:			if (ch->pcdata->devildata[DEVIL_ASMODEUS] == 1) {
ap.c:	fam->level 					=	ch->level;
ap.c:	fam->max_hit				=	(short)(ch->max_hit * hp_mod);
ap.c:	fam->hit					=	fam->max_hit;
ap.c:	fam->damage[DICE_TYPE]		=	3;
ap.c:	fam->damage[DICE_NUMBER]	=	ch->level;
ap.c:	fam->damage[DICE_BONUS]		=	ch->level / 3;
ap.c:	if(ch->cabal)
ap.c:		fam->cabal = ch->cabal;
ap.c:	fam->leader = ch;
ap.c:	SET_BIT(fam->affected_by, AFF_CHARM);
ap.c:	char_to_room(fam,ch->in_room);
ap.c:	sprintf(buf,"%sA jagged incarnadine rift opens in mid-air, and $N emerges.%s", get_char_color(ch,"red"), END_COLOR(ch));
ap.c:	af.level		=	ch->level;
ap.c:	/* The spell used to begin the demon-summoning rituals for AP favors. */
ap.c:	if (str_cmp(ch->Class()->name,"anti-paladin"))
ap.c:		return send_to_char("Only anti-paladins may call upon the demonic powers in this manner.\n\r",ch);
ap.c:	if (ch->ghost > 0)
ap.c:	if (!IS_SET(ch->in_room->room_flags,ROOM_DARK) && sun != SUN_SET && sun != SUN_DARK)
ap.c:	if (af->duration == 0)
ap.c:	timer.level		=	ch->level;
ap.c:	int demon = -1, type = -1;
ap.c:	af = affect_find(ch->affected,gsn_unholy_communion);
ap.c:	if (af->aftype == AFT_TIMER)
ap.c:	if (str_cmp(ch->Class()->name,"anti-paladin"))
ap.c:			if (demon_table[i].type == LESSER_DEMON && ch->level >= 25) {
ap.c:			} else if (demon_table[i].type == GREATER_DEMON && ch->level > 34) {
ap.c:	if (type == -1)
ap.c:	if (!IS_SET(ch->in_room->room_flags, ROOM_DARK) || (IS_OUTSIDE(ch) &&
ap.c:		return send_to_char("It occurs to you that a well-lit place is perhaps not ideal for this.\n\r",ch);
ap.c:	for (d = descriptor_list; d; d = d->next)
ap.c:		if (d->connected == CON_PLAYING
ap.c:			&& !IS_IMMORTAL(d->character)
ap.c:			&& !IS_NPC(d->character)
ap.c:			&& d->character->in_room->area == ch->in_room->area
ap.c:			&& d->character != ch)
ap.c:			if (ch->pcdata->lesserdata[i] == FAVOR_FAILED)
ap.c:			if (ch->pcdata->lesserdata[i] == FAVOR_IN_PROGRESS)
ap.c:			if (ch->pcdata->lesserdata[i] == FAVOR_GRANTED)
ap.c:		if (failed >= 3 || ch->pcdata->lesserdata[demon] == FAVOR_FAILED)
ap.c:		ch->pcdata->lesserdata[demon] = FAVOR_IN_PROGRESS;
ap.c:			if (ch->pcdata->greaterdata[i] == FAVOR_FAILED)
ap.c:			if(failed >= 3 || ch->pcdata->greaterdata[demon] == FAVOR_FAILED)
ap.c:			if (ch->pcdata->greaterdata[i] == FAVOR_IN_PROGRESS)
ap.c:			if (ch->pcdata->greaterdata[i] == FAVOR_GRANTED)
ap.c:		ch->pcdata->greaterdata[demon] = FAVOR_IN_PROGRESS;
ap.c:	int vnum = -1;
ap.c:				act("A well-dressed man with a wicked twinkle in his eye steps from the shadows!",ch,0,0,TO_ALL);
ap.c:				act("A huge demon materializes in mid-air and crashes unceremoniously to the ground.",ch,0,0,TO_ALL);
ap.c:	if (vnum == -1)
ap.c:	char_to_room(mob,ch->in_room);
ap.c:				RS.Queue.AddToQueue(10, 2, do_murder, mob, ch->name);
ap.c:				af.duration		=	-1;
ap.c:				RS.Queue.AddToQueue(6, 3, sprintf,buf, (char*)"%s I see you,  mortal.", ch->name);
ap.c:				RS.Queue.AddToQueue(9, 3, sprintf, buf, (char*)"%s I will not devour you; you may yet entertain me.  Rewards shall be yours if you provide me with the dead flesh of one of your aberrant lightwalking kin.  Do you submit yourself to my desire?", ch->name);
ap.c:				RS.Queue.AddToQueue(6, 5, act, "An uncomfortable sensation crawls over you as you eye this well-dressed demon.", mob, 0, ch, TO_VICT);
ap.c:	if (!IS_NPC(mob) || !af->owner)
ap.c:	switch(mob->pIndexData->vnum) {
ap.c:			if (af->owner && af->duration == 12) {
ap.c:				sprintf (buf,"%s Does it want a hint?  Does it?  We might not be in the same area as we were before, we might not... but always somewhere near, yes....",af->owner->name);
ap.c:			if (af->owner && af->duration == 1) {
ap.c:				sprintf (buf,"%s We give up... it cannnot find us... a pity, yes.  Goodbye, it.",af->owner->name);
ap.c:				af->owner->pcdata->lesserdata[LESSER_FURCAS] = FAVOR_FAILED;
ap.c:			if (af->duration == 4) {
ap.c:			if (af->duration == 1) {
ap.c:			if (af->duration % 2 == 0) {
ap.c:			if (af->duration == 1) {
ap.c:				af->owner->pcdata->lesserdata[LESSER_MALAPHAR] = FAVOR_FAILED;
ap.c:			if (af->duration == 1) {
ap.c:				af->owner->pcdata->lesserdata[LESSER_IPOS] = FAVOR_FAILED;
ap.c:	if (!IS_NPC(mob) || !af->owner)
ap.c:	switch(mob->pIndexData->vnum) {
ap.c:			if (af->duration == 5) {
ap.c:			if (af->duration == 3) {
ap.c:			if (af->duration == 1) {
ap.c:				sprintf(buf,"The abyss will not forget this treachery, %s.",af->owner->name);
ap.c:				af->owner->pcdata->greaterdata[GREATER_OZE] = FAVOR_FAILED;
ap.c:			if (af->duration == 1) {
ap.c:				sprintf(buf,"%s You fool.  You utter fool.  You know not what power you have squandered.",af->owner->name);
ap.c:			if (af->duration == 1) {
ap.c:				sprintf(buf,"%s, you fool.  You utter fool.  You know not what power you have squandered!",af->owner->name);
ap.c:			if (af->duration == 4) {
ap.c:			if (af->duration == 3) {
ap.c:			if (af->duration == 2) {
ap.c:			if (af->duration == 1) {
ap.c:				af->owner->pcdata->greaterdata[GREATER_GERYON] = FAVOR_FAILED;
ap.c:			if (af->duration == 3) {
ap.c:			if (af->duration == 2) {
ap.c:				act("As blood trickles down your neck, your mind races to decide:  ear or nose?",mob,0,af->owner,TO_VICT);
ap.c:			if (af->duration == 1) {
ap.c:				af->owner->pcdata->greaterdata[GREATER_CIMERIES] = FAVOR_FAILED;
ap.c:		sprintf(buf,"%d",pRoomIndex->vnum);
ap.c:			&& !pRoomIndex->cabal
ap.c:			&& pRoomIndex->area->area_type != ARE_UNOPENED
ap.c:			&& pRoomIndex->area->area_type != ARE_SHRINE
ap.c:			&& (is_adjacent_area(ch->in_room->area,
ap.c:				pRoomIndex->area)
ap.c:			|| (ch->in_room->area == pRoomIndex->area)))
ap.c:	if(ch->fighting != NULL) {
ap.c:	for(victim = ch->in_room->people; victim != NULL; victim = victim->next_in_room) {
ap.c:		if(ch->fighting != NULL)
ap.c:				do_bash(ch,victim->name);
ap.c:				do_murder(ch,victim->name);
ap.c:				spell_fireball(skill_lookup("fireball"),ch->level,ch,NULL,TAR_IGNORE);
ap.c:				do_cleave(ch,victim->name);
ap.c:	ROOM_INDEX_DATA *in_room = ch->in_room;
ap.c:			if(in_room->exit[DIR_NORTH] == NULL) {
ap.c:			if(in_room->exit[room] == NULL) {
ap.c:			if(in_room->exit[room] == NULL) {
ap.c:			if(in_room->exit[room] == NULL) {
ap.c:			if(in_room->exit[room] == NULL) {
ap.c:			if(in_room->exit[room] == NULL) {
ap.c:	CHAR_DATA *victim = ch->fighting;
ap.c:			do_bash(ch,victim->name);
ap.c:			do_trip(ch,victim->name);
ap.c:					spell_curse(skill_lookup("curse"),ch->level,ch,victim,TAR_CHAR_OFFENSIVE);
ap.c:					spell_blindness(skill_lookup("blindness"),ch->level,ch,victim,TAR_CHAR_OFFENSIVE);
ap.c:					spell_energy_drain(skill_lookup("energy drain"),ch->level,ch,victim,TAR_CHAR_OFFENSIVE);
ap.c:					spell_iceball(skill_lookup("iceball"),ch->level,ch,NULL,TAR_IGNORE);
ap.c:			do_bash(ch,victim->name);
ap.c:	ROOM_INDEX_DATA *room = ch->in_room;
ap.c:	if (af->duration % 24 == 0) {
ap.c:	if (af->duration == 1) {
ap.c:		act("A razor-clawed hand bursts from your belly as the world fades to black....",ch,0,0,TO_CHAR);
ap.c:		for (corpse = room->contents; corpse; corpse = corpse->next_content)
ap.c:			if (corpse->item_type == ITEM_CORPSE_PC)
ap.c:		if (corpse && corpse->item_type == ITEM_CORPSE_PC)
ap.c:		ch->pcdata->greaterdata[GREATER_GAMYGYN] = FAVOR_FAILED;
ap.c:	ROOM_INDEX_DATA *room = ch->in_room;
ap.c:	if (af->duration % 24 == 0) {
ap.c:	if (af->duration == 1) {
ap.c:		act("A razor-clawed hand bursts from your belly as the world fades to black....",ch,0,0,TO_CHAR);
ap.c:		for (corpse = room->contents; corpse; corpse = corpse->next_content)
ap.c:			if (corpse->item_type == ITEM_CORPSE_PC)
ap.c:		if (corpse && corpse->item_type == ITEM_CORPSE_PC)
ap.c:		ch->pcdata->greaterdata[GREATER_OROBAS] = FAVOR_FAILED;
ap.c:		if (ch->fighting)
ap.c:			victim = ch->fighting;
ap.c:	if(!(ch->fighting) && !(get_char_room(ch,argument))) {
ap.c:	damage_new(ch,victim,ch->level*3,TYPE_UNDEFINED,TRUE,DAM_COLD,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"icy breath");
ap.c:		if(ch->fighting)
ap.c:			victim=ch->fighting;
ap.c:	if(ch->fighting)
ap.c:		chance-=20;
ap.c:	if(victim->position == POS_SLEEPING)
ap.c:	if(victim->position < POS_STANDING)
ap.c:		damage_new(ch,victim,ch->level*2,TYPE_UNDEFINED,DAM_FIRE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"burning touch");
ap.c:		af.duration = ch->level/12;
ap.c:	for (corpse = ch->in_room->contents; corpse; corpse = corpse->next_content)
ap.c:		if (corpse->item_type == ITEM_CORPSE_PC &&
ap.c:			!str_cmp(corpse->owner,victim->true_name)) {
ap.c:		&& victim->Class()->name == "anti-paladin") {
ap.c:		act("A flailing multi-armed demon rends hungrily at $N's corpse with its many arms!",ch,0,victim,TO_ALL);
ap.c:		ch->pcdata->greaterdata[GREATER_OROBAS] = FAVOR_GRANTED;
ap.c:		ch->pcdata->learned[skill_lookup("traitors luck")] = 1;
ap.c:		ch->pcdata->greaterdata[GREATER_GAMYGYN] = FAVOR_GRANTED;
ap.c:		ch->pcdata->learned[skill_lookup("bloodlust")] = 1;
ap.c:	CHAR_DATA *owner=af->owner;
ap.c:	damage_new(owner,ch,owner->level/2,skill_lookup("burning touch"),DAM_FIRE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the consuming fire*");
ap.c:		ch->level < skill_table[gsn_darksight].skill_level[ch->Class()->GetIndex()] )
ap.c:	if (ch->pcdata->greaterdata[GREATER_GERYON] == GERYON_EYE)
ap.c:	if (ch->mana < 40)
ap.c:		ch->mana -= 20;
ap.c:	ch->mana -= 40;
ap.c:/* Dark Insight -- Completely ripped from assess */
ap.c:                act("$N appears to be resistant to $t.",ch,(char*)get_insight_line(victim->res_flags),victim,TO_CHAR);
ap.c:                act("$N appears to be immune to $t.",ch,(char*)get_insight_line(victim->imm_flags),victim,TO_CHAR);
ap.c:                act("$N appears to be vulnerable to $t.",ch,(char*)get_insight_line(victim->vuln_flags),victim,TO_CHAR);
ap.c:                dammod = victim->dam_mod;
ap.c:                if (victim->dam_mod < 20)
ap.c:                else if (victim->dam_mod <= 40)
ap.c:                else if (victim->dam_mod <= 60)
ap.c:                else if (victim->dam_mod <= 80)
ap.c:                else if (victim->dam_mod <= 99)
ap.c:                else if (victim->dam_mod <= 100)
aprog.c:		area->aprogs->pulse_prog = NULL;
aprog.c:		free_pstring(area->aprogs->pulse_name);
aprog.c:		REMOVE_BIT(area->progtypes, APROG_PULSE);
aprog.c:		area->aprogs->reset_prog = NULL;
aprog.c:		free_pstring(area->aprogs->reset_name);
aprog.c:		REMOVE_BIT(area->progtypes, APROG_RESET);
aprog.c:		area->aprogs->sun_prog = NULL;
aprog.c:		free_pstring(area->aprogs->sun_name);
aprog.c:		REMOVE_BIT(area->progtypes, APROG_SUN);
aprog.c:		area->aprogs->tick_prog = NULL;
aprog.c:		free_pstring(area->aprogs->tick_name);
aprog.c:		REMOVE_BIT(area->progtypes, APROG_TICK);
aprog.c:		area->aprogs->aggress_prog = NULL;                                                                           
aprog.c:		free_pstring(area->aprogs->aggress_name);                                                                     
aprog.c:		REMOVE_BIT(area->progtypes, APROG_AGGRESS);                                                                  
aprog.c:		area->aprogs->myell_prog = NULL;
aprog.c:		free_pstring(area->aprogs->myell_name);
aprog.c:		REMOVE_BIT(area->progtypes, APROG_MYELL);
aprog.c:		sprintf(buf,"Load_improgs: 'A': Function not found for area %s.",area->name);
aprog.c:		area->aprogs->pulse_prog = (APROG_FUN_PULSE *)aprog_table[i].function;
aprog.c:		free_pstring(area->aprogs->pulse_name);
aprog.c:		area->aprogs->pulse_name = palloc_string(name);
aprog.c:		SET_BIT(area->progtypes, APROG_PULSE);
aprog.c:		area->aprogs->reset_prog = (APROG_FUN_RESET *)aprog_table[i].function;
aprog.c:		free_pstring(area->aprogs->reset_name);
aprog.c:		area->aprogs->reset_name = palloc_string(name);
aprog.c:		SET_BIT(area->progtypes, APROG_RESET);
aprog.c:		area->aprogs->sun_prog = (APROG_FUN_SUN *)aprog_table[i].function;
aprog.c:		free_pstring(area->aprogs->sun_name);
aprog.c:		area->aprogs->sun_name = palloc_string(name);
aprog.c:		SET_BIT(area->progtypes,APROG_SUN);
aprog.c:		area->aprogs->tick_prog = (APROG_FUN_TICK *)aprog_table[i].function;
aprog.c:		free_pstring(area->aprogs->tick_name);
aprog.c:		area->aprogs->tick_name = palloc_string(name);
aprog.c:		SET_BIT(area->progtypes, APROG_TICK);
aprog.c:		area->aprogs->aggress_prog = (APROG_FUN_AGGRESS *)aprog_table[i].function;                                                        
aprog.c:		free_pstring(area->aprogs->aggress_name);                                                                     
aprog.c:		area->aprogs->aggress_name = palloc_string(name);                                                                  
aprog.c:		SET_BIT(area->progtypes, APROG_AGGRESS);                                                                     
aprog.c:		area->aprogs->myell_prog = (APROG_FUN_MYELL *)aprog_table[i].function;
aprog.c:		free_pstring(area->aprogs->myell_name);
aprog.c:		area->aprogs->myell_name = palloc_string(name);
aprog.c:		SET_BIT(area->progtypes, APROG_MYELL);
aprog.c:	for(ch = char_list; ch; ch = ch->next)
aprog.c:		if(!IS_NPC(ch) && ch->in_room->area == area && ch->level > 10 && !ch->fighting && !IS_IMMORTAL(ch))
aprog.c:			ch->gold += 25;
aprog.c:	if(area->age > 2 && area->age < 6)
aprog.c:	if(area->age >= 6)
aprog.c:	/*for ( ch->level = ch->level ; ch->level < 25; ch->level++ ) {
aprog.c:	ch->exp = exp_per_level(ch) * (ch->level - 1);*/
aprog.c:	if (area->sky >= SKY_OVERCAST)
aprog.c:	for (obj = pedroom->contents; obj; obj = obj->next_content) 
aprog.c:		if (obj->pIndexData->vnum == 9015) {
aprog.c:	for (obj = pedestal->contains; obj; obj = obj->next_content) 
aprog.c:		if (obj->pIndexData->vnum == 9016) {
aprog.c:			if (pedroom->people) {
aprog.c:				sprintf(buf,"%sAs the afternoon sun drops lower in the sky a single shaft of sunlight shines through a gap in the stones, coming to rest directly on the white marble pedestal.%s",get_char_color(pedroom->people,"yellow"),END_COLOR(pedroom->people));
aprog.c:				act(buf,pedroom->people,0,0,TO_ALL);
aprog.c:			if (pedroom->people) {
aprog.c:				sprintf(buf,"%sAs the afternoon sun drops lower in the sky a single shaft of sunlight shines through a gap in the stones, coming to rest directly on the white marble pedestal.%s",get_char_color(pedroom->people,"yellow"),END_COLOR(pedroom->people));
aprog.c:				act(buf,pedroom->people,0,0,TO_ALL);
aprog.c:				RS.Queue.AddToQueue(4, 5, act, "The opacity of the crystal sphere appears to fade, and it begins to glow a brilliant white!", pedroom->people, 0, 0, TO_ALL);
aprog.c:				RS.Queue.AddToQueue(7, 5, act, "To the northwest, an immense pillar of light ascends from the forest into the heavens!", pedroom->people, 0, 0, TO_ALL);
aprog.c:			for (obj = portroom->contents; obj; obj = obj->next_content) {
aprog.c:				if (obj->pIndexData->vnum == 9009) {
aprog.c:				if (portroom->people) {
aprog.c:					act(buf,portroom->people,0,0,TO_ALL);
aprog.c:		if (pedroom->people)
aprog.c:			act("As the sun descends toward the horizon, the shaft of light illuminating the pedestal fades to a spot, and disappears.",pedroom->people,0,0,TO_ALL);
aprog.c:		for (obj = portroom->contents; obj; obj = obj->next_content)
aprog.c:			if (obj->pIndexData->vnum == 9008) {
aprog.c:			if (portroom->people)
aprog.c:				act("The opalescent gateway begins to break down, its edges flexing and twisting wildly.",portroom->people,0,0,TO_ALL);
aprog.c:	if (area->nplayer == 0)
aprog.c:	for (shark = char_list; shark; shark = shark->next) {
aprog.c:		if (shark->pIndexData->vnum == 20111) {
aprog.c:			if (!shark->fighting && !shark->last_fought && number_percent()>50 && shark->in_room)
aprog.c:	for ( d = descriptor_list; d; d = d->next) {
aprog.c:		if ( d->connected == CON_PLAYING
aprog.c:		&&   d->character->in_room != NULL
aprog.c:		&&   d->character->in_room->area == area
aprog.c:			ch = d->character;
aprog.c:			if ((d->character->hit * 2) > d->character->max_hit)
aprog.c:			if (d->character->in_room->vnum < 20100 ||
aprog.c:				(d->character->in_room->vnum > 20150 &&
aprog.c:				 d->character->in_room->vnum < 20181) ||
aprog.c:				d->character->in_room->vnum > 20219)
aprog.c:			char_to_room(shark, ch->in_room);
aprog.c:			do_murder(shark,ch->name);
aprog.c:	if((IS_NPC(victim) && !IS_SET(victim->act, ACT_LAW))
aprog.c:	if(ch->law_pass)
aprog.c:		ch->law_pass = FALSE;
ban.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
ban.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
ban.c:				sprintf(buf,"BANNED - %s just tried to connect.", site);
ban.c:			sprintf(buf,"%-25s\t%-10s\t%-10s\t%-10s\t%-10s\t%-10s\n\r", "Site", "By", "Type", "Date", "Duration", "Reason");
ban.c:				sprintf(buf,"%-25s\t%-10s\t%-10s\t%-10s\t%-10s\t%-10s\n\r",row[0],row[1],(atoi(row[5]) > 0) ? "Newbie" : "All",row[7],row[4],row[2]);
ban.c:		send_to_char("Syntax:    ban <site> <ip/host> <newbie/all> <duration> <reason>    (-1 duration is permanent)\n\r"\
ban.c:	strftime(date, 200, "%Y-%m-%d", localtime(&current_time));
ban.c:			arg1,ch->true_name,argument,date,duration,ban_type,host_type);
basestr.c:#define UPCHAR(c)       ((c) >= 'a' && (c) <= 'z' ? (c) + 'A' - 'a' : (c))
basestr.c:	return (int)(i-myString);
basestr.c:		return -1;
basestr.c:	return (cptr - myString);
basestr.c:		return -1;
basestr.c:	return (cptr - myString);
basestr.c:	return (Find(substr, 0, fIgnoreCase) > -1);
basestr.c:			*(myString + i) += 'A' - 'a';
basestr.c:			*(myString + i) += 'a' - 'A';
basestr.c:		*myString += 'A' - 'a';
basestr.c:			*(myString + i) += 'a' - 'A';
bit.c: *  and has been used here for OLC - OLC would not be what it is without   *
bit.c: implementing a system like below with such functions. -Jason Dinkel
bit.c: Purpose:	Returns the value of the flags entered.  Multi-flags accepted.
bootup.c:                                                pObjIndex->limcount++;
bootup.c:	lhour = (current_time - 650336715) / (PULSE_TICK / PULSE_PER_SECOND);
bootup.c:	time_info.hour = ((current_time - RS_EPOCH) % (60 * 24)) / (60);
bootup.c:	time_info.day = ((current_time - RS_EPOCH) % (60 * 60 * 12)) / (60 * 24);
bootup.c:	time_info.month = ((current_time - RS_EPOCH) % (60 * 60 * 24 * 6)) / (60 * 60 * 12);
bootup.c:	time_info.year  = 1515 + (current_time - RS_EPOCH) / (60 * 60 * 24 * 6);
bootup.c:	berus_pos = ((current_time-RS_EPOCH)%(BERUS_SPD*360))/BERUS_SPD;
bootup.c:	calabren_pos = ((current_time-RS_EPOCH)%(CALABREN_SPD*360))/CALABREN_SPD;
bootup.c:	//	CArea::LoadAreaData();	//loads the data about each area - name, uid, etc
bootup.c:		if ( strArea[0] == '-' )
bootup.c:* -cal 
bootup.c:			((classname *)lastp)->next 	= stackcopy; \
bootup.c:		stackcopy->index						= i++; \
bootup.c:		stackcopy->next 						= NULL; \
bootup.c:		if(row[jloop*4 + COL_WORLD_ROOMS_0_TO_ROOM][0] != -1) \
bootup.c:		if(row[jloop*4 + COL_WORLD_ROOMS_0_TO_ROOM][0] == -1) continue;\
bootup.c:	buf[i-2] = '\0';
cabal.c:*	ROM 2.4 is copyright 1993-1995 Russ Taylor			   *
cabal.c:	if(ch->cabal == CABAL_HORDE)
cabal.c:	if(ch->cabal)
cabal.c:			if(ch->cabal != cabal_skills[i].cabal)
cabal.c:			if(ch->pcdata->cabal_level < cabal_skills[i].level && cabal_skills[i].level != 10) 
cabal.c:			if(ch->pcdata->cabal_level != cabal_skills[i].level && cabal_skills[i].specific)
cabal.c:			if(cabal_skills[i].level == 10 && ch->pcdata->induct != CABAL_LEADER)
cabal.c:			if(ch->pcdata->learned[skill_lookup(cabal_skills[i].skill)] < 2)
cabal.c:				ch->pcdata->learned[skill_lookup(cabal_skills[i].skill)] = 70;
cabal.c:			ch->pcdata->learned[skill_lookup(cabal_skills[i].skill)] = 0;
cabal.c:	if(ch->in_room->cabal != ch->cabal && !IS_IMMORTAL(ch))
cabal.c:        sprintf(buf,"%s %s '%s%s%s'",ch->name, color ? arg2 : arg1, color ? get_char_color(ch,arg1) : "",
cabal.c:        af.modifier     = -8;
cabal.c:	af.duration	= 18 - (level / 5);
cabal.c:		capitalize(tribe_table[ch->pcdata->tribe].name));
cabal.c:	for(obj = ch->carrying; obj; obj = obj->next_content)
cabal.c:		if(obj->wear_loc != WEAR_NONE && obj->wear_loc != WEAR_BRAND &&
cabal.c:		obj->wear_loc != WEAR_SHIELD && obj->wear_loc != WEAR_WIELD &&
cabal.c:		obj->wear_loc != WEAR_DUAL_WIELD && obj->wear_loc != WEAR_WAIST && obj->wear_loc != WEAR_ABOUT)
cabal.c:	switch(ch->pcdata->tribe)
cabal.c:			af.modifier	= (short)(75 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(20 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(-25 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(-20 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= -25;
cabal.c:			af.modifier	= (short)(60 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(20 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(-20 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(-15 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= -15;
cabal.c:			af.modifier	= (short)(55 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(20 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(-25 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(-15 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= -25;
cabal.c:			af.modifier	= (short)(45 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(20 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(-20 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(-20 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= -20;
cabal.c:			af.modifier	= (short)(40 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(20 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(-20 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(-20 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= -20;
cabal.c:			af.modifier	= (short)(40 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(20 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(-20 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(-30 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= -15;
cabal.c:			af.modifier	= (short)(20 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(50 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(-30 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(-20 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= -15;
cabal.c:			af.modifier	= (short)(40 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(50 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(-20 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(-20 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= -10;
cabal.c:			af.modifier	= -20;
cabal.c:			af.modifier	= (short)(30 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(50 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(-20 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier = (short)(-30 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= -15;
cabal.c:			af.modifier	= (short)(20 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(55 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(-30 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= (short)(-20 * (float) ((float)ch->level /(float)51));
cabal.c:			af.modifier	= -10;
cabal.c:        for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
cabal.c:        if (!IS_NPC(ch) && !IS_NPC(vch) && (ch->fighting == NULL || vch->fighting == NULL))
cabal.c:                spell_blindness(skill_lookup("blindness"),level-4,ch,vch,TAR_CHAR_OFFENSIVE);
cabal.c:                spell_poison(skill_lookup("poison"),level-4,ch,vch,TAR_CHAR_OFFENSIVE);
cabal.c:                spell_weaken(skill_lookup("weaken"),level-4,ch,vch,TAR_CHAR_OFFENSIVE);
cabal.c:        spell_fireball(sn,level-2,ch,NULL,TAR_CHAR_OFFENSIVE);
cabal.c:	demand = URANGE(5,victim->pcdata->bounty/500,10);
cabal.c:	if(victim->cabal>0)
cabal.c:	if(victim->pcdata->induct>0)
cabal.c:	if(demand > obj->cost && number_percent()>30)
cabal.c:		char_to_room(demon,ch->in_room);
cabal.c:		demon->hunting = ch;
cabal.c:	if(obj->cost > (demand * 2))
cabal.c:	if(obj->cost > (demand * 4))
cabal.c:	char_to_room(demon,ch->in_room);
cabal.c:	act("$n accepts the offering of $p for the blood of $T.",demon,obj,victim->name,TO_ALL);
cabal.c:	demon->hunting 	= victim;
cabal.c:	demon->master	= ch;
cabal.c:	af.duration	= ch->level;
cabal.c:	int merc_vnum=-1, amount = 0;
cabal.c:		if(ch->pcdata->bounty_credits>=bounty_table[0].credits_required)
cabal.c:			send_to_char("warrior       - 2500 gold\n\r",ch);
cabal.c:                if(ch->pcdata->bounty_credits>=bounty_table[1].credits_required)
cabal.c:                        send_to_char("thief         - 7500 gold\n\r",ch);
cabal.c:                if(ch->pcdata->bounty_credits>=bounty_table[2].credits_required)
cabal.c:                        send_to_char("assassin      - 25000 gold\n\r",ch);
cabal.c:                if(ch->pcdata->bounty_credits>=bounty_table[3].credits_required)
cabal.c:                        send_to_char("healer        - 10000 gold\n\r",ch);
cabal.c:	for(merc=char_list;merc!=NULL;merc=merc->next)
cabal.c:		if(IS_NPC(merc) && merc->pIndexData->vnum>=MOB_VNUM_WARRIOR_MERCENARY &&
cabal.c:		merc->pIndexData->vnum<=MOB_VNUM_SHAMAN_MERCENARY && merc->master==ch)
cabal.c:	if(!str_cmp(capitalize(target_name),"Warrior") && ch->pcdata->bounty_credits>=bounty_table[0].credits_required) {
cabal.c:        if(!str_cmp(capitalize(target_name),"Thief") && ch->pcdata->bounty_credits>=bounty_table[1].credits_required){
cabal.c:        if(!str_cmp(capitalize(target_name),"Assassin") && ch->pcdata->bounty_credits>=bounty_table[2].credits_required) {
cabal.c:        if(!str_cmp(capitalize(target_name),"Healer") && ch->pcdata->bounty_credits>=bounty_table[3].credits_required) {
cabal.c:	if(amount>ch->gold)
cabal.c:	ch->gold-=amount;
cabal.c:	char_to_room(merc,ch->in_room);
cabal.c:	merc->alignment=ch->alignment;
cabal.c:	merc->level = ch->level;
cabal.c:	merc->max_hit = ch->max_hit * 2;
cabal.c:	merc->hit = merc->max_hit;
cabal.c:	merc->damage[DICE_NUMBER] = ch->level/4;
cabal.c:	merc->damage[DICE_TYPE] = ch->level/10;
cabal.c:	merc->damage[DICE_BONUS] = ch->level/2;
cabal.c:		merc->leader=ch;
cabal.c:	SET_BIT(merc->affected_by,AFF_CHARM);
cabal.c:	af.modifier	= ch->pcdata->cabal_level + 2;
cabal.c:	af.duration	= (get_skill(ch,sn)-60);
cabal.c:	bcr = sqrt(ch->pcdata->bounty_credits) / 2;
cabal.c:	af.modifier	= (int)(ch->level/7 + URANGE(1,bcr,31));
cabal.c:	if(is_affected(ch, sn) || (ch->pcdata->cabal_level == 5 && ch->mana < 100))
cabal.c:	if(ch->in_room == victim->in_room)
cabal.c:	if(is_adj_range(victim->in_room->area, ch->in_room->area, UMIN(ch->pcdata->cabal_level + 1,4)))
cabal.c:		if(ch->pcdata->cabal_level == 5)
cabal.c:			ch->mana -= 100;
cabal.c:			send_to_char(victim->in_room->description,ch);
cabal.c:				char *rtitle = victim->in_room->name;
cabal.c:				ROOM_INDEX_DATA *dRoom = get_room_index(number_range(victim->in_room->vnum + 30, 
cabal.c:										     victim->in_room->vnum - 30));
cabal.c:					rtitle = dRoom->name;
cabal.c:	af.duration = (6 - ch->pcdata->cabal_level) * 2;
cabal.c:	if(ch->pcdata->cabal_level == 5)
cabal.c:	victim->move/=2;
cabal.c:	af.modifier	= -(number_range(7,15));
cabal.c:	if(victim->pcdata->bounty)
cabal.c:	if(ch->gold<amount)
cabal.c:	ch->gold-=amount;
cabal.c:	if(IS_SET(ch->comm,COMM_ANSI))
cabal.c:		sprintf(info,"An informant whispers to you '\x01B[1;31mI saw %s in %s.\x01B[0;37m'\n\r",victim->name,victim->in_room->name);
cabal.c:		sprintf(info,"An informant whispers to you 'I saw %s in %s.'\n\r",victim->name,victim->in_room->name);
cabal.c:	if (ch->mana < 30)
cabal.c:	 ch->mana -= 30;
cabal.c:	if (!ch->fighting)
cabal.c:		if ((pexit = ch->in_room->exit[dir]) != NULL && !IS_SET(pexit->exit_info,EX_CLOSED))
cabal.c:		act("$n opens $s mouth and startles you with an animal-like howl!",ch,0,0,TO_ROOM);
cabal.c:		for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
cabal.c:			vch_next = vch->next_in_room;
cabal.c:					vch->fighting==ch && (!IS_NPC(vch) || (IS_NPC(vch) && !IS_SET(vch->act,ACT_SENTINEL))))
cabal.c:	int mod = (ch->level * 2);
cabal.c:	victim->mana += mod;
cabal.c:	if(victim->mana > victim->max_mana)
cabal.c:		victim->mana = victim->max_mana;
cabal.c:	for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
cabal.c:		if(obj->pIndexData->vnum == OBJ_VNUM_SCRIBE && obj->item_type == ITEM_TRASH)
cabal.c:	if((ch->mana - cost) < 0)
cabal.c:		ch->mana -= cost;
cabal.c:	if(skill_table[skill].skill_level[ch->Class()->GetIndex()] >= 30)
cabal.c:	obj->level = 4 + (level/2) + (ipower / 200);
cabal.c:	obj->item_type = ITEM_SCROLL;
cabal.c:	obj->value[0] = 4 + (level/2) + (ipower / 100);
cabal.c:	obj->value[1] = skill;
cabal.c:	obj->value[2] = -1;
cabal.c:	obj->value[3] = -1;
cabal.c:	obj->value[4] = -1;
cabal.c:	free_pstring(obj->short_descr);
cabal.c:	obj->short_descr = palloc_string("a scroll with arcane markings");
cabal.c:	free_pstring(obj->description);
cabal.c:	obj->description = palloc_string("You see a scroll marked with some strange arcane symbols.");
cabal.c:	af.duration = ch->level / 5;
cabal.c:	if(IS_SET(victim->act, PLR_IGNORANT)) {
cabal.c:		af.duration = ch->level;
cabal.c:	for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
cabal.c:	if (IS_NPC(ch) && (!ch->desc || !ch->desc->original))
cabal.c:		ch = ch->desc->original;
cabal.c:	if ((ch->cabal != CABAL_HORDE || ch->pcdata->induct != CABAL_LEADER) && !IS_IMMORTAL(ch))
cabal.c:	if (victim->cabal == CABAL_HORDE)
cabal.c:	if (victim->cabal != CABAL_NONE)
cabal.c:	if (victim->level < 15
cabal.c:		|| (victim->Class()->name == "sorcerer")
cabal.c:		|| (victim->Class()->name == "paladin")
cabal.c:		|| (victim->Class()->name == "necromancer")
cabal.c:		|| (victim->Class()->name == "healer")
cabal.c:		|| (victim->Class()->name == "shapeshifter")
cabal.c:		|| (victim->Class()->name == "chronomancer"))
cabal.c:	af.duration		=	-1;
cabal.c:	if (af->modifier > 0)
cabal.c:	if (ch->in_room->vnum != 23628)
cabal.c:	if ((ch->level < 54 && ch->pcdata->induct != CABAL_LEADER) || IS_NPC(ch)
cabal.c:		|| ch->cabal != CABAL_HORDE)
cabal.c:	if(victim->cabal != CABAL_HORDE)
cabal.c:	victim->cabal = CABAL_NONE;
cabal.c:	free_pstring(victim->pcdata->extitle);
cabal.c:	victim->pcdata->extitle = palloc_string(", Exiled from the Horde");
cabal.c:	af.modifier = -level/6;
cabal.c:	victim->hit = UMIN(victim->max_hit, victim->hit + dice(ch->level,3));
cabal.c:	if(check_dispel(ch->level,victim,gsn_poison)) {
cabal.c:	if(check_dispel(ch->level,victim,gsn_plague)) {
cabal.c:	if(check_dispel(ch->level,victim,gsn_blindness)) {
cabal.c:	if(ch->fighting)
cabal.c:	af.modifier = -10;
cabal.c:	CHAR_DATA *victim = ch->fighting, *vch, *vch_next;
cabal.c:	for(vch = ch->in_room->people; vch; vch = vch->next_in_room)
cabal.c:	if(ch->hit < ch->max_hit * .06)
cabal.c:	for(vch = ch->in_room->people; vch; vch = vch_next)
cabal.c:		vch_next = vch->next_in_room;
cabal.c:			damage_new(ch, vch, (int)((float)ch->hit * .35), sn, DAM_TRUESTRIKE, TRUE, HIT_UNBLOCKABLE, HIT_NOADD, HIT_NOMULT, NULL);
cabal.c:	for(vch = ch->in_room->people; vch; vch = vch->next_in_room)
cabal.c:			vch->hit = UMIN(vch->max_hit, vch->hit + (level * 10 * (ch->hit / ch->max_hit)));
cabal.c:	ch->hit = (int)((float)ch->max_hit * .05);
cabal.c:	if(af->modifier == 0 || !af->owner || is_safe(af->owner, ch))
cabal.c:	float dam = af->modifier / (af->duration == 0 ? 1 : af->duration);
cabal.c:	damage_new(af->owner, ch, (int)dam, gsn_retribution, DAM_HOLY, TRUE, HIT_UNBLOCKABLE, HIT_NOADD, 
cabal.c:	af->modifier -= (int)dam;
cabal.c:	af.duration	= level - 5;
cabal.c:		if (ch->cabal != CABAL_PHALANX && !IS_IMMORTAL(ch) && ch->pcdata->induct == CABAL_LEADER)
cabal.c:		if(victim->cabal != CABAL_PHALANX)
cabal.c:		if(victim->pcdata->cabal_level > 1 && get_trust(ch) < 59)
cabal.c:				victim->pcdata->cabal_level = 2;
cabal.c:				victim->pcdata->cabal_level = 3;
cabal.c:	if(victim->hit < victim->max_hit*.7) {
chardef.c:	/* Default race -- DO NOT REMOVE OR CHANGE */
chardef.c:    {  0, -4,   0,  0 },  /* 0  */
chardef.c:    {  0, -4, 10,  1 },  /* 1  */
chardef.c:    {  0, -2, 20,  2 },
chardef.c:    { 50, -1, 30,  3 },  /* 3  */
chardef.c:    { 40, -1, 40,  4 },
chardef.c:    { 30, -1, 50,  5 },  /* 5  */
chardef.c:    { -5,  4, 240, 30 },
chardef.c:    {-10,  5, 270, 35 }, /* 20  */
chardef.c:    {-15,  6, 300, 40 },
chardef.c:    {-20,  6, 325, 45 },
chardef.c:    {-30,  7, 375, 50 },
chardef.c:    {-40,  8, 400, 55 },
chardef.c:    {-50,  9, 450, 60 }  /* 25   */
chardef.c:    {   40, 0, -12,-50},
chardef.c:    {   30, 0, -8, -40},
chardef.c:    {   20, 0, -6, -30},   /* 5 */
chardef.c:    {   10, 0, -4, -20},
chardef.c:    {    0, 0, -3, -15},
chardef.c:    {    0, 0, -2, -10},
chardef.c:    {    0, 0, -1,  -5},
chardef.c:    { - 10, 1, 0,    0},   /* 15 */
chardef.c:    { - 15, 1, 0,    0},
chardef.c:    { - 20, 2, 0,    0},
chardef.c:    { - 30, 2, 0,    0},
chardef.c:    { - 40, 3, 1,    5},
chardef.c:    { - 50, 3, 2,   10},   /* 20 */
chardef.c:    { - 60, 4, 3,   15},
chardef.c:    { - 75, 5, 4,   20},
chardef.c:    { - 90, 6, 6,   30},
chardef.c:    { -105, 7, 8,   40},
chardef.c:    { -120, 8, 12,  50}    /* 25 */
chardef.c:    { -4, 20 },   /*  0 */
chardef.c:    { -3, 25 },   /*  1 */
chardef.c:    { -2, 30 },
chardef.c:    { -2, 35 },	  /*  3 */
chardef.c:    { -1, 40 },
chardef.c:    { -1, 45 },   /*  5 */
chardef.c:    { -1, 50 },
chrono.c:		if((dir=direction_lookup(target_name))==-1)
chrono.c:	pexit = ch->in_room->exit[dir];
chrono.c:	if (!pexit || !IS_SET(pexit->exit_info, EX_ISDOOR))
chrono.c:		rune->level 		= level;
chrono.c:		rune->placed_on 	= (EXIT_DATA *) pexit;
chrono.c:		rune->target_type 	= RUNE_TO_PORTAL;	//grep for this too
chrono.c:		rune->owner		= ch;
chrono.c:		rune->trigger_type	= RUNE_TRIGGER_EXIT;	//grep for rune trigger types if you need to
chrono.c:		rune->type		= sn;
chrono.c:		rune->duration		= level / 10;
chrono.c:		rune->end_fun		= NULL;
chrono.c:		rune->function		= trigger_stasis_wall;  //this is what's called when the rune is triggered
chrono.c:	rune->level		= level;
chrono.c:	rune->placed_on		= (ROOM_INDEX_DATA *) ch->in_room;
chrono.c:	rune->target_type	= RUNE_TO_ROOM;
chrono.c:	rune->owner		= ch;
chrono.c:	rune->trigger_type 	= RUNE_TRIGGER_ENTRY;
chrono.c:	rune->type		= sn;
chrono.c:	rune->duration		= level / 10;
chrono.c:	rune->extra		= dir;
chrono.c:	rune->end_fun		= NULL;
chrono.c:	rune->drawn_in		= ch->in_room->vnum;
chrono.c:	rune->function		= activate_stasis_wall;
chrono.c:	CHAR_DATA *victim = (CHAR_DATA *) vo2, *ch = rune->owner;
chrono.c:	if(!rune->owner)
chrono.c:	CHAR_DATA *victim = (CHAR_DATA *) vo2, *ch = rune->owner;
chrono.c:	EXIT_DATA *pexit = ch->in_room->exit[dir];
chrono.c:	if(!rune->owner || rune->owner == victim || dir != rune->extra || !pexit)
chrono.c:	act("As you pass through the $t, a stasis wall snaps into existence behind you!",victim,pexit->keyword,0,TO_CHAR);
chrono.c:	act("As $n passes through the $t, a stasis wall snaps into existence behind $m!",victim,pexit->keyword,0,TO_ROOM);
chrono.c:        new_rune.level              = rune->level;
chrono.c:        new_rune.owner              = rune->owner;
chrono.c:        new_rune.type               = rune->type;
chrono.c:        new_rune.duration           = rune->level / 10;
chrono.c:        CHAR_DATA *ch = rune->owner;
chrono.c:        if(ch->in_room->vnum != rune->drawn_in)
chrono.c:                damage_new(ch,ch,dice(rune->level,4),TYPE_UNDEFINED,DAM_ENERGY,TRUE,HIT_UNBLOCKABLE,0,1,"mana surge");
chrono.c:        if(number_percent()>get_skill(ch,rune->type))
chrono.c:        act("The rune flares $t!",ch,skill_table[rune->type].msg_off,0,TO_ALL);
chrono.c:    if ( IS_NPC(ch) && ch->desc == NULL)
chrono.c:    if(ch->Class()->ctype!=CLASS_CASTER && !IS_IMMORTAL(ch))
chrono.c:    if (IS_SET(ch->act,PLR_BETRAYER))
chrono.c:    if(!IS_NPC(ch) && ch->pcdata->oalign==3 && ch->alignment==-1000)
chrono.c:    if (!IS_NPC(ch) && ch->pcdata->energy_state>2)
chrono.c:    || (!IS_NPC(ch) && ch->pcdata->learned[sn] == 0))
chrono.c:    if ( ch->position < skill_table[sn].minimum_position )
chrono.c:    if (ch->level + 2 == skill_table[sn].skill_level[ch->Class()->GetIndex()])
chrono.c:    	mana = UMAX( skill_table[sn].min_mana, 100 / ( 2 + ch->level - skill_table[sn].skill_level[ch->Class()->GetIndex()] ) );
chrono.c:	if((where = direction_lookup(target_name))<0 || !(pexit=ch->in_room->exit[where]))
chrono.c:        act("$n carefully begins to scribe an intricate rune on the $t.",ch,strcmp(pexit->keyword,"") ? pexit->keyword : "door",0,TO_ROOM);
chrono.c:        act("You carefully begin to scribe an intricate rune on the $t.",ch,strcmp(pexit->keyword,"") ? pexit->keyword : "door",0,TO_CHAR);
chrono.c:	vo = (ROOM_INDEX_DATA *) ch->in_room;
chrono.c:        act("Slowly tracing a glowing pattern in front of you, you create a rune in midair.",ch,pexit->keyword,0,TO_CHAR);
chrono.c:    if ( !IS_NPC(ch) && ch->mana < mana )
chrono.c:        ch->mana -= mana;
chrono.c:	if (IS_SET(ch->in_room->room_flags,ROOM_NO_MAGIC) && !(ch->level > LEVEL_HERO))
chrono.c:        (*skill_table[sn].spell_fun) ( sn, ch->level*2, ch, vo, target);
chrono.c:			rune = ((OBJ_DATA *) vo)->rune;
chrono.c:			rune = ((EXIT_DATA *) vo)->rune;
chrono.c:			rune = ((ROOM_INDEX_DATA *) vo)->rune;
chrono.c:        if(rune_prev && !rune_prev->next_content)
chrono.c:		rune = rune_prev->next_content;
chrono.c:	for(rune_loop = rune; rune_loop; rune_loop = rune_loop->next_content)
chrono.c:		if(rune_loop->trigger_type == trigger_type)
chrono.c:	switch(rune->target_type)
chrono.c:			obj = (OBJ_DATA *) rune->placed_on;
chrono.c:			if(obj->has_rune && rune->next_content)
chrono.c:			{       obj->rune = rune->next_content; break; }
chrono.c:			obj->has_rune = FALSE;
chrono.c:			exit = (EXIT_DATA *) rune->placed_on;
chrono.c:			if(exit->has_rune && rune->next_content)
chrono.c:			{	exit->rune = rune->next_content; break; }
chrono.c:			exit->has_rune = FALSE;
chrono.c:			room = (ROOM_INDEX_DATA *) rune->placed_on;
chrono.c:			if(room->has_rune && rune->next_content)
chrono.c:			{       room->rune = rune->next_content; break; }
chrono.c:			room->has_rune = FALSE;
chrono.c:		rune_list = rune_list->next;
chrono.c:		for(rune_prev = rune_list; rune_prev; rune_prev = rune_prev->next)
chrono.c:			if(rune_prev->next == rune)
chrono.c:				rune_prev->next = rune->next;
chrono.c:	rune_new->next	= rune_list;
chrono.c:	rune_new->next_content = NULL;
chrono.c:	switch(rune_new->target_type)
chrono.c:			obj = (OBJ_DATA *) rune_new->placed_on;
chrono.c:			if(obj->has_rune)
chrono.c:				rune_new->next_content = obj->rune;
chrono.c:			obj->rune = rune_new;
chrono.c:			obj->has_rune = TRUE;
chrono.c:			pexit = (EXIT_DATA *) rune_new->placed_on;
chrono.c:			if(pexit->has_rune)
chrono.c:				rune_new->next_content = pexit->rune;
chrono.c:			pexit->rune = rune_new;
chrono.c:			pexit->has_rune = TRUE;
chrono.c:			room = (ROOM_INDEX_DATA *) rune_new->placed_on;
chrono.c:			if(room->has_rune)
chrono.c:				rune_new->next_content = room->rune;
chrono.c:			room->rune = rune_new;
chrono.c:			room->has_rune = TRUE;
class.c:	for(CClass *j = CClass::first; j; j = j->next)
class.c:		if(j->index == nIndex)
class.c:	for (aclass = first; aclass; aclass = aclass->next)
class.c:		if (aclass->name.PrefixMatch(name))
class.c:			return aclass->index;
class.c:	return -1;
comm.c: *  Thanks to abaddon for proof-reading our comm.c and pointing out bugs.  *
comm.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
comm.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
comm.c: * This file contains all of the OS-dependent stuff:
comm.c: *    Game_loop ---> Read_from_descriptor ---> Read
comm.c: *    Game_loop ---> Read_from_buffer
comm.c: *    Game_loop ---> Process_Output ---> Write_to_descriptor -> Write
comm.c: * The OS-dependent functions are Read_from_descriptor and Write_to_descriptor.
comm.c: * -- Furey  26 Jan 1993
comm.c: * OS-dependent declarations.
comm.c:int				reboot_num = -1;
comm.c: * OS-dependent local functions.
comm.c: * Other local functions (OS-independent).
comm.c:		if(--done < 0)
comm.c:	for ( d = descriptor_list; d; d = d->next )
comm.c:	    maxdesc = UMAX( maxdesc, d->descriptor );
comm.c:	    FD_SET( d->descriptor, &in_set  );
comm.c:	    FD_SET( d->descriptor, &out_set );
comm.c:	    FD_SET( d->descriptor, &exc_set );
comm.c:	    d_next = d->next;
comm.c:	    if ( FD_ISSET( d->descriptor, &exc_set ) )
comm.c:		FD_CLR( d->descriptor, &in_set  );
comm.c:		FD_CLR( d->descriptor, &out_set );
comm.c:		if ( d->character && d->character->level > 1)
comm.c:		    save_char_obj( d->character );
comm.c:		d->outtop	= 0;
comm.c:	    d_next	= d->next;
comm.c:	    d->fcommand	= FALSE;
comm.c:	    if ( FD_ISSET( d->descriptor, &in_set ) )
comm.c:		if ( d->character != NULL )
comm.c:		    d->character->timer = 0;
comm.c:		    FD_CLR( d->descriptor, &out_set );
comm.c:		    if ( d->character != NULL && d->character->level > 1)
comm.c:			save_char_obj( d->character );
comm.c:		    d->outtop	= 0;
comm.c:	    if ( d->character != NULL && d->character->wait > 0 )
comm.c:			--d->character->wait;
comm.c:		if ( d->character != NULL && d->character->wait <= 0 && d->character->pcdata->pending)
comm.c:			interpret(d->character, d->character->pcdata->queue[0]);
comm.c:			if(!d->character) //Cal: Silly Morglum.  But what if we just interped a "quit"?
comm.c:				continue; //then d->character is null and we just crashed. :(
comm.c:			for(i=1;i<d->character->pcdata->write_next;i++) {
comm.c:				strcpy(d->character->pcdata->queue[(i-1)],
comm.c:					d->character->pcdata->queue[i]);
comm.c:			d->character->pcdata->write_next--;
comm.c:			for(i=d->character->pcdata->write_next;i<MAX_QUEUE;i++) {
comm.c:				d->character->pcdata->queue[i][0] = '\0';
comm.c:			if(d->character->pcdata->write_next == 0)
comm.c:				d->character->pcdata->pending = FALSE;
comm.c:			d->character->pcdata->queue[d->character->pcdata->read_next][0] = '\0';
comm.c:			d->character->pcdata->read_next++;
comm.c:			if (d->character->pcdata->read_next > 19)
comm.c:				d->character->pcdata->read_next = 0;
comm.c:			if (d->character->pcdata->queue[d->character->pcdata->read_next][0] == '\0') 
comm.c:				d->character->pcdata->pending = FALSE;
comm.c:	    if ( d->incomm[0] != '\0' )
comm.c:		d->fcommand	= TRUE;
comm.c:		stop_idling( d->character );
comm.c:		if ( d->showstr_point )
comm.c:			show_string( d, d->incomm );
comm.c:		else if ( d->pString )
comm.c:            string_add( d->character, d->incomm );
comm.c:		else if ( d->connected == CON_PLAYING && d->character->pcdata && d->character->pcdata->entering_text )
comm.c:            process_text(d->character, d->incomm);
comm.c:			switch( d->connected )
comm.c:						substitute_alias( d, d->incomm );
comm.c:					nanny( d, d->incomm );
comm.c:/*		if (d->showstr_point)
comm.c:		    show_string(d,d->incomm);
comm.c:		else if ( d->connected == CON_PLAYING && d->character->pcdata && d->character->pcdata->entering_text )
comm.c:		    process_text(d->character, d->incomm);
comm.c:		else if ( d->connected == CON_PLAYING )
comm.c:		    substitute_alias( d, d->incomm );
comm.c:		    nanny( d, d->incomm );
comm.c:		d->incomm[0]	= '\0';
comm.c:	    d_next = d->next;
comm.c:	    if ( ( d->fcommand || d->outtop > 0 )
comm.c:	    &&   FD_ISSET(d->descriptor, &out_set) )
comm.c:		    if ( d->character != NULL && d->character->level > 1)
comm.c:			save_char_obj( d->character );
comm.c:		    d->outtop	= 0;
comm.c:	 * Sleep( last_time + 1/PULSE_PER_SECOND - now ).
comm.c:	    usecDelta	= ((int) last_time.tv_usec) - ((int) now_time.tv_usec)
comm.c:	    secDelta	= ((int) last_time.tv_sec ) - ((int) now_time.tv_sec );
comm.c:		secDelta  -= 1;
comm.c:		usecDelta -= 1000000;
comm.c:    if ( fcntl( desc, F_SETFL, FNDELAY ) == -1 )
comm.c:    dnew->descriptor	= desc;
comm.c:    dnew->connected	= CON_GET_NAME;
comm.c:    dnew->showstr_head	= NULL;
comm.c:    dnew->showstr_point = NULL;
comm.c:    dnew->outsize	= 2000;
comm.c:    dnew->pEdit		= NULL;			/* OLC */
comm.c:    dnew->pString	= NULL;			/* OLC */
comm.c:    dnew->editor	= 0;			/* OLC */
comm.c:    dnew->outbuf	= new char[dnew->outsize];
comm.c:	dnew->outtop	= 0;
comm.c:	dnew->host = palloc_string( "(unknown)" );
comm.c:		dnew->host = palloc_string( from->h_name );
comm.c:		dnew->type = 0;
comm.c:		dnew->host = palloc_string( buf );
comm.c:		dnew->type = 1;
comm.c:    if ( check_ban(dnew->host,NBAN_ALL,dnew->type))
comm.c:    dnew->next			= descriptor_list;
comm.c:    if ( dclose->outtop > 0 )
comm.c:    if ( dclose->snoop_by != NULL )
comm.c:	write_to_buffer( dclose->snoop_by,
comm.c:	for ( d = descriptor_list; d != NULL; d = d->next )
comm.c:	    if ( d->snoop_by == dclose )
comm.c:		d->snoop_by = NULL;
comm.c:    if ( ( ch = dclose->character ) != NULL )
comm.c:	sprintf( log_buf, "Closing link to %s.", ch->name );
comm.c:	if ( dclose->connected == CON_PLAYING && !merc_down)
comm.c:	    int ftime = current_time - ch->last_fight_time;
comm.c:	    if(ch->invis_level < 51)
comm.c:				ch->last_fight_name != NULL ? ch->last_fight_name : "nobody",
comm.c:				ch->last_fight_time ? ftime > 600 ? 
comm.c:				ftime : -1,
comm.c:	    ch->desc = NULL;
comm.c:	    free_char(dclose->original ? dclose->original :
comm.c:		dclose->character );
comm.c:	d_next = d_next->next;
comm.c:	descriptor_list = descriptor_list->next;
comm.c:	for ( d = descriptor_list; d && d->next != dclose; d = d->next )
comm.c:	    d->next = dclose->next;
comm.c:    close( dclose->descriptor );
comm.c:    if ( d->incomm[0] != '\0' )
comm.c:    iStart = strlen(d->inbuf);
comm.c:    if ( iStart >= sizeof(d->inbuf) - 10 )
comm.c:		sprintf( log_buf, "%s input overflow!", d->host );
comm.c:		write_to_descriptor( d->descriptor,"\n\r*** PUT A LID ON IT!!! ***\n\r", 0 );
comm.c:		nRead = read( d->descriptor, d->inbuf + iStart,
comm.c:	    sizeof(d->inbuf) - 10 - iStart );
comm.c:	    	if ( d->inbuf[iStart-1] == '\n' || d->inbuf[iStart-1] == '\r' )
comm.c:    d->inbuf[iStart] = '\0';
comm.c:    if ( d->incomm[0] != '\0' )
comm.c:    for ( i = 0; d->inbuf[i] != '\n' && d->inbuf[i] != '\r'; i++ )
comm.c:	if ( d->inbuf[i] == '\0' )
comm.c:    for ( i = 0, k = 0; d->inbuf[i] != '\n' && d->inbuf[i] != '\r'; i++ )
comm.c:	if ( k >= MAX_INPUT_LENGTH - 2 )
comm.c:	    write_to_descriptor( d->descriptor, "Line too long.\n\r", 0 );
comm.c:	    for ( ; d->inbuf[i] != '\0'; i++ )
comm.c:		if ( d->inbuf[i] == '\n' || d->inbuf[i] == '\r' )
comm.c:	    d->inbuf[i]   = '\n';
comm.c:	    d->inbuf[i+1] = '\0';
comm.c:	if ( d->inbuf[i] == '\b' && k > 0 )
comm.c:	    --k;
comm.c:	else if ( isascii(d->inbuf[i]) && isprint(d->inbuf[i]) )
comm.c:	    d->incomm[k++] = d->inbuf[i];
comm.c:	d->incomm[k++] = ' ';
comm.c:    d->incomm[k] = '\0';
comm.c:    if ( d->incomm[0] == '!' )
comm.c:		strcpy( d->incomm, d->inlast );
comm.c:		strcpy( d->inlast, d->incomm );
comm.c:    while ( d->inbuf[i] == '\n' || d->inbuf[i] == '\r' )
comm.c:    for ( j = 0; ( d->inbuf[j] = d->inbuf[i+j] ) != '\0'; j++ )
comm.c:		for(b_af = victim->affected; b_af != NULL; b_af = b_af->next)
comm.c:			if (b_af->type == gsn_bluff)
comm.c:		percent *= (b_af->modifier * 3);
comm.c:    if (!merc_down && d->showstr_point)
comm.c:	else if (d->pString != NULL)
comm.c:	else if (!merc_down && fPrompt && d->connected == CON_PLAYING)
comm.c:	ch = d->character;
comm.c:	if ((victim = ch->fighting) != NULL)
comm.c:        if (victim->max_hit > 0)
comm.c:        	percent = victim->hit * 100 / victim->max_hit;
comm.c:        	percent = -1;
comm.c:	            (can_see(ch,victim)) ? (IS_NPC(victim) ? victim->short_descr : PERS(victim,ch)) : "Someone",wound);
comm.c:			sprintf(buf,"(Waiting: %d)\n\r", (ch->wait / PULSE_VIOLENCE));
comm.c:	ch = d->original ? d->original : d->character;
comm.c:	if (!IS_SET(ch->comm, COMM_COMPACT) )
comm.c:	if (!IS_NPC(ch) && ch->pcdata->entering_text)
comm.c:        else if ( IS_SET(ch->comm, COMM_PROMPT))
comm.c:            bust_a_prompt( d->character );
comm.c:	if (IS_SET(ch->comm,COMM_TELNET_GA))
comm.c:     * Short-circuit if nothing to write.
comm.c:    if ( d->outtop == 0 )
comm.c:     * Snoop-o-rama.
comm.c:    if ( d->snoop_by != NULL )
comm.c:	if (d->character != NULL)
comm.c:	    write_to_buffer( d->snoop_by, d->character->name,0);
comm.c:	write_to_buffer( d->snoop_by, "> ", 2 );
comm.c:	write_to_buffer( d->snoop_by, d->outbuf, d->outtop );
comm.c:     * OS-dependent output.
comm.c:     * - Wreck
comm.c:    if ( !write_to_descriptor( d->descriptor, d->outbuf, d->outtop ) )
comm.c:	d->outtop = 0;
comm.c:	d->outtop = 0;
comm.c:   Player customizable prompts. -Dev
comm.c:    if(IS_NPC(ch) || !str_cmp(ch->prompt,"")
comm.c:		|| !str_cmp(ch->prompt,"<%hhp %mm %vmv> ")
comm.c:		|| !str_cmp(ch->prompt,"<%hhp %mm %vmv>")) {
comm.c:    		ch->hit,ch->mana,ch->move,END_COLOR(ch));
comm.c:   if (IS_SET(ch->comm,COMM_AFK))
comm.c:   sprintf(buf2,"%s%s%s",get_char_color(ch,"prompt"),ch->prompt,END_COLOR(ch));
comm.c:				if ((pexit = ch->in_room->exit[door]) != NULL
comm.c:				&&  pexit ->u1.to_room != NULL
comm.c:				&&  can_see_room(ch,pexit->u1.to_room)
comm.c:				&&  !IS_SET(pexit->exit_info,EX_NONOBVIOUS)
comm.c:				&&  (!IS_SET(pexit->exit_info,EX_CLOSED) || IS_IMMORTAL(ch)))
comm.c:            if ( !IS_SET( ch->comm,COMM_ANSI ) )
comm.c:              sprintf( buf2, "%d", ch->hit);
comm.c:              sprintf( buf2, "%d", ch->hit);
comm.c:            sprintf( buf2, "%d", ch->max_hit );
comm.c:            sprintf( buf2, "%d", ch->mana );
comm.c:            sprintf( buf2, "%d", ch->max_mana );
comm.c:		 	if(ch->wait > 1)
comm.c:				sprintf(buf2,"-");
comm.c:            sprintf( buf2, "%d", ch->move );
comm.c:            sprintf( buf2, "%d", ch->max_move );
comm.c:			if (ch->max_hit == 0)
comm.c:				sprintf( buf2, "%d%s", (100 * ch->hit)/ch->max_hit, "%");
comm.c:			if (ch->max_mana == 0)
comm.c:				sprintf(buf2, "%d%s",(100 * ch->mana)/ch->max_mana, "%");
comm.c:			if (ch->max_move == 0)
comm.c:				sprintf(buf2, "%d%s",(100 * ch->move)/ch->max_move, "%");
comm.c:            sprintf( buf2, "%d", ch->exp );
comm.c:            ch->level * exp_per_level(ch) - ch->exp);
comm.c:            sprintf( buf2, "%ld", ch->gold);
comm.c:            if( ch->in_room != NULL )
comm.c:			((!IS_NPC(ch) && IS_SET(ch->act,PLR_HOLYLIGHT)) ||
comm.c:		 	(!IS_AFFECTED(ch,AFF_BLIND) && !room_is_dark( ch->in_room )))
comm.c:			? ch->in_room->name : "darkness");
comm.c:            if( IS_IMMORTAL( ch ) && ch->in_room != NULL )
comm.c:               sprintf( buf2, "%d", ch->in_room->vnum );
comm.c:            if( IS_IMMORTAL( ch ) && ch->in_room != NULL )
comm.c:               sprintf( buf2, "%s", ch->in_room->area->name );
comm.c:	    	if(IS_IMMORTAL(ch) && ch->in_room != NULL)
comm.c:    			for ( d = descriptor_list; d != NULL; d = d->next )
comm.c:        			if ( d->connected == CON_PLAYING
comm.c:        			&&   d->character->in_room != NULL
comm.c:        			&&   d->character->in_room->area == ch->in_room->area
comm.c:        			&&   !IS_IMMORTAL(d->character))
comm.c:            if(IS_IMMORTAL(ch) && ch->in_room != NULL)
comm.c:                for ( d = descriptor_list; d != NULL; d = d->next )
comm.c:                        if ( d->connected == CON_PLAYING
comm.c:                        &&   d->character->in_room != NULL
comm.c:                        &&   d->character->in_room->area == ch->in_room->area
comm.c:                        &&   can_see(ch,d->character))
comm.c:                for ( d = descriptor_list; d != NULL; d = d->next )
comm.c:                        if ( d->connected == CON_PLAYING && can_see(ch,d->character))
comm.c:            	sprintf( buf2, " (%s - %s)", olc_ed_name(ch), olc_ed_vnum(ch) );
comm.c:		sprintf(buf2,"%d", ch->pcdata->write_next);
comm.c:   write_to_buffer( ch->desc, buf, point - buf );
comm.c: * - Wreck
comm.c:    str=d->outbuf;
comm.c:    while ( *str != '\0' && (str-d->outbuf)<d->outtop )
comm.c:    	if ( (int)(point-buf)>=MAX_STRING_LENGTH-32 )
comm.c:    	    if ( !(ok=write_to_descriptor( d->descriptor,
comm.c:    	    case '-': 	sprintf( buf2, "~" );		     	       break;
comm.c:    	    case 'n':	if ( d->character && IS_ANSI( d->character ) )
comm.c:	    if ( d->character && IS_ANSI( d->character ) )
comm.c:    ok=ok && (write_to_descriptor( d->descriptor, buf, strlen( buf ) ));
comm.c:    d->outtop=0;
comm.c:    if ( d->outtop == 0 && !d->fcommand ) {
comm.c:		d->outbuf[0]	= '\n';
comm.c:		d->outbuf[1]	= '\r';
comm.c:		d->outtop	= 2;
comm.c:    while ( d->outtop + length >= d->outsize ) {
comm.c:		if (d->outsize >= 32000) {
comm.c:		    d->outtop = 0;
comm.c:		d->outsize 	*= 2;
comm.c:		outbuf       = new char[d->outsize];
comm.c:		strncpy( outbuf, d->outbuf, d->outtop );
comm.c:		delete[] d->outbuf;
comm.c:		d->outbuf   = outbuf;
comm.c:    strcpy( d->outbuf + d->outtop, txt );
comm.c:    d->outtop += length;
comm.c:	nBlock = UMIN( length - iStart, 4096 );
comm.c:	int ele_num = -1, gn = -1;
comm.c:    ch = d->character;
comm.c:    switch ( d->connected )
comm.c:		bug( "Nanny: bad d->connected %d.", d->connected );
comm.c:	ch   = d->character;
comm.c:	if (IS_SET(ch->act, PLR_DENY))
comm.c:	    sprintf( log_buf, "Denying access to %s@%s.", argument, d->host );
comm.c:	if (check_ban(d->host,NBAN_ALL,d->type) && !IS_SET(ch->act,PLR_PERMIT))
comm.c:	    d->connected = CON_GET_OLD_PASSWORD;
comm.c:	    if (check_ban(d->host,NBAN_NEWBIE,d->type))
comm.c:		d->connected = CON_CONFIRM_NEW_NAME;
comm.c:				free_char( d->character );
comm.c:				d->character = NULL;
comm.c:				d->connected = CON_GET_NAME;
comm.c:		sprintf( buf, "Give me a password for %s: %s", ch->name, echo_off_str );
comm.c:		d->connected = CON_GET_NEW_PASSWORD;
comm.c:	if ( strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ))
comm.c: * This  should hopefully handle the pfile obj->limcount bug with bad pwds
comm.c:	for (fobj = ch->carrying; fobj != NULL; fobj = fobj_next)
comm.c:	fobj_next = fobj->next_content;
comm.c:	fobj->pIndexData->limcount++; /* Increment count due to drop from */
comm.c:	if (check_playing(d,(ch->true_name ? ch->true_name :ch->name)))
comm.c:	if ( check_reconnect( d, ch->name, TRUE ) )
comm.c:	free_pstring(ch->pcdata->logon_time);
comm.c:	ch->pcdata->logon_time = palloc_string(ctime( &current_time ));
comm.c:	ch->pcdata->logon_time[strlen(ch->pcdata->logon_time)-1] = '\0';
comm.c:	ch->true_name,
comm.c:	d->host,
comm.c:	auto_check_multi(d,d->host) ? " (MULTI)" : "");
comm.c:	    d->connected = CON_READ_IMOTD;
comm.c:	    d->connected = CON_READ_MOTD;
comm.c:		d_next = d_old->next;
comm.c:		if (d_old == d || d_old->character == NULL)
comm.c:		if (str_cmp((ch->true_name ? ch->true_name :
comm.c:			ch->name),d_old->original ?
comm.c:		    d_old->original->name : (d_old->character->true_name
comm.c:			? d_old->character->true_name :d_old->character->name)))
comm.c:	    if (check_reconnect(d,ch->name,TRUE))
comm.c:            if ( d->character != NULL )
comm.c:                free_char( d->character );
comm.c:                d->character = NULL;
comm.c:	    d->connected = CON_GET_NAME;
comm.c:            if ( d->character != NULL )
comm.c:                free_char( d->character );
comm.c:                d->character = NULL;
comm.c:	    d->connected = CON_GET_NAME;
comm.c:	    sprintf(buf, "Only original and genre-appropriate names are allowed on Riftshadow.\n\r");
comm.c:	    d->connected = CON_LEGIT_NAME;
comm.c:	    free_char( d->character );
comm.c:	    d->character = NULL;
comm.c:	    d->connected = CON_GET_NAME;
comm.c:	pwdnew = crypt( argument, ch->name );
comm.c:	free_pstring( ch->pcdata->pwd );
comm.c:	ch->pcdata->pwd	= palloc_string( pwdnew );
comm.c:	d->connected = CON_CONFIRM_NEW_PASSWORD;
comm.c:	if ( strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ) )
comm.c:	    d->connected = CON_GET_NEW_PASSWORD;
comm.c:        sprintf(buf,"%-15s ( no extra xp)",pc_race_table[race].name) :
comm.c:        sprintf(buf,"%-15s (%3d extra xp)",pc_race_table[race].name,
comm.c:	d->connected = CON_GET_NEW_RACE;
comm.c:        sprintf(buf,"%-15s ( no extra xp)",pc_race_table[race].name) :
comm.c:        sprintf(buf,"%-15s (%3d extra xp)",pc_race_table[race].name,
comm.c:        ch->race = race;
comm.c:	ch->race=race;
comm.c:	copy_vector(ch->affected_by, race_data_lookup(race)->aff);
comm.c:	copy_vector(ch->imm_flags, race_data_lookup(race)->imm);
comm.c:	copy_vector(ch->res_flags, race_data_lookup(race)->res);
comm.c:	copy_vector(ch->vuln_flags, race_data_lookup(race)->vuln);
comm.c:	copy_vector(ch->form, race_data_lookup(race)->form);
comm.c:	copy_vector(ch->parts, race_data_lookup(race)->parts);
comm.c:	    ch->pcdata->learned[sn] = 100;
comm.c:	ch->size = pc_race_table[race].size;
comm.c:					  "4)  Pleasant-looking\n\r"\
comm.c:					  "----------------\n\r"\
comm.c:	d->connected = CON_GET_BEAUTY;
comm.c:			ch->pcdata->beauty = atoi(argument) + 2;
comm.c:			d->connected = CON_GET_NEW_SEX;
comm.c:	case 'm': case 'M': ch->sex = SEX_MALE;
comm.c:			    ch->pcdata->true_sex = SEX_MALE;
comm.c:	case 'f': case 'F': ch->sex = SEX_FEMALE;
comm.c:			    ch->pcdata->true_sex = SEX_FEMALE;
comm.c:		if (CClass::GetClass(classind)->status == CLASS_CLOSED)
comm.c:                sprintf(buf,"%-15s ( no extra xp)",(RSTR)tClass->name);
comm.c:	    if (pc_race_table[ch->race].classes[iClass] == 1 && CClass::GetClass(iClass)->status == CLASS_OPEN)
comm.c:                strcat( buf, (RSTR)CClass::GetClass(iClass)->name );
comm.c:	d->connected = CON_GET_NEW_CLASS;
comm.c:	if ( iClass == -1 || CClass::GetClass(iClass)->status == CLASS_CLOSED)
comm.c:	if (pc_race_table[ch->race].classes[iClass] != 1)
comm.c:	    	if (pc_race_table[ch->race].classes[iClass] == 1 && CClass::GetClass(iClass)->status == CLASS_OPEN)
comm.c:                	strcat( buf, (RSTR)CClass::GetClass(iClass)->name );
comm.c:   	ch->SetClass(iClass);
comm.c:	sprintf( log_buf, "%s@%s new player.%s", ch->name, d->host,
comm.c:	auto_check_multi(d,d->host) ? " (MULTI-CHAR?)" : "" );
comm.c:	if (ch->Class()->GetIndex() == CLASS_SORCERER) {
comm.c:		ch->pcdata->ele_temp[1] = -1;
comm.c:		ch->pcdata->ele_temp[2] = -1;
comm.c:		ch->pcdata->ele_temp[3] = -1;
comm.c:		d->connected = CON_GET_THERMAL;
comm.c:	} else if (ch->Class()->GetIndex() == CLASS_WARRIOR) {
comm.c:		d->connected = CON_CHOOSE_WEAPON;
comm.c:		ch->pcdata->start_weapon = -1;
comm.c:		ch->perm_stat[STAT_STR] = 12;
comm.c:   		ch->perm_stat[STAT_INT] = 12;
comm.c:   		ch->perm_stat[STAT_WIS] = 12;
comm.c:   		ch->perm_stat[STAT_DEX] = 12;
comm.c:   		ch->perm_stat[STAT_CON] = 12;
comm.c:		ch->train = get_allocate_points(ch);
comm.c:   		d->connected = CON_ALLOCATE_STATS;
comm.c:		ch->pcdata->ele_temp[1] = ele_num;
comm.c:		d->connected = CON_GET_MATERIAL;
comm.c:		ch->pcdata->ele_temp[2] = ele_num;
comm.c:		d->connected = CON_GET_DYNAMIC;
comm.c:		ch->pcdata->ele_temp[3] = ele_num;
comm.c:				"The remaining two will combine to form your Para-Elemental Minor focus:",
comm.c:				sphere_table[ch->pcdata->ele_temp[1]].name,
comm.c:				sphere_table[ch->pcdata->ele_temp[2]].name,
comm.c:				sphere_table[ch->pcdata->ele_temp[3]].name);
comm.c:		d->connected = CON_CHOOSE_ELE;
comm.c:		if (!(ele_num == ch->pcdata->ele_temp[1]
comm.c:			|| ele_num == ch->pcdata->ele_temp[2]
comm.c:			|| ele_num == ch->pcdata->ele_temp[3])) {
comm.c:					"The remaining two will combine to form your Para-Elemental Minor focus:",
comm.c:					sphere_table[ch->pcdata->ele_temp[1]].name,
comm.c:					sphere_table[ch->pcdata->ele_temp[2]].name,
comm.c:					sphere_table[ch->pcdata->ele_temp[3]].name);
comm.c:		if (ele_num == ch->pcdata->ele_temp[1]) {
comm.c:			ch->pcdata->ele_major = ch->pcdata->ele_temp[1];
comm.c:			ch->pcdata->ele_para = para_compute(ch->pcdata->ele_temp[2],
comm.c:				ch->pcdata->ele_temp[3]);
comm.c:		} else if (ele_num == ch->pcdata->ele_temp[2]) {
comm.c:			ch->pcdata->ele_major = ch->pcdata->ele_temp[2];
comm.c:			ch->pcdata->ele_para = para_compute(ch->pcdata->ele_temp[1],
comm.c:				ch->pcdata->ele_temp[3]);
comm.c:		} else if (ele_num == ch->pcdata->ele_temp[3]) {
comm.c:			ch->pcdata->ele_major = ch->pcdata->ele_temp[3];
comm.c:			ch->pcdata->ele_para = para_compute(ch->pcdata->ele_temp[1],
comm.c:				ch->pcdata->ele_temp[2]);
comm.c:		gn = group_lookup(sphere_table[ch->pcdata->ele_major].name);
comm.c:		gn = group_lookup(sphere_table[ch->pcdata->ele_para].name);
comm.c:		sprintf(buf,"Your Major focus is %s.\n\r",sphere_table[ch->pcdata->ele_major].name);
comm.c:		sprintf(buf,"Your Para-Elemental focus is %s.\n\r",sphere_table[ch->pcdata->ele_para].name);
comm.c:		ch->perm_stat[STAT_STR] = 12;
comm.c:   		ch->perm_stat[STAT_INT] = 12;
comm.c:   		ch->perm_stat[STAT_WIS] = 12;
comm.c:   		ch->perm_stat[STAT_DEX] = 12;
comm.c:   		ch->perm_stat[STAT_CON] = 12;
comm.c:		ch->train = get_allocate_points(ch);
comm.c:		d->connected = CON_ALLOCATE_STATS;
comm.c:		ch->pcdata->start_weapon = i;
comm.c:                ch->perm_stat[STAT_STR] = 12;
comm.c:                ch->perm_stat[STAT_INT] = 12;  
comm.c:                ch->perm_stat[STAT_WIS] = 12;
comm.c:                ch->perm_stat[STAT_DEX] = 12;
comm.c:                ch->perm_stat[STAT_CON] = 12;
comm.c:		ch->train = get_allocate_points(ch);
comm.c:                d->connected = CON_ALLOCATE_STATS;
comm.c:			modif = -1;
comm.c:			if(modamt>ch->train)
comm.c:			if((ch->perm_stat[modif]+modamt)<12)
comm.c:			if((ch->perm_stat[modif]+modamt)>pc_race_table[ch->race].max_stats[modif] &&
comm.c:				(strcmp(pc_race_table[ch->race].name,"human") || modif != ch->Class()->attr_prime || 
comm.c:					ch->perm_stat[modif]+modamt > pc_race_table[ch->race].max_stats[modif]+3))
comm.c:			ch->train -= modamt;
comm.c:			ch->perm_stat[modif] += modamt;
comm.c:			ch->mod_stat[STAT_STR]=0;
comm.c:			ch->mod_stat[STAT_INT]=0;
comm.c:			ch->mod_stat[STAT_WIS]=0;
comm.c:			ch->mod_stat[STAT_DEX]=0;
comm.c:			ch->mod_stat[STAT_CON]=0;
comm.c:			if (pc_race_table[ch->race].align == ALIGN_ANY && ch->Class()->align == ALIGN_ANY) {
comm.c:			} else if ((pc_race_table[ch->race].align == ALIGN_GN
comm.c:	&& ch->Class()->align == ALIGN_GN)
comm.c:        || (pc_race_table[ch->race].align == ALIGN_ANY
comm.c:	&& ch->Class()->align == ALIGN_GN)
comm.c:        || (pc_race_table[ch->race].align == ALIGN_GN
comm.c:	&& ch->Class()->align == ALIGN_ANY))
comm.c:        else if ((pc_race_table[ch->race].align == ALIGN_GE
comm.c:        && ch->Class()->align == ALIGN_GE)
comm.c:        || (pc_race_table[ch->race].align == ALIGN_ANY
comm.c:        && ch->Class()->align == ALIGN_GE)
comm.c:        || (pc_race_table[ch->race].align == ALIGN_GE
comm.c:        && ch->Class()->align == ALIGN_ANY))
comm.c:        else if ((pc_race_table[ch->race].align == ALIGN_NE
comm.c:	&& ch->Class()->align == ALIGN_NE)
comm.c:        || (pc_race_table[ch->race].align == ALIGN_ANY
comm.c:	&& ch->Class()->align == ALIGN_NE)
comm.c:        || (pc_race_table[ch->race].align == ALIGN_NE
comm.c:	&& ch->Class()->align == ALIGN_ANY))
comm.c:        d->connected = CON_GET_ALIGNMENT;
comm.c:        if (pc_race_table[ch->race].align == ALIGN_ANY
comm.c:	&& ch->Class()->align == ALIGN_ANY)
comm.c:            case 'g' : case 'G' : ch->alignment = 1000;  break;
comm.c:	    case 'n' : case 'N' : ch->alignment = 0;	break;
comm.c:            case 'e' : case 'E' : ch->alignment = -1000; break;
comm.c:        else if ((pc_race_table[ch->race].align == ALIGN_GN
comm.c:	&& ch->Class()->align == ALIGN_GN)
comm.c:        || (pc_race_table[ch->race].align == ALIGN_ANY
comm.c:	&& ch->Class()->align == ALIGN_GN)
comm.c:        || (pc_race_table[ch->race].align == ALIGN_GN
comm.c:	&& ch->Class()->align == ALIGN_ANY))
comm.c:            case 'g' : case 'G' : ch->alignment = 1000;  break;
comm.c:	    case 'n' : case 'N' : ch->alignment = 0;	break;
comm.c:        else if ((pc_race_table[ch->race].align == ALIGN_GE
comm.c:        && ch->Class()->align == ALIGN_GE)
comm.c:        || (pc_race_table[ch->race].align == ALIGN_ANY
comm.c:        && ch->Class()->align == ALIGN_GE)
comm.c:        || (pc_race_table[ch->race].align == ALIGN_GE
comm.c:        && ch->Class()->align == ALIGN_ANY))
comm.c:            case 'g' : case 'G' : ch->alignment = 1000;  break;
comm.c:            case 'e' : case 'E' : ch->alignment = -1000;    break;
comm.c:        else if ((pc_race_table[ch->race].align == ALIGN_NE
comm.c:	&& ch->Class()->align == ALIGN_NE)
comm.c:        || (pc_race_table[ch->race].align == ALIGN_ANY
comm.c:	&& ch->Class()->align == ALIGN_NE)
comm.c:        || (pc_race_table[ch->race].align == ALIGN_NE
comm.c:	&& ch->Class()->align == ALIGN_ANY))
comm.c:	    case 'n' : case 'N' : ch->alignment = 0;	break;
comm.c:            case 'e' : case 'E' : ch->alignment = -1000; break;
comm.c:        else if ((pc_race_table[ch->race].align == ALIGN_G
comm.c:	|| ch->Class()->align == ALIGN_G) ||
comm.c:	(pc_race_table[ch->race].align == ALIGN_GN
comm.c:	&& ch->Class()->align == ALIGN_GE))
comm.c:                ch->alignment = 1000;
comm.c:        else if (pc_race_table[ch->race].align == ALIGN_N
comm.c:	|| ch->Class()->align == ALIGN_N
comm.c:        || (pc_race_table[ch->race].align == ALIGN_GN
comm.c:	&& ch->Class()->align == ALIGN_NE)
comm.c:        || (pc_race_table[ch->race].align == ALIGN_NE
comm.c:	&& ch->Class()->align == ALIGN_GN))
comm.c:                ch->alignment = 0;
comm.c:        else if ((pc_race_table[ch->race].align == ALIGN_E
comm.c:	|| ch->Class()->align == ALIGN_E) ||
comm.c:        (pc_race_table[ch->race].align == ALIGN_NE
comm.c:        && ch->Class()->align == ALIGN_GE))
comm.c:                ch->alignment = -1000;
comm.c:	if (ch->Class()->GetIndex() != CLASS_PALADIN)
comm.c:        d->connected = CON_GET_ETHOS;
comm.c:	if (ch->Class()->GetIndex() == CLASS_PALADIN)
comm.c:		ch->pcdata->ethos = 1000;
comm.c:            case 'l' : case 'L' : ch->pcdata->ethos = 1000;  break;
comm.c:            case 'n' : case 'N' : ch->pcdata->ethos = 0;    break;
comm.c:            case 'c' : case 'C' : ch->pcdata->ethos = -1000; break;
comm.c:    ch->pcdata->learned[gsn_recall] = 100;
comm.c:	if ((ch->Class()->GetIndex() == CLASS_WARRIOR && type == ch->pcdata->start_weapon) ||
comm.c:    		(ch->Class()->weapon == weapon_table[type].vnum))
comm.c:        		ch->pcdata->learned[*weapon_table[type].gsn] = 40;
comm.c:    SET_BIT(ch->comm,COMM_SHOW_AFFECTS);
comm.c:	d->connected = CON_DEFAULT_CHOICE;
comm.c:		ch->hometown = hometown_lookup(argument);
comm.c:	d->connected = CON_NEW_CHAR;
comm.c:	d->connected = CON_READ_MOTD;
comm.c:        d->connected = CON_READ_MOTD;
comm.c:        if ( ch->pcdata == NULL || ch->pcdata->pwd[0] == '\0')
comm.c:	ch->next	= char_list;
comm.c:	d->connected	= CON_PLAYING;
comm.c:	free_pstring(ch->pcdata->logon_time);
comm.c:	ch->pcdata->logon_time = palloc_string(ctime( &current_time ));
comm.c:	ch->pcdata->logon_time[strlen(ch->pcdata->logon_time)-1] = '\0';
comm.c:	if ( ch->level == 0 )
comm.c:		/* Let's set up the basic auto-actions players usually set on logging in */
comm.c:		SET_BIT(ch->act,PLR_AUTOASSIST);
comm.c:		SET_BIT(ch->act,PLR_AUTOEXIT);
comm.c:		SET_BIT(ch->act,PLR_AUTOGOLD);
comm.c:		SET_BIT(ch->act,PLR_COLOR);
comm.c:		SET_BIT(ch->act,PLR_AUTOABORT);
comm.c:		SET_BIT(ch->comm,COMM_ANSI);
comm.c:		send_to_char("Type 'auto' to see a list of all auto-actions that may be set.\n\r",ch);
comm.c:        ch->level           = START_LEVEL;
comm.c:        ch->exp             = (ch->level-1) * exp_per_level(ch);
comm.c:        ch->max_hit         = (ch->Class()->gainconst + 2) * 8; 
comm.c:        ch->hit             = ch->max_hit;
comm.c:        ch->pcdata->perm_hit= ch->max_hit;
comm.c:        ch->max_mana        = UMAX(ch->perm_stat[STAT_INT]-10,11) * 15;
comm.c:        ch->pcdata->perm_mana=ch->max_mana;
comm.c:        ch->max_move        = (sh_int)((ch->perm_stat[STAT_DEX] + ch->perm_stat[STAT_CON]) * 7.5);
comm.c:        ch->mana            = ch->max_mana;
comm.c:        ch->move            = ch->max_move;
comm.c:		if(ch->perm_stat[STAT_WIS] / 3 < 5)
comm.c:			ch->practice = 5;
comm.c:			ch->practice 		= ch->perm_stat[STAT_WIS] / 3;
comm.c:		ch->true_name = palloc_string(ch->name);
comm.c:		ch->pcdata->special	= 0;
comm.c:		ch->ghost			= 0;
comm.c:		ch->pcdata->shifted = -1;
comm.c:	    ch->pcdata->energy_state= 0;
comm.c:		ch->pcdata->condition[COND_THIRST] = 1;
comm.c:		ch->pcdata->condition[COND_HUNGER] = 1;
comm.c:	    ch->pcdata->roll_time	= current_time;
comm.c:	    ch->pcdata->birth_date	= time_info.year;
comm.c:	    ch->pcdata->death_time	= 400 + pc_race_table[ch->race].death_modifier * 25 + number_range(-35, 50);
comm.c:	    ch->pcdata->style		= 0;
comm.c:		ch->position = POS_STANDING;
comm.c:		zero_vector(ch->pcdata->styles);
comm.c:		zero_vector(ch->pcdata->ele_sphere);
comm.c:		ch->pcdata->tribe		= 0;
comm.c:				ch->true_name, ch->logon, ch->level,
comm.c:				ch->Class()->GetIndex(), ch->race, ch->cabal, ch->sex, (int)(ch->played + current_time - ch->logon) / 3600,
comm.c:				ch->alignment, ch->pcdata->ethos);
comm.c:		title_table [ch->Class()->GetIndex()] [ch->level]
comm.c:		[ch->sex == SEX_FEMALE ? 1 : 0] );
comm.c:	          ch->pcdata->deposited_items[i] = 0;
comm.c:	    if(ch->Class()->GetIndex() == CLASS_ANTI_PALADIN)
comm.c:		ch->pcdata->learned[skill_lookup("steal")] = -2;
comm.c:		if(!str_cmp(race_table[ch->race].name,"minotaur"))
comm.c:			ch->pcdata->learned[skill_lookup("gore")] = 70;
comm.c:			ch->pcdata->learned[skill_lookup("headbutt")] = 70;
comm.c:		else if(!str_cmp(race_table[ch->race].name,"elf") || !str_cmp(race_table[ch->race].name,"drow"))
comm.c:			ch->pcdata->learned[skill_lookup("silent movement")] = 70;
comm.c:		ch->gold = 500;
comm.c:	else if ( ch->in_room != NULL )
comm.c:	    char_to_room( ch, ch->in_room );
comm.c:	ch->pcdata->host = palloc_string(ch->desc->host);
comm.c:	if(ch->Class()->GetIndex() == CLASS_HEALER)
comm.c:    race = ch->race;
comm.c:	ch->pcdata->condition[COND_DEHYDRATED] = dh;
comm.c:	obj_next = obj->next;
comm.c:	if (obj->carried_by == ch)
comm.c:		else if (obj->pIndexData->limtotal != 0 && ch->level < 10)
comm.c:	ch->pcdata->old_room=0;
comm.c:	sprintf(buf,"$N (%s) has left real life behind.",(ch->cabal>0) ? capitalize(cabal_table[ch->cabal].name) : "Uncaballed");
comm.c:		if(IS_SET(ch->act, PLR_CODER))
comm.c:	sprintf(buf,"players SET logins=logins+1, lastlogin=%d", (int)ch->logon);
comm.c:	if(ch->cabal>0)
comm.c:		if(cabal_down_new(ch,ch->cabal,FALSE))
comm.c:	sprintf(buffile,"%s WHERE name = '%s'",buf,ch->true_name);
comm.c:	if (ch->pet != NULL)
comm.c:	    char_to_room(ch->pet,ch->in_room);
comm.c:	    act("$n awakens into the world of Shalar.",ch->pet,NULL,NULL,TO_ROOM);
comm.c:        if (ch->cabal != 0)
comm.c:	if(ch->Class()->GetIndex() == CLASS_ZEALOT ||
comm.c:			ch->Class()->GetIndex() == CLASS_HEALER ||
comm.c:			ch->Class()->GetIndex() == CLASS_PALADIN) {
comm.c:		SET_BIT(ch->act, PLR_EMPOWERED);
comm.c:	bounty common anti-paladin sorcerer warrior thief paladin zealot healer
comm.c:	    if ( isupper(*pc)) /* ugly anti-caps hack */
comm.c:		  pMobIndex  = pMobIndex->next )
comm.c:		if ( is_name( name, pMobIndex->player_name ) )
comm.c: * Look for link-dead player to reconnect.
comm.c:    for ( ch = char_list; ch != NULL; ch = ch->next )
comm.c:	&&   (!fConn || ch->desc == NULL)
comm.c:	&&   !str_cmp( (d->character->true_name ?
comm.c:		d->character->true_name: d->character->name),
comm.c:		 (ch->true_name?
comm.c:		ch->true_name : ch->name ) ))
comm.c:		free_pstring( d->character->pcdata->pwd );
comm.c:		d->character->pcdata->pwd = palloc_string( ch->pcdata->pwd );
comm.c:			fch_next = fch->next;
comm.c:			    && fch->master == d->character)
comm.c:		free_char( d->character );
comm.c:		d->character = ch;
comm.c:		ch->desc	 = d;
comm.c:		ch->timer	 = 0;
comm.c:		if(ch->invis_level < 51)
comm.c:		ch->pcdata->host = palloc_string(ch->desc->host);
comm.c:	for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
comm.c:	obj->pIndexData->limcount++;
comm.c:		sprintf( log_buf, "%s@%s reconnected.", ch->name, d->host );
comm.c:		d->connected = CON_PLAYING;
comm.c:    for ( dold = descriptor_list; dold; dold = dold->next )
comm.c:	&&   dold->character != NULL
comm.c:	&&   dold->connected != CON_GET_NAME
comm.c:	&&   dold->connected != CON_GET_OLD_PASSWORD
comm.c:	&&   !str_cmp( name, dold->original
comm.c:	         ? dold->original->true_name : dold->character->true_name) )
comm.c:	    d->connected = CON_BREAK_CONNECT;
comm.c:    ||   ch->desc == NULL
comm.c:    ||   ch->desc->connected != CON_PLAYING
comm.c:    ||   ch->was_in_room == NULL
comm.c:    ||   ch->in_room != get_room_index(ROOM_VNUM_LIMBO))
comm.c:    ch->timer = 0;
comm.c:    char_to_room( ch, ch->was_in_room );
comm.c:    ch->was_in_room	= NULL;
comm.c:    if ( txt != NULL && ch->desc != NULL )
comm.c:        write_to_buffer( ch->desc, txt, strlen(txt) );
comm.c:    if ( txt != NULL && ch->desc != NULL )
comm.c:        write_to_buffer( ch->desc, txt, strlen(txt) );
comm.c:    if ( txt == NULL || ch->desc == NULL)
comm.c:    if (ch->lines == 0 )
comm.c:    ch->desc->showstr_head  = new char[strlen(txt) + 1];
comm.c:    strcpy(ch->desc->showstr_head,txt);
comm.c:    ch->desc->showstr_point = ch->desc->showstr_head;
comm.c:    show_string(ch->desc,"");
comm.c:	if (d->showstr_head)
comm.c:	    delete[] d->showstr_head;
comm.c:	    d->showstr_head = 0;
comm.c:    	d->showstr_point  = 0;
comm.c:    if (d->character)
comm.c:	show_lines = d->character->lines;
comm.c:    for (scan = buffer; ; scan++, d->showstr_point++)
comm.c:	if (((*scan = *d->showstr_point) == '\n' || *scan == '\r')
comm.c:	    && (toggle = -toggle) < 0)
comm.c:	    for (chk = d->showstr_point; isspace(*chk); chk++);
comm.c:		    if (d->showstr_head)
comm.c:            		delete[] d->showstr_head;
comm.c:            		d->showstr_head = 0;
comm.c:        	    d->showstr_point  = 0;
comm.c:    if (ch->sex < 0 || ch->sex > 2)
comm.c:    	ch->sex = IS_NPC(ch) ? 0 : ch->pcdata->true_sex;
comm.c:     * Discard null and zero-length messages.
comm.c:	for ( d = descriptor_list; d != NULL; d = d->next )
comm.c:		if ( d->connected == CON_PLAYING
comm.c:			 && d->character
comm.c:			 && d->character->in_room != NULL
comm.c:			 && d->character->in_room->area == ch->in_room->area
comm.c:			 && !IS_SET(d->character->comm,COMM_QUIET))
comm.c:			if (IS_SET(d->character->in_room->room_flags, ROOM_SILENCE))
comm.c:			if(!IS_AWAKE(d->character))
comm.c:			to = d->character;
comm.c:			if ( (!IS_NPC(to) && to->desc == NULL )) 
comm.c:                		case 'e': i = he_she  [URANGE(0, victim->sex, 2)];        break;
comm.c:                		case 'm': i = him_her [URANGE(0, victim->sex, 2)];        break;
comm.c:                		case 's': i = his_her [URANGE(0, victim->sex, 2)];        break;
comm.c:			if ( to->desc != NULL )
comm.c:				sprintf(buf2,"%s yells '%s", ch->short_descr, get_char_color(to, "yells"));
comm.c:            	write_to_buffer( to->desc, buf, point - buf );
comm.c:     * Discard null and zero-length messages.
comm.c:    if (ch == NULL || ch->in_room == NULL)
comm.c:    to = ch->in_room->people;
comm.c:			sprintf(buf,"Act: null vch with TO_VICT. -- %s", format);
comm.c:		if (vch->in_room == NULL)
comm.c:        to = vch->in_room->people;
comm.c:    for ( ; to != NULL; to = to->next_in_room )
comm.c:        if ( (!IS_NPC(to) && to->desc == NULL )
comm.c:        ||    to->position < min_pos )
comm.c:			i = (ch->true_name ? ch->true_name:ch->name);
comm.c:			i = (vch->true_name ? vch->true_name:vch->name);
comm.c:            case 'e': i = he_she  [URANGE(0, ch  ->sex, 2)];        break;
comm.c:            case 'E': i = he_she  [URANGE(0, vch ->sex, 2)];        break;
comm.c:            case 'm': i = him_her [URANGE(0, ch  ->sex, 2)];        break;
comm.c:            case 'M': i = him_her [URANGE(0, vch ->sex, 2)];        break;
comm.c:            case 's': i = his_her [URANGE(0, ch  ->sex, 2)];        break;
comm.c:            case 'S': i = his_her [URANGE(0, vch ->sex, 2)];        break;
comm.c:                            ? obj1->short_descr
comm.c:		    //obj article truncation: back up 2-don't truncate the/a from obj short descr unless it's preceded by Your or 's
comm.c:		    if(((str - format) >= 4 && *(str - 4) == '\'' && *(str - 3) == 's')
comm.c:			|| ((str - format) >= 6 && *(str - 5) == 'o' && *(str - 4) == 'u' && *(str - 3) == 'r'))
comm.c:                            ? obj2->short_descr
comm.c:        if ( to->desc != NULL )
comm.c:            write_to_buffer( to->desc, buf, point - buf );
comm.c:        if (ch->cabal == 0 || ch->cabal > MAX_CABAL || IS_IMMORTAL(ch))
comm.c:	guardian = get_cabal_guardian(ch->cabal);
comm.c:	rstring = talloc_string(cabal_messages[ch->cabal].login);
comm.c:	sprintf(buf,rstring,ch->name);
comm.c:        if (ch->cabal == 0 || ch->cabal > MAX_CABAL || IS_IMMORTAL(ch))
comm.c:        guardian = get_cabal_guardian(ch->cabal);
comm.c:        rstring = talloc_string(cabal_messages[ch->cabal].logout);
comm.c:        sprintf(buf,rstring,ch->name);
comm.c:	if (!victim->desc || (victim->desc->connected != CON_PLAYING) )
comm.c:		send_to_char("They are link-dead.\n\r",ch);
comm.c:	cres = RS.SQL.Update("players SET name = '%s' WHERE name = '%s' LIMIT 1", capitalize(new_name), victim->true_name);
comm.c:	cname	= palloc_string(victim->true_name);
comm.c:	free_pstring(victim->name);
comm.c:	free_pstring(victim->true_name);
comm.c:	free_pstring(victim->backup_true_name);
comm.c:	victim->name = palloc_string(capitalize(new_name));
comm.c:	victim->true_name = palloc_string(capitalize(new_name));
comm.c:	victim->backup_true_name = palloc_string(capitalize(new_name));
comm.c:    if( IS_NPC( ch ) && !IS_SET(ch->act,ACT_WARD_MOB))
comm.c:	if( IS_SET( ch->act, PLR_COLOR ) || IS_NPC(ch))
comm.c:		    while( skip-- > 0 )
comm.c:		allocate+=(pc_race_table[ch->race].max_stats[i]-13);
comm.c:	if(!strcmp(pc_race_table[ch->race].name,"human"))
comm.c:                write_to_buffer(ch->desc,"Type '<str/int/wis/dex/con> <amount>' to modify a particular stat.\n\r",0);
comm.c:                write_to_buffer(ch->desc,"The default amount is 1, use negative numbers to deallocate points.\n\r",0);
comm.c:                write_to_buffer(ch->desc,"Type 'finish' when you're done.\n\r",0);
comm.c:		write_to_buffer(ch->desc,"\n\rTime to allocate points to your stats.\n\r",0);
comm.c:	sprintf(buf, "You have %d points to allocate.\n\r",ch->train);
comm.c:	write_to_buffer(ch->desc, buf, 0);
comm.c:	ch->perm_stat[STAT_STR], pc_race_table[ch->race].max_stats[STAT_STR],
comm.c:	ch->perm_stat[STAT_INT], pc_race_table[ch->race].max_stats[STAT_INT],
comm.c:	ch->perm_stat[STAT_WIS], pc_race_table[ch->race].max_stats[STAT_WIS],
comm.c:	ch->perm_stat[STAT_DEX], pc_race_table[ch->race].max_stats[STAT_DEX],
comm.c:	ch->perm_stat[STAT_CON], pc_race_table[ch->race].max_stats[STAT_CON]);
comm.c:	write_to_buffer(ch->desc,"> ", 0);
comm.c:		ch->pcdata->entering_text = FALSE;
comm.c:		ch->pcdata->entered_text[0] = '\0';
comm.c:		ch->pcdata->end_fun = NULL;
comm.c:		if(ch->pcdata->end_fun)
comm.c:			(*ch->pcdata->end_fun) (ch, ch->pcdata->entered_text);
comm.c:		ch->pcdata->entering_text = FALSE;
comm.c:		ch->pcdata->end_fun = NULL;
comm.c:                if (ch->pcdata->entered_text == NULL || ch->pcdata->entered_text[0] == '\0')
comm.c:                strcpy(obuf,ch->pcdata->entered_text);
comm.c:                for (len = strlen(obuf); len > 0; len--)
comm.c:                                                len--;
comm.c:                                        free_pstring(ch->pcdata->entered_text);
comm.c:                                        ch->pcdata->entered_text = palloc_string(obuf);
comm.c:                free_pstring(ch->pcdata->entered_text);
comm.c:                ch->pcdata->entered_text = palloc_string(obuf);
comm.c:		return send_to_char(ch->pcdata->entered_text,ch);
comm.c:		return send_to_char(ch->pcdata->entered_text,ch);
comm.c:				for(rcount = 80 * i; rcount > (80 * i) - 15; rcount--)
comm.c:				if(rcount <= (80 * i) - 15)
comm.c:					rbuf[iloc - rcount] = tbuf[iloc + 1];
comm.c:				rbuf[iloc - rcount] = '\0';
comm.c:		if (ch->pcdata->entered_text)
comm.c:	    	strcat(obuf,ch->pcdata->entered_text);
comm.c:        free_pstring(ch->pcdata->entered_text);
comm.c:        ch->pcdata->entered_text = palloc_string(obuf);
const.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
const.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
const.c:/* attack table  -- not very organized :( */
const.c:    { 	"none",			"hit",				-1,				0 	},  /*  0 */
const.c:    {   "grep",			"grep",				DAM_SLASH,		-10 },
const.c:    {   "suction",		"suction",			DAM_BASH,		-20	},
const.c:    { 	"infinite", 	"infinite darkness",DAM_NEGATIVE,	-30	},	/* 45 */
const.c:	"",			"You feel more self-confident.",	"", CMD_SPELL
const.c:	"","Your awe-inspiring aura fades away.","$n seems less powerful.", CMD_COMMUNE
const.c:/* non-combat skills */
const.c:        "", "The guild will put you in touch with a new mercenary-for-hire.",    "", CMD_POWER
const.c:        "crippling blow", "Your once-mangled arm feels stronger, despite a lingering stiffness.",	"",   CMD_NONE
const.c:		"anti-paladin",	
db.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
db.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
db.c:sh_int gsn_hold_person; /* Hold person -Detlef */
db.c:sh_int gsn_confuse; /* Confuse for Outlaw -Detlef */
db.c:sh_int gsn_deafen; /* Deafen for AP -Detlef */
db.c:sh_int gsn_divine_intervention; /* Divine intervention - Dioxide */
db.c:sh_int gsn_creep; /* creep skill - Dioxide */	
db.c:sh_int gsn_pincer;  /* Quest pincer -- Graelik */
db.c:sh_int gsn_devour; /* Quest devour -- Dioxide */
db.c:sh_int gsn_keen_vision; /* Eagle eyes -- Dioxide */
db.c:    16, 32, 64, 128, 256, 1024, 2048, 4096, 8192, 16384, 32768-64
db.c:			i--;
db.c: * Semi-locals.
db.c:	lhour		= (current_time - 650336715)
db.c:	time_info.hour = ((current_time - RS_EPOCH) % (60 * 24)) / (60);
db.c:	time_info.day = ((current_time - RS_EPOCH) % (60 * 60 * 12)) / (60 * 24);
db.c:	time_info.month = ((current_time - RS_EPOCH) % (60 * 60 * 24 * 6)) / (60 * 60 * 12);
db.c:	time_info.year	= 1515 + (current_time - RS_EPOCH) / (60 * 60 * 24 * 6);
db.c:	berus_pos = ((current_time-RS_EPOCH)%(BERUS_SPD*360))/BERUS_SPD;
db.c:	calabren_pos = ((current_time-RS_EPOCH)%(CALABREN_SPD*360))/CALABREN_SPD;
db.c:	    if ( strArea[0] == '-' )
db.c:named Zzz.plr in the /player directory as an end-of-pfile's signature.
db.c:-Ceran
db.c:						pObjIndex->limcount++;
db.c:/*  pArea->reset_first	= NULL;
db.c:    pArea->reset_last	= NULL; */
db.c:    pArea->file_name	= fread_string(fp);
db.c:	pArea->prev			= NULL;
db.c:	zero_vector(pArea->area_flags);
db.c:	SET_BIT(pArea->area_flags, AREA_LOADING);	/* OLC */
db.c:    pArea->vnum         = top_area;             /* OLC */
db.c:	pArea->affected		= NULL;
db.c:    pArea->name		= fread_string( fp );
db.c:	pArea->credits	= fread_string( fp );
db.c:	pArea->low_range = fread_number(fp);
db.c:    pArea->high_range = fread_number(fp);
db.c:	pArea->min_vnum	= fread_number(fp);
db.c:    pArea->max_vnum	= fread_number(fp);
db.c:    pArea->area_type	= flag_lookup(fread_word(fp),area_type_table);
db.c:	pArea->climate		= climate_lookup(fread_word(fp));
db.c:    fread_flag_new(pArea->area_flags,fp);
db.c:	pArea->security = fread_number(fp);
db.c:	pArea->builders	= fread_string( fp );
db.c:	pArea->age		= 15;
db.c:    pArea->nplayer	= 0;
db.c:    pArea->empty	= FALSE;
db.c:	pArea->nplayer = 0;
db.c:    zero_vector(pArea->affected_by);
db.c:	/* Morg - Valgrind fix. */
db.c:	zero_vector(pArea->progtypes);
db.c:	pArea->aprogs = NULL;
db.c:	pArea->temp	= 0;
db.c:	pArea->sky = 0;	
db.c:		area_last->next = pArea;
db.c:		pArea->prev = area_last;
db.c:        REMOVE_BIT(area_last->area_flags, AREA_LOADING);        /* OLC */
db.c:    pArea->next	= NULL;
db.c:		for(pArea = area_first; pArea; pArea = pArea->next) {
db.c:			if (!pArea->next)
db.c:			if (pArea->min_vnum > pArea->next->min_vnum) {
db.c:				if (pArea->next->next)
db.c:					pArea->next->next->prev = pArea;
db.c:				pArea->next->prev = pArea->prev;
db.c:					pArea->prev->next = pArea->next;
db.c:				pArea->prev = pArea->next;
db.c:				placeholder = pArea->next->next;
db.c:				pArea->next->next = pArea;
db.c:				pArea->next = placeholder;
db.c:					area_first = pArea->prev;
db.c:	for (pArea = area_first; pArea; pArea = pArea->next) {
db.c:		pArea->vnum = vnum;
db.c:    pArea->age          = 15;
db.c:    pArea->nplayer      = 0;
db.c:    pArea->file_name     = palloc_string( strArea );
db.c:    pArea->vnum         = top_area;
db.c:    pArea->name         = palloc_string( "New Area" );
db.c:    pArea->builders     = palloc_string( "" );
db.c:	pArea->security		= 1;
db.c:	pArea->min_vnum        = 0;
db.c:    pArea->max_vnum        = 0;
db.c:	pArea->nplayer		= 0;
db.c:    zero_vector(pArea->area_flags);
db.c:/*  pArea->recall       = ROOM_VNUM_TEMPLE;        ROM OLC */
db.c:            SKEY( "Name", pArea->name );
db.c:             KEY( "Security", pArea->security, fread_number( fp ) );
db.c:                pArea->min_vnum = fread_number( fp );
db.c:                pArea->max_vnum = fread_number( fp );
db.c:    area_last->next = pArea;
db.c: pArea->next = NULL;
db.c:            SKEY( "Builders", pArea->builders );
db.c:	    SKEY( "Credits", pArea->credits );
db.c:    if ( area_last->min_vnum == 0 || area_last->max_vnum == 0 )
db.c:        area_last->min_vnum = area_last->max_vnum = vnum;
db.c:    if ( vnum != URANGE( area_last->min_vnum, vnum, area_last->max_vnum ) )
db.c:		if ( vnum < area_last->min_vnum )
db.c:            area_last->min_vnum = vnum;
db.c:			area_last->max_vnum = vnum;
db.c:    pr = pR->reset_last;
db.c:        pR->reset_first = pReset;
db.c:        pR->reset_last  = pReset;
db.c:        pR->reset_last->next = pReset;
db.c:        pR->reset_last       = pReset;
db.c:        pR->reset_last->next = NULL;
db.c:	pReset->command	= letter;
db.c:	pReset->arg1	= fread_number( fp );
db.c:	pReset->arg2	= fread_number( fp );
db.c:	pReset->arg3	= (letter == 'G' || letter == 'R')
db.c:	pReset->arg4	= (letter == 'P' || letter == 'M')
db.c:/*	pReset->arg4	= (letter == 'P' || letter == 'M')
db.c:	    get_mob_index  ( pReset->arg1 );
db.c:/*	    get_room_index ( pReset->arg3 ); */
db.c:            if ( ( pRoomIndex = get_room_index ( pReset->arg3 ) ) )
db.c:                iLastRoom = pReset->arg3;
db.c:/*	    temp_index = get_obj_index  ( pReset->arg1 );
db.c:	    temp_index->reset_num++;
db.c:	    get_room_index ( pReset->arg3 ); */
db.c:	    get_obj_index ( pReset->arg1 );
db.c:            if ( ( pRoomIndex = get_room_index ( pReset->arg3 ) ) )
db.c:                iLastObj = pReset->arg3;
db.c:/*	    temp_index = get_obj_index  ( pReset->arg1 );
db.c:	    temp_index->reset_num++;
db.c:	    get_obj_index  ( pReset->arg3 ); */
db.c:	    get_obj_index  ( pReset->arg1 );
db.c:/*	    temp_index = get_obj_index  ( pReset->arg1 );
db.c:	    temp_index->reset_num++; */
db.c:	    get_obj_index (pReset->arg1);
db.c:	    pRoomIndex = get_room_index( pReset->arg1 );
db.c:	    if ( pReset->arg2 < 0
db.c:	    ||   pReset->arg2 > 5
db.c:	    || !( pexit = pRoomIndex->exit[pReset->arg2] )
db.c:	    || !IS_SET( pexit->exit_info, EX_ISDOOR ) )
db.c:		bug( "Load_resets: 'D': exit %d not door.", pReset->arg2 );
db.c:/*	    if ( pReset->arg3 < 0 || pReset->arg3 > 2 )
db.c:		bug( "Load_resets: 'D': bad 'locks': %d.", pReset->arg3 );
db.c:            switch ( pReset->arg3 )
db.c:					bug( "Load_resets: 'D': bad 'locks': %d." , pReset->arg3);
db.c:						SET_BIT( pexit->exit_info, EX_CLOSED );
db.c:                	SET_BIT( pexit->exit_info, EX_CLOSED);
db.c:					SET_BIT( pexit->exit_info, EX_LOCKED );
db.c:	    pRoomIndex		= get_room_index( pReset->arg1 );
db.c:	    if ( pReset->arg2 < 0 || pReset->arg2 > 6 )
db.c:		bug( "Load_resets: 'R': bad exit %d.", pReset->arg2 );
db.c:/*	if ( area_last->reset_first == NULL )
db.c:	    area_last->reset_first	= pReset;
db.c:	if ( area_last->reset_last  != NULL )
db.c:	    area_last->reset_last->next	= pReset;
db.c:	area_last->reset_last	= pReset;*/
db.c:	pReset->next		= NULL;
db.c:	pShop->keeper		= fread_number( fp );
db.c:	if ( pShop->keeper == 0 )
db.c:	    pShop->buy_type[iTrade]	= fread_number( fp );
db.c:	pShop->profit_buy	= fread_number( fp );
db.c:	pShop->profit_sell	= fread_number( fp );
db.c:	pShop->open_hour	= fread_number( fp );
db.c:	pShop->close_hour	= fread_number( fp );
db.c:	pMobIndex		= get_mob_index( pShop->keeper );
db.c:	pMobIndex->pShop	= pShop;
db.c:	    shop_last->next = pShop;
db.c:	pShop->next	= NULL;
db.c:	while((inum = fread_number(fp)) != -1)
db.c:			for(mob = char_list; mob; mob = mob->next)
db.c:				if(mob->cabal == inum && IS_CABAL_GUARD(mob))
db.c:		for(mob = char_list; mob; mob = mob->next)
db.c:			if(mob->pIndexData->vnum == vnum)
db.c:	      pRoomIndex  = pRoomIndex->next )
db.c:		if ( ( pexit = pRoomIndex->exit[door] ) != NULL )
db.c:		    if ( pexit->u1.vnum <= 0
db.c:		    || get_room_index(pexit->u1.vnum) == NULL)
db.c:			pexit->u1.to_room = NULL;
db.c:			pexit->u1.to_room = get_room_index( pexit->u1.vnum );
db.c:			if(IS_SET(pexit->exit_info, EX_CLOSED) && !IS_SET(pexit->exit_info, EX_ISDOOR))
db.c:				SET_BIT(pexit->exit_info, EX_ISDOOR);
db.c:		SET_BIT(pRoomIndex->room_flags,ROOM_NO_MOB);
db.c:	      pRoomIndex  = pRoomIndex->next )
db.c:		if ( ( pexit     = pRoomIndex->exit[door]       ) != NULL
db.c:		&&   ( to_room   = pexit->u1.to_room            ) != NULL
db.c:		&&   ( pexit_rev = to_room->exit[rev_dir[door]] ) != NULL
db.c:		&&   pexit_rev->u1.to_room != pRoomIndex
db.c:		&&   (pRoomIndex->vnum < 1200 || pRoomIndex->vnum > 1299))
db.c:		    sprintf( buf, "Fix_exits: %d:%d -> %d:%d -> %d.",
db.c:			pRoomIndex->vnum, door,
db.c:			to_room->vnum,    rev_dir[door],
db.c:			(pexit_rev->u1.to_room == NULL)
db.c:			    ? 0 : pexit_rev->u1.to_room->vnum );
db.c:	for (area = area_first; area; area = area->next)
db.c:			area->adjacent[i] = NULL;
db.c:		for (room = room_list; room != NULL; room = room->next_room)
db.c:			if (room->area != area)
db.c:				if ((pexit = room->exit[dir]) != NULL)
db.c:					if ((to_room = pexit->u1.to_room) != NULL)
db.c:						if (to_room->area != area)
db.c:								if (area->adjacent[i] == to_room->area)
db.c:								area->adjacent[count] = to_room->area;
db.c:    for ( pArea = area_first; pArea != NULL; pArea = pArea->next ){
db.c:		if (IS_SET(pArea->progtypes, APROG_TICK))
db.c:			(pArea->aprogs->tick_prog) (pArea);
db.c:		for (paf = pArea->affected; paf; paf = paf_next) {
db.c:			paf_next = paf->next;
db.c:			if (paf->duration > 0 ) {
db.c:				if (paf->tick_fun)
db.c:					(*paf->tick_fun) (pArea,paf);
db.c:				paf->duration--;
db.c:			} else if (paf->duration < 0)
db.c:		if (pArea->nplayer == 0)  {
db.c:			pArea->empty = TRUE;
db.c:			pArea->empty = FALSE;
db.c:		if ( ++pArea->age < 6 )
db.c:		if ( (pArea->empty || pArea->age >= 30)) {
db.c:			if (IS_SET(pArea->progtypes, APROG_RESET))
db.c:				(pArea->aprogs->reset_prog) (pArea);
db.c:	   		sprintf(buf,"%s has just been reset.",pArea->name);
db.c:	    	pArea->age = number_range( 0, 2 );
db.c:	if (pRoom->trap)
db.c:		pRoom->trap->armed = TRUE;
db.c:	for ( pReset = pRoom->reset_first; pReset != NULL; pReset = pReset->next )
db.c:		switch ( pReset->command )
db.c:	    		bug( "Reset_area: bad command %c.", pReset->command );
db.c:	    		if ( ( pMobIndex = get_mob_index( pReset->arg1 ) ) == NULL )
db.c:					bug( "Reset_area: 'M': bad vnum %d.", pReset->arg1 );
db.c:	    		if ( ( pRoomIndex = get_room_index( pReset->arg3 ) ) == NULL )
db.c:					bug( "Reset_area: 'R': bad vnum %d.", pReset->arg3 );
db.c:	    		if ( pMobIndex->count >= pReset->arg2 )
db.c:	    		for (mob = pRoomIndex->people; mob != NULL; mob = mob->next_in_room)
db.c:					if (mob->pIndexData == pMobIndex)
db.c:		    			if (count >= pReset->arg4)
db.c:	    		if (count >= pReset->arg4)
db.c:					SET_BIT(pMob->affected_by, AFF_INFRARED);
db.c:					pRoomIndexPrev = get_room_index( pRoom->vnum - 1 );
db.c:     				&& IS_SET( pRoomIndexPrev->room_flags, ROOM_PET_SHOP ) )
db.c:     				SET_BIT( pMob->act, ACT_PET);
db.c:				pMob->zone = pRoomIndex->area;
db.c:				level  = URANGE( 0, pMob->level - 2, LEVEL_HERO - 1 ); /* -1 ROM */
db.c:				if ( !( pObjIndex = get_obj_index( pReset->arg1 ) ) )
db.c:					bug( "Reset_room: 'O' 1 : bad vnum %d", pReset->arg1 );
db.c:					sprintf (buf,"%d %d %d %d",pReset->arg1, pReset->arg2, pReset->arg3, pReset->arg4 );
db.c:				if ( !( pRoomIndex = get_room_index( pReset->arg3 ) ) )
db.c:					bug( "Reset_room: 'O' 2 : bad vnum %d.", pReset->arg3 );
db.c:					sprintf (buf,"%d %d %d %d",pReset->arg1, pReset->arg2, pReset->arg3, pReset->arg4 );
db.c:				for(pObj2 = pRoomIndex->contents; pObj2; pObj2 = pObj2->next_content)
db.c:					if(pObj2->pIndexData->vnum == pObjIndex->vnum && 
db.c:					   pObj2->item_type == ITEM_CONTAINER && !pObj2->contains)
db.c:				if ((pObjIndex->limcount >= pObjIndex->limtotal                                                   
db.c:					 && pObjIndex->limtotal > 0) 
db.c:					 || count_obj_list( pObjIndex, pRoomIndex->contents ) > 0 )
db.c:				pObj = create_object( pObjIndex, UMIN(number_fuzzy( level ), LEVEL_HERO -1) );
db.c:				pObj->cost = 0;
db.c:				pObj->owner = palloc_string("none");
db.c:				pObj->talked = palloc_string("someone a long long time ago");
db.c:				if ( !( pObjIndex = get_obj_index( pReset->arg1 ) ) )
db.c:					bug( "Reset_room: 'P': bad vnum %d.", pReset->arg1 );
db.c:				if ( !( pObjToIndex = get_obj_index( pReset->arg3 ) ) )
db.c:					bug( "Reset_room: 'P': bad vnum %d.", pReset->arg3 );
db.c:				if (pReset->arg2 > 50)
db.c:				else if (pReset->arg2 == -1)
db.c:					limit = pReset->arg2;
db.c:				if ( pRoom->area->nplayer > 1
db.c:     				|| ( LastObj->in_room == NULL && !last)
db.c:				|| ( pObjIndex->limtotal > 0 && pObjIndex->limcount >= pObjIndex->limtotal )
db.c:     				|| ( pObjIndex->count >= limit /* && number_range(0,4) != 0 */ )
db.c:      				|| ( count = count_obj_list( pObjIndex, LastObj->contains ) ) > pReset->arg4  )
db.c:				while (count < pReset->arg4) {
db.c:					pObj = create_object( pObjIndex, number_fuzzy( LastObj->level ) );
db.c:					pObj->owner = palloc_string("none");
db.c:					if (pObjIndex->limcount >= pObjIndex->limtotal && pObjIndex->limtotal > 0)
db.c:				LastObj->value[1] = LastObj->pIndexData->value[1];
db.c:				if ( !( pObjIndex = get_obj_index( pReset->arg1 ) ) )
db.c:					bug( "Reset_room: 'E' or 'G': bad vnum %d.", pReset->arg1 );
db.c:					bug( "Reset_room: 'E' or 'G': null mob for vnum %d.", pReset->arg1 );
db.c:				if ( LastMob->pIndexData->pShop )
db.c:					if (!pObjIndex->new_format)
db.c:						switch ( pObjIndex->item_type )
db.c:									if (pObjIndex->value[i] > 0)
db.c:				         							skill_table[pObjIndex->value[i]].
db.c:								olevel = UMAX(0,(olevel * 3 / 4) - 2);
db.c:					pObj->owner = palloc_string("none");
db.c:					if (pObj->pIndexData->limtotal == 0)
db.c:						SET_BIT( pObj->extra_flags, ITEM_INVENTORY );
db.c:					if (pReset->arg2 > 50 )  /* old format */
db.c:					else if ( pReset->arg2 == -1 || pReset->arg2 == 0 )  /* no limit */
db.c:						limit = pReset->arg2;
db.c:					if (pObjIndex->limcount >= pObjIndex->limtotal && pObjIndex->limtotal > 0)
db.c:			            pObj=create_object(pObjIndex,UMIN(number_fuzzy(level), LEVEL_HERO - 1));
db.c:					pObj->owner = palloc_string("none");
db.c:				if ( pReset->command == 'E' )
db.c:					if (pReset->arg3 == 16)
db.c:							equip_char( LastMob, pObj, pReset->arg3, TRUE);       					}
db.c:					else if  ( pReset->arg3 == 18)
db.c:							equip_char(LastMob,pObj,pReset->arg3, TRUE);
db.c:						equip_char( LastMob, pObj, pReset->arg3, TRUE);
db.c:				for (rch = LastMob->in_room->people; rch != NULL; rch = rch->next_in_room)
db.c:					if (IS_NPC(rch) && (pReset->arg2 == rch->pIndexData->vnum))
db.c:				LastMob->leader = rch;
db.c:				if ( ( pRoomIndex = get_room_index( pReset->arg1 ) ) == NULL )                                            
db.c:					bug( "Reset_area: 'D': bad vnum %d.", pReset->arg1 );                                                     
db.c:				if ( ( pexit = pRoomIndex->exit[pReset->arg2] ) == NULL )                                                 
db.c:				SET_BIT( pexit->exit_info, EX_ISDOOR );                                                                   
db.c:				switch ( pReset->arg3 )                                                                                   
db.c:						REMOVE_BIT( pexit->exit_info, EX_CLOSED );                                                                
db.c:						REMOVE_BIT( pexit->exit_info, EX_LOCKED );                                                                
db.c:						SET_BIT(    pexit->exit_info, EX_CLOSED );                                                                
db.c:						REMOVE_BIT( pexit->exit_info, EX_LOCKED );                                                                
db.c:						SET_BIT(    pexit->exit_info, EX_CLOSED );                                                                
db.c:						SET_BIT(    pexit->exit_info, EX_LOCKED );                                                                
db.c:if ( !( pRoomIndex = get_room_index( pReset->arg1 ) ) )
db.c:bug( "Reset_room: 'R': bad vnum %d.", pReset->arg1 );
db.c:for ( d0 = 0; d0 < pReset->arg2 - 1; d0++ )
db.c:d1   = number_range( d0, pReset->arg2-1 );
db.c:pExit                = pRoomIndex->exit[d0];
db.c:pRoomIndex->exit[d0] = pRoomIndex->exit[d1];
db.c:pRoomIndex->exit[d1] = pExit;
db.c:	for ( vnum = pArea->min_vnum; vnum <= pArea->max_vnum; vnum++ )
db.c:    mob->pIndexData	= pMobIndex;
db.c:    mob->name		= palloc_string( pMobIndex->player_name );    /* OLC */
db.c:    mob->short_descr	= palloc_string( pMobIndex->short_descr );    /* OLC */
db.c:    mob->long_descr	= palloc_string( pMobIndex->long_descr );     /* OLC */
db.c:	if(pMobIndex->description)
db.c:    mob->description	= palloc_string( pMobIndex->description );    /* OLC */
db.c:    mob->id		= get_mob_id();
db.c:    mob->prompt		= NULL;
db.c:    copy_vector(mob->progtypes, pMobIndex->progtypes);
db.c:	total_wealth += pMobIndex->wealth;
db.c:    if (pMobIndex->new_format)
db.c: 	mob->group		= pMobIndex->group;
db.c:	copy_vector(mob->act, pMobIndex->act);
db.c:	copy_vector(mob->affected_by, pMobIndex->affected_by);
db.c:	mob->alignment		= pMobIndex->alignment;
db.c:	mob->level		= pMobIndex->level;
db.c:	mob->hitroll		= pMobIndex->hitroll;
db.c:	mob->damroll		= pMobIndex->damage[DICE_BONUS];
db.c:	mob->max_hit		= dice(pMobIndex->hit[DICE_NUMBER],
db.c:				       pMobIndex->hit[DICE_TYPE])
db.c:				  + pMobIndex->hit[DICE_BONUS];
db.c:	mob->hit		= mob->max_hit;
db.c:	mob->max_mana		= dice(pMobIndex->mana[DICE_NUMBER],
db.c:				       pMobIndex->mana[DICE_TYPE])
db.c:				  + pMobIndex->mana[DICE_BONUS];
db.c:	mob->mana		= mob->max_mana;
db.c:	mob->damage[DICE_NUMBER]= pMobIndex->damage[DICE_NUMBER];
db.c:	mob->damage[DICE_TYPE]	= pMobIndex->damage[DICE_TYPE];
db.c:	mob->dam_type		= pMobIndex->dam_type;
db.c:        if (mob->dam_type == 0)
db.c:                case (1): mob->dam_type = 3;        break;  /* slash */
db.c:                case (2): mob->dam_type = 7;        break;  /* pound */
db.c:                case (3): mob->dam_type = 11;       break;  /* pierce */
db.c:	    mob->armor[i]	= pMobIndex->ac[i];
db.c:	copy_vector(mob->off_flags, pMobIndex->off_flags);
db.c:	copy_vector(mob->imm_flags, pMobIndex->imm_flags);
db.c:	copy_vector(mob->res_flags, pMobIndex->res_flags);
db.c:	copy_vector(mob->vuln_flags, pMobIndex->vuln_flags);
db.c:	mob->start_pos		= pMobIndex->start_pos;
db.c:	mob->sex		= pMobIndex->sex;
db.c:        if (mob->sex == 3) /* random sex */
db.c:            mob->sex = number_range(1,2);
db.c:	mob->race		= pMobIndex->race;
db.c:	copy_vector(mob->form, pMobIndex->form);
db.c:	copy_vector(mob->parts, pMobIndex->parts),
db.c:	mob->size		= pMobIndex->size;
db.c:	copy_vector(mob->progtypes, pMobIndex->progtypes);
db.c:	mob->dam_mod		= pMobIndex->dam_mod;
db.c:	mob->defense_mod	= 0;
db.c:	mob->arms		= pMobIndex->arms;
db.c:	mob->legs		= pMobIndex->legs;
db.c:	mob->regen_rate = 0;
db.c:	mob->mobstyle	=	0;
db.c:	mob->stolen_from	= FALSE;
db.c:	if (pMobIndex->Class()->GetIndex() == CLASS_WARRIOR) {
db.c:			if (IS_SET(pMobIndex->styles,style)) {
db.c:				mob->mobstyle = style;
db.c:	if(IS_SET(mob->act,ACT_WARD_MOB))
db.c:		mob->invis_level = LEVEL_HERO + 1;
db.c:            mob->perm_stat[i] = UMIN(25,11 + mob->level/4);
db.c:        if (mob->pIndexData->Class()->GetIndex() == CLASS_WARRIOR)
db.c:            mob->perm_stat[STAT_STR] += 3;
db.c:            mob->perm_stat[STAT_INT] -= 1;
db.c:            mob->perm_stat[STAT_CON] += 2;
db.c:        if (mob->pIndexData->Class()->GetIndex() == CLASS_THIEF)
db.c:            mob->perm_stat[STAT_DEX] += 3;
db.c:            mob->perm_stat[STAT_INT] += 1;
db.c:            mob->perm_stat[STAT_WIS] -= 1;
db.c:        if (IS_SET(mob->act,ACT_CLERIC))
db.c:            mob->perm_stat[STAT_WIS] += 3;
db.c:            mob->perm_stat[STAT_DEX] -= 1;
db.c:            mob->perm_stat[STAT_STR] += 1;
db.c:        if (IS_SET(mob->act,ACT_MAGE))
db.c:            mob->perm_stat[STAT_INT] += 3;
db.c:            mob->perm_stat[STAT_STR] -= 1;
db.c:            mob->perm_stat[STAT_DEX] += 1;
db.c:        if (IS_SET(mob->off_flags,OFF_FAST))
db.c:            mob->perm_stat[STAT_DEX] += 2;
db.c:        mob->perm_stat[STAT_STR] += mob->size - SIZE_MEDIUM;
db.c:        mob->perm_stat[STAT_CON] += (mob->size - SIZE_MEDIUM) / 2;
db.c:		af.level     = mob->level;
db.c:		af.duration  = -1;
db.c:		if(pMobIndex->affect_sn[i]<0)
db.c:		if(pMobIndex->affect_sn[i]>0)
db.c:			af.type 	= pMobIndex->affect_sn[i];
db.c:			SET_BIT(af.bitvector, pMobIndex->affect_bit[i]);
db.c:	copy_vector(mob->act, pMobIndex->act);
db.c:	copy_vector(mob->affected_by, pMobIndex->affected_by);
db.c:	mob->alignment		= pMobIndex->alignment;
db.c:	mob->level		= pMobIndex->level;
db.c:	mob->hitroll		= pMobIndex->hitroll;
db.c:	mob->damroll		= 0;
db.c:	mob->max_hit		= mob->level * 8 + number_range(
db.c:					mob->level * mob->level/4,
db.c:					mob->level * mob->level);
db.c:	mob->hit		= mob->max_hit;
db.c:	mob->max_mana		= 100 + dice(mob->level,10);
db.c:	mob->mana		= mob->max_mana;
db.c:	    case (1): mob->dam_type = 3; 	break;  /* slash */
db.c:	    case (2): mob->dam_type = 7;	break;  /* pound */
db.c:	    case (3): mob->dam_type = 11;	break;  /* pierce */
db.c:	    mob->armor[i]	= 0;
db.c:	mob->armor[3]		= 0;
db.c:	mob->race		= pMobIndex->race;
db.c:	copy_vector(mob->off_flags, pMobIndex->off_flags);
db.c:	copy_vector(mob->imm_flags, pMobIndex->imm_flags);
db.c:	copy_vector(mob->res_flags, pMobIndex->res_flags);
db.c:	copy_vector(mob->vuln_flags, pMobIndex->vuln_flags);
db.c:	mob->start_pos		= pMobIndex->start_pos;
db.c:	mob->sex		= pMobIndex->sex;
db.c:	copy_vector(mob->form, pMobIndex->form);
db.c:	copy_vector(mob->parts, pMobIndex->parts);
db.c:	mob->size		= SIZE_MEDIUM;
db.c:	mob->material		= "";
db.c:	mob->arms		= pMobIndex->arms;
db.c:	mob->legs		= pMobIndex->legs;
db.c:	mob->regen_rate = 0;
db.c:	mob->timer		= 0;
db.c:            mob->perm_stat[i] = 11 + mob->level/4;
db.c:    mob->position = mob->start_pos;
db.c:    mob->cabal		= mob->pIndexData->cabal;
db.c:    mob->home_room	= NULL;
db.c:    mob->next		= char_list;
db.c:    pMobIndex->count++;
db.c:/* duplicate a mobile exactly -- except inventory */
db.c:    clone->name 	= palloc_string(parent->name);
db.c:    clone->version	= parent->version;
db.c:    clone->short_descr	= palloc_string(parent->short_descr);
db.c:    clone->long_descr	= palloc_string(parent->long_descr);
db.c:    clone->description	= palloc_string(parent->description);
db.c:    clone->group	= parent->group;
db.c:    clone->sex		= parent->sex;
db.c:    clone->SetClass(parent->Class()->GetIndex());
db.c:    clone->race		= parent->race;
db.c:    clone->level	= parent->level;
db.c:    clone->trust	= 0;
db.c:    clone->timer	= parent->timer;
db.c:    clone->wait		= parent->wait;
db.c:    clone->hit		= parent->hit;
db.c:    clone->max_hit	= parent->max_hit;
db.c:    clone->mana		= parent->mana;
db.c:    clone->max_mana	= parent->max_mana;
db.c:    clone->move		= parent->move;
db.c:    clone->max_move	= parent->max_move;
db.c:    clone->gold		= parent->gold;
db.c:    clone->exp		= parent->exp;
db.c:    copy_vector(clone->act, parent->act);
db.c:    copy_vector(clone->comm, parent->comm);
db.c:    copy_vector(clone->imm_flags, parent->imm_flags);
db.c:    copy_vector(clone->res_flags, parent->res_flags);
db.c:    copy_vector(clone->vuln_flags, parent->vuln_flags);
db.c:    clone->invis_level	= parent->invis_level;
db.c:    copy_vector(clone->affected_by, parent->affected_by);
db.c:    clone->position	= parent->position;
db.c:    clone->practice	= parent->practice;
db.c:    clone->train	= parent->train;
db.c:    clone->saving_throw	= parent->saving_throw;
db.c:    clone->alignment	= parent->alignment;
db.c:    clone->hitroll	= parent->hitroll;
db.c:    clone->damroll	= parent->damroll;
db.c:    clone->wimpy	= parent->wimpy;
db.c:    copy_vector(clone->form, parent->form);
db.c:    copy_vector(clone->parts, parent->parts);
db.c:    clone->size		= parent->size;
db.c:    copy_vector(clone->off_flags, parent->off_flags);
db.c:    clone->dam_type	= parent->dam_type;
db.c:    clone->start_pos	= parent->start_pos;
db.c:    clone->dam_mod	= parent->dam_mod;
db.c:    clone->defense_mod	= parent->defense_mod;
db.c:    clone->cabal	= parent->cabal;
db.c:    clone->arms		= parent->arms;
db.c:    clone->legs		= parent->legs;
db.c:    	clone->armor[i]	= parent->armor[i];
db.c:	clone->perm_stat[i]	= parent->perm_stat[i];
db.c:	clone->mod_stat[i]	= parent->mod_stat[i];
db.c:	clone->damage[i]	= parent->damage[i];
db.c:    for (paf = parent->affected; paf != NULL; paf = paf->next)
db.c:    obj->pIndexData	= pObjIndex;
db.c:    obj->in_room	= NULL;
db.c:    obj->ohp		= 0;
db.c:    if (pObjIndex->new_format)
db.c:	obj->level = pObjIndex->level;
db.c:	obj->level		= UMAX(0,level);
db.c:    obj->wear_loc	= -1;
db.c:	obj->name     = palloc_string( pObjIndex->name );           /* OLC */
db.c:	obj->short_descr  = palloc_string( pObjIndex->short_descr );    /* OLC */
db.c:	obj->description  = palloc_string( pObjIndex->description );    /* OLC */
db.c:	obj->material	= palloc_string(pObjIndex->material);
db.c:	if(pObjIndex->wear_loc_name)
db.c:		obj->wear_loc_name = palloc_string(pObjIndex->wear_loc_name);
db.c:		obj->wear_loc_name = NULL;
db.c:    obj->item_type	= pObjIndex->item_type;
db.c:    copy_vector(obj->extra_flags, pObjIndex->extra_flags);
db.c:	obj->apply		= pObjIndex->apply;
db.c:	obj->charaffs	= pObjIndex->charaffs;
db.c:    copy_vector(obj->wear_flags, pObjIndex->wear_flags);
db.c:	copy_vector(obj->imm_flags, pObjIndex->imm_flags);
db.c:	copy_vector(obj->res_flags, pObjIndex->res_flags);
db.c:	copy_vector(obj->vuln_flags, pObjIndex->vuln_flags);
db.c:	obj->value[0]	= pObjIndex->value[0];
db.c:    obj->value[1]	= pObjIndex->value[1];
db.c:    obj->value[2]	= pObjIndex->value[2];
db.c:    obj->value[3]	= pObjIndex->value[3];
db.c:    obj->value[4]	= pObjIndex->value[4];
db.c:    obj->weight		= pObjIndex->weight;
db.c:	copy_vector(obj->progtypes, pObjIndex->progtypes);
db.c:	/* Morg - Valgrind Fix */
db.c:	obj->contains	= NULL;
db.c:	if (pObjIndex->extra_descr)
db.c:		ed->description		=	palloc_string(pObjIndex->extra_descr->description);
db.c:		ed->keyword			=	palloc_string(pObjIndex->extra_descr->keyword);
db.c:		ed->next			=	obj->extra_descr;
db.c:		obj->extra_descr	=	ed;
db.c:    if (level == -1 || pObjIndex->new_format)
db.c:	obj->cost	= pObjIndex->cost;
db.c:    	obj->cost	= number_fuzzy( 10 )
db.c:    switch ( obj->item_type )
db.c:	bug( "Read_object: vnum %d bad type.", pObjIndex->vnum );
db.c:	if (obj->value[2] == 999)
db.c:		obj->value[2] = -1;
db.c:	if (!pObjIndex->new_format)
db.c:	    obj->cost /= 5;
db.c:	   obj->value[i] = -1;
db.c:	if (level != -1 && !pObjIndex->new_format)
db.c:	    obj->value[0]	= number_fuzzy( obj->value[0] );
db.c:	if (level != -1 && !pObjIndex->new_format)
db.c:	    obj->value[0]	= number_fuzzy( obj->value[0] );
db.c:	    obj->value[1]	= number_fuzzy( obj->value[1] );
db.c:	    obj->value[2]	= obj->value[1];
db.c:	if (!pObjIndex->new_format)
db.c:	    obj->cost *= 2;
db.c:	if (level != -1 && !pObjIndex->new_format)
db.c:	    obj->value[1] = number_fuzzy( number_fuzzy( 1 * level / 4 + 2 ) );
db.c:	    obj->value[2] = number_fuzzy( number_fuzzy( 3 * level / 4 + 6 ) );
db.c:	if (level != -1 && !pObjIndex->new_format)
db.c:	    obj->value[0]	= number_fuzzy( level / 5 + 3 );
db.c:	    obj->value[1]	= number_fuzzy( level / 5 + 3 );
db.c:	    obj->value[2]	= number_fuzzy( level / 5 + 3 );
db.c:	if (level != -1 && !pObjIndex->new_format)
db.c:	    obj->value[0] = number_fuzzy( number_fuzzy( obj->value[0] ) );
db.c:	if (!pObjIndex->new_format)
db.c:	    obj->value[0]	= obj->cost;
db.c:    for (paf = pObjIndex->affected; paf != NULL; paf = paf->next)
db.c:	if ( paf->location == APPLY_SPELL_AFFECT ) {
db.c:		oaf.where = paf->where;
db.c:		oaf.type = paf->type;
db.c:		oaf.level = paf->level;
db.c:		oaf.duration = paf->duration;
db.c:		oaf.location = paf->location;
db.c:		oaf.modifier = paf->modifier;
db.c:		copy_vector(oaf.bitvector, paf->bitvector);
db.c:    obj->owner = palloc_string("none");
db.c:    obj->next		= object_list;
db.c:    pObjIndex->limcount += 1;
db.c:/* duplicate an object exactly -- except contents */
db.c:    clone->name 	= palloc_string(parent->name);
db.c:    clone->short_descr 	= palloc_string(parent->short_descr);
db.c:    clone->description	= palloc_string(parent->description);
db.c:    clone->item_type	= parent->item_type;
db.c:    copy_vector(clone->extra_flags, parent->extra_flags);
db.c:	clone->apply		= parent->apply;
db.c:    copy_vector(clone->wear_flags, parent->wear_flags);
db.c:	copy_vector(clone->imm_flags, parent->imm_flags);
db.c:	copy_vector(clone->res_flags, parent->res_flags);
db.c:	copy_vector(clone->vuln_flags, parent->vuln_flags);
db.c:    clone->weight	= parent->weight;
db.c:    clone->cost		= parent->cost;
db.c:    clone->level	= parent->level;
db.c:    clone->condition	= parent->condition;
db.c:    clone->material	= palloc_string(parent->material);
db.c:    clone->timer	= parent->timer;
db.c:    clone->ohp		= parent->ohp;
db.c:	if(parent->wear_loc_name)
db.c:		clone->wear_loc_name = palloc_string(parent->wear_loc_name);
db.c:	clone->value[i]	= parent->value[i];
db.c:    for (paf = parent->affected; paf != NULL; paf = paf->next)
db.c:    for (ed = parent->extra_descr; ed != NULL; ed = ed->next)
db.c:        ed_new->keyword    	= palloc_string( ed->keyword);
db.c:        ed_new->description     = palloc_string( ed->description );
db.c:        ed_new->next           	= clone->extra_descr;
db.c:        clone->extra_descr  	= ed_new;
db.c:    ch->name			= &str_empty[0];
db.c:    ch->short_descr		= &str_empty[0];
db.c:    ch->long_descr		= &str_empty[0];
db.c:    ch->description		= &str_empty[0];
db.c:    ch->prompt  = &str_empty[0];
db.c:    ch->logon			= current_time;
db.c:    ch->lines			= PAGELEN;
db.c:    	ch->armor[i]		= 0;
db.c:    ch->position		= POS_STANDING;
db.c:    ch->hit			= 20;
db.c:    ch->max_hit			= 20;
db.c:    ch->mana			= 100;
db.c:    ch->max_mana		= 100;
db.c:    ch->move			= 100;
db.c:    ch->max_move		= 100;
db.c:    ch->last_fought             = NULL;
db.c:    (int)ch->last_fight_time         = NULL;
db.c:    ch->last_fight_name         = NULL;
db.c:    ch->on			= NULL;
db.c:    ch->hometown		= 0;
db.c:    ch->arms			= 2;
db.c:    ch->legs			= 2;
db.c:    ch->balance			= 0;
db.c:	ch->regen_rate 		= 0;
db.c:    for ( ; ed != NULL; ed = ed->next )
db.c:	if ( is_name( (char *) name, ed->keyword ) )
db.c:	    return ed->description;
db.c:	  pMobIndex  = pMobIndex->next )
db.c:	if ( pMobIndex->vnum == vnum )
db.c:	  pObjIndex  = pObjIndex->next )
db.c:	if ( pObjIndex->vnum == vnum )
db.c:	  pRoomIndex  = pRoomIndex->next )
db.c:	if ( pRoomIndex->vnum == vnum )
db.c:    else if ( c == '-' )
db.c:	number = number * 10 + c - '0';
db.c:	number = 0 - number;
db.c:    if (c == '-')
db.c:	number = number * 10 + c - '0';
db.c:	return -1 * number;
db.c:		bit = letter - 'A';
db.c:		bit = letter - ('a' - 26);
db.c:	for (i = letter; i > 'A'; i--)
db.c:	for (i = letter; i > 'a'; i --)
db.c: * These strings are read-only and shared.
db.c: *   this function takes 40% to 50% of boot-up time.
db.c:         *   -- Furey
db.c:	    plast[-1] = '\0';
db.c:		plast[-1] = '\0';
db.c:		iHash     = UMIN( MAX_KEY_HASH - 1, plast - 1 - top_string );
db.c:		    sAllocString += top_string - pString;
db.c:    static bool char_special[256-EOF];
db.c:    if ( char_special[EOF-EOF] != TRUE )
db.c:        char_special[EOF -  EOF] = TRUE;
db.c:        char_special['\n' - EOF] = TRUE;
db.c:        char_special['\r' - EOF] = TRUE;
db.c:        if ( !char_special[ ( *plast++ = getc( fp ) ) - EOF ] )
db.c:        switch ( plast[-1] )
db.c:		plast[-1] = '\0';
db.c:    pMem -= sizeof(*magic);
db.c: * Fread_strings are read-only and shared.
db.c:	for(pArea = area_first; pArea; pArea = pArea->next)
db.c:		if(pArea->area_type == ARE_UNOPENED || pArea->area_type == ARE_CABAL || pArea->area_type == ARE_SHRINE)
db.c:		if(iArea && (pArea->low_range>iArea || pArea->high_range<iArea))
db.c:		if (pArea->low_range == 1 && pArea->high_range == 51)
db.c:			sprintf(buf,"[  ALL  ] %-20s - %s\n\r",pArea->credits, pArea->name);
db.c:			sprintf(buf,"[%2d - %2d] %-20s - %s\n\r", pArea->low_range, pArea->high_range, pArea->credits, pArea->name);
db.c:    for (fch = char_list; fch != NULL; fch = fch->next)
db.c:	if (fch->pcdata != NULL)
db.c:	for (af = fch->affected; af != NULL; af = af->next)
db.c:    for (fch = char_free; fch != NULL; fch = fch->next)
db.c:    for (pc = pcdata_free; pc != NULL; pc = pc->next)
db.c:    for (d = descriptor_list; d != NULL; d = d->next)
db.c:    for (d= descriptor_free; d != NULL; d = d->next)
db.c:	    for (af = pObjIndex->affected; af != NULL; af = af->next)
db.c:    for (obj = object_list; obj != NULL; obj = obj->next)
db.c:	for (oaf = obj->affected; oaf != NULL; oaf = oaf->next)
db.c:    for (obj = obj_free; obj != NULL; obj = obj->next)
db.c:    for (af = affect_free; af != NULL; af = af->next)
db.c:    fprintf(fp,  "---------------\n");
db.c:	    fprintf(fp,"#%-4d %3d active %3d killed     %s\n",
db.c:		pMobIndex->vnum,pMobIndex->count,
db.c:		pMobIndex->killed,pMobIndex->short_descr);
db.c:    fprintf(fp,  "---------------\n");
db.c:	    fprintf(fp,"#%-4d %3d active %3d reset      %s\n",
db.c:		pObjIndex->vnum,pObjIndex->count,
db.c:		pObjIndex->reset_num,pObjIndex->short_descr);
db.c:    case 0:  number -= 1; break;
db.c:    if ( ( to = to - from + 1 ) <= 1 )
db.c:    while ( ( number = number_mm() & (power -1 ) ) >= to )
db.c:    while ( (percent = number_mm() & (128-1) ) > 99 )
db.c:    while ( ( door = number_mm() & (8-1) ) > 5)
db.c:    return number_mm( ) & ( ( 1 << width ) - 1 );
db.c: * I've gotten too many bad reports on OS-supplied random number generators.
db.c: * This is the Mitchell-Moore algorithm from Knuth Volume II.
db.c: * -- Furey
db.c:   define OLD_RAND to use the old system -- Alander */
db.c:    piState[-2] = 55 - 55;
db.c:    piState[-1] = 55 - 24;
db.c:    piState[0]  = ((int) current_time) & ((1 << 30) - 1);
db.c:        piState[iState] = (piState[iState-1] + piState[iState-2])
db.c:        & ((1 << 30) - 1);
db.c:    iState1             = piState[-2];
db.c:    iState2             = piState[-1];
db.c:        & ((1 << 30) - 1);
db.c:    piState[-2]         = iState1;
db.c:    piState[-1]         = iState2;
db.c:    return value_00 + level * (value_32 - value_00) / 32;
db.c: * Used for player-entered strings that go into disk files.
db.c:	    *str = '-';
db.c:    for ( ichar = 0; ichar <= sstr2 - sstr1; ichar++ )
db.c:    if ( sstr1 <= sstr2 && !str_cmp( astr, bstr + sstr2 - sstr1 ) )
db.c: * Returns an initial-capped string.
db.c:	    ch->in_room ? ch->in_room->vnum : 0, ch->true_name, buf, str );
db.c:    strtime[strlen(strtime)-1] = '\0';
db.c: * -- Furey
db.c:    if(get_trust(ch) < 56 && !IS_BUILDER(ch, ch->in_room->area))
db.c:    pArea = ch->in_room->area;
db.c:	ich_next = ich->next;
db.c:	if(IS_NPC(ich) && ich->in_room->area == pArea && pArea->area_type == ARE_UNOPENED)
db.c:    pArea->age = number_range(0,3);
db.c:    sprintf(buf,"Area: %s reset.\n\r",pArea->name);
db.c:    sprintf(buf,"Area: %s reset by %s.\n\r",pArea->name,ch->name);
db.c:    if (ch->level < 52 && !IS_SET(ch->comm,COMM_BUILDER))
db.c:	for(pArea = area_first; pArea != NULL; pArea = pArea->next)
db.c:		if(pArea->min_vnum<=i && pArea->max_vnum>=i)
db.c:    			sprintf(buf,"%-25s: %4d %4d\n\r",pArea->name,pArea->min_vnum,pArea->max_vnum);
db.c:    for (pArea = area_first; pArea != NULL; pArea = pArea->next)
db.c:    sprintf(buf,"%-25s: %4d %4d",pArea->name,pArea->min_vnum,pArea->max_vnum);
db.c:    avnum[i] = pArea->min_vnum;
db.c:    for(a = 1; a<i-1; a++)
db.c:	sprintf(buf,"%-40s %s\n\r",list[x],x+1<=i ? list[x+1] : "");
db.c:	lObjIndex->limcount = 0;
db.c:	send_to_char("Loading all in-game counts now (excluding PC objects).\n\r",ch);
db.c:    	for (obj = object_list; obj != NULL; obj = obj->next)
db.c:	carrier = obj->carried_by;
db.c:	obj->pIndexData->limcount++;
db.c:				pObjIndex->limcount++;
db.c:			for(x=MAX_TOP_BOUNTY;x>i;x--)
db.c:				top_bounty_name[x]=top_bounty_name[x-1];
db.c:				top_bounty_value[x]=top_bounty_value[x-1];
db.c:		pRoomIndex->reset_first			= NULL;
db.c:		pRoomIndex->reset_last			= NULL;
db.c:        pRoomIndex->owner               = palloc_string("");
db.c:		pRoomIndex->move_progs			= FALSE;
db.c:        pRoomIndex->people              = NULL;
db.c:        pRoomIndex->contents            = NULL;
db.c:        pRoomIndex->extra_descr         = NULL;
db.c:		pRoomIndex->trap				= NULL;
db.c:		pRoomIndex->affected			= NULL;
db.c:		zero_vector(pRoomIndex->room_flags);
db.c:			pRoomIndex->tracks[i] = new_track_data();
db.c:        pRoomIndex->area                = area_last;
db.c:        pRoomIndex->vnum                = vnum;
db.c:        pRoomIndex->name                = fread_string( fp );
db.c:		if (pRoomIndex->name[strlen(pRoomIndex->name) - 1] == '.')
db.c:			chop(pRoomIndex->name);
db.c:        pRoomIndex->description         = fread_string( fp );
db.c:        pRoomIndex->sector_type         = sect_table[sect_lookup(fread_word( fp ))].value;
db.c:		/* Morg - Valgrind fix. */
db.c:		pRoomIndex->rprogs				= NULL;
db.c:		zero_vector(pRoomIndex->progtypes);
db.c:		pRoomIndex->cabal				= 0;
db.c:		pRoomIndex->has_rune			= FALSE;
db.c:		zero_vector(pRoomIndex->affected_by);
db.c:		if(pRoomIndex->area->area_type == ARE_SHRINE) {
db.c:			SET_BIT(pRoomIndex->room_flags, ROOM_NO_SUMMON_TO);
db.c:			SET_BIT(pRoomIndex->room_flags, ROOM_NO_SUMMON_FROM);
db.c:			SET_BIT(pRoomIndex->room_flags, ROOM_NO_GATE);
db.c:            pRoomIndex->exit[door] = NULL;
db.c:        pRoomIndex->heal_rate = 100;
db.c:        pRoomIndex->mana_rate = 100;
db.c:		pRoomIndex->light = 0;
db.c:                pRoomIndex->heal_rate = fread_number(fp);
db.c:                pRoomIndex->mana_rate = fread_number(fp);
db.c:                pRoomIndex->guild = fread_number(fp);
db.c:                if (pRoomIndex->cabal)
db.c:                pRoomIndex->cabal = cabal_lookup(fread_word(fp));
db.c:                pexit->u1.vnum          = fread_number( fp );
db.c:                fread_flag_new(pexit->exit_info, fp);
db.c:                pexit->key              = fread_number( fp );
db.c:                pexit->keyword          = fread_string( fp );
db.c:                pexit->description      = fread_string( fp );
db.c:                pRoomIndex->exit[door]  = pexit;
db.c:                ed->keyword             = fread_string( fp );
db.c:                ed->description         = fread_string( fp );
db.c:                ed->next                = pRoomIndex->extra_descr;
db.c:                pRoomIndex->extra_descr = ed;
db.c:				trap->room = pRoomIndex;
db.c:				trap->type = flag_lookup(fread_word(fp), trap_table);
db.c:				trap->quality = fread_number(fp);
db.c:				if (trap->quality > 10)
db.c:					trap->quality = 10;
db.c:				trap->complexity = fread_number(fp);
db.c:				trap->timer = fread_number(fp);
db.c:				if (trap->timer < 0)
db.c:					trap->timer = 0;
db.c:				trap->trig_echo = fread_string(fp);
db.c:				trap->exec_echo = fread_string(fp);
db.c:				trap->armed = TRUE;
db.c:				pRoomIndex->trap = trap;
db.c:                if (pRoomIndex->owner[0] != '\0')
db.c:                pRoomIndex->owner = fread_string(fp);
db.c:		SET_BIT(pRoomIndex->room_flags,	bitvect);
db.c:        pRoomIndex->next        = room_index_hash[iHash];
db.c:        pRoomIndex->next_room   = room_list;
db.c:		ballot->name	= fread_string(fp);
db.c:		ballot->next	= ballot_first;
db.c:			vote->voter 	= palloc_string(word);
db.c:			vote->vote_for	= palloc_string(fread_word(fp));
db.c:			vote->time	= fread_string(fp);
db.c:			vote->ip	= fread_string(fp);
db.c:			vote->next	= vote_first;
db.c:			ballot->first_vote = vote;
db.c:	pReset->arg1 = 0;
db.c:	pReset->arg2 = 0;
db.c:	pReset->arg3 = 0;
db.c:	pReset->arg4 = 0;
db.c:	pReset->command	= letter;
db.c:	    pReset->arg1		= fread_number(fp);	//leader vnum
db.c:	    pReset->arg2		= fread_number(fp);	//leader mob number
db.c:		pReset->arg3		= 0; 
db.c:	    pReset->arg4		= 0;
db.c:		pReset->arg1	= fread_number( fp );  	//mob vnum
db.c:		pReset->arg3	= fread_number( fp ); 	//to room vnum
db.c:		pReset->arg2	= fread_number( fp ); 	// global limit
db.c:		pReset->arg4	= fread_number( fp ); 	// local limit
db.c:		if ( ( pRoomIndex = get_room_index ( pReset->arg3 ) ) )
db.c:			iLastRoom = pReset->arg3;
db.c:		if(area_last->area_type == ARE_UNOPENED)  //debugging for unopened areas
db.c:	    	get_mob_index  ( pReset->arg1 );
db.c:	    	get_room_index ( pReset->arg3 );
db.c:	    pReset->arg1		= fread_number(fp);	//object vnum
db.c:	    pReset->arg2		= 0;				//crappy placeholder
db.c:	    pReset->arg3		= fread_number(fp); //room vnum
db.c:		iLastRoom = pReset->arg3;
db.c:	    pReset->arg4		= 0;				//crappy placeholder
db.c:	    temp_index = get_obj_index  ( pReset->arg1 );
db.c:	    temp_index->reset_num++;
db.c:		if ( ( pRoomIndex = get_room_index ( pReset->arg3 ) ) )
db.c:			iLastObj = pReset->arg3;
db.c:		if(area_last->area_type == ARE_UNOPENED)
db.c:	    	get_room_index ( pReset->arg3 );
db.c:	    pReset->arg1		= fread_number(fp);	//object being put in container
db.c:	    pReset->arg2		= -1;				//crappy placeholder
db.c:	    pReset->arg3		= fread_number(fp);	//container vnum
db.c:	    pReset->arg4		= fread_number(fp);	//number of copies to put in cont.
db.c:	    temp_index = get_obj_index  ( pReset->arg1 );
db.c:	    temp_index->reset_num++;
db.c:		if(area_last->area_type == ARE_UNOPENED)
db.c:	    	get_obj_index  ( pReset->arg3 );
db.c:	    pReset->arg1		= fread_number(fp);	//object to give
db.c:	    pReset->arg2		= 0;
db.c:	    pReset->arg3		= 0;
db.c:	    pReset->arg4		= 0;
db.c:	    temp_index = get_obj_index  ( pReset->arg1 );
db.c:	    temp_index->reset_num++;
db.c:	    pReset->arg1		= fread_number(fp);	//object to give
db.c:	    pReset->arg2		= 0;
db.c:	    pReset->arg3	= flag_lookup(word,wear_locations);  //location of obj
db.c:		if (pReset->arg3 == NO_FLAG)
db.c:	    pReset->arg4		= 0;
db.c:	    temp_index = get_obj_index  ( pReset->arg1 );
db.c:	    temp_index->reset_num++;
db.c:	    pReset->arg1		= fread_number(fp);	//room vnum
db.c:	    pReset->arg2		= flag_lookup(fread_word( fp ),direction_table); //direction
db.c:		if (pReset->arg2 == NO_FLAG)
db.c:		pReset->arg3	= 0;
db.c:		pReset->arg3	= 1;
db.c:		pReset->arg3	= 2;
db.c:	    pReset->arg4		= 0;
db.c:		if ( ( pRoomIndex = get_room_index ( pReset->arg1 ) ) )
db.c:	    pReset->arg1	= fread_number(fp);
db.c:	    pReset->arg2	= fread_number(fp);
db.c:	    pReset->arg3	= 0;
db.c:	    pReset->arg4	= 0;
db.c:		if ( ( pRoomIndex = get_room_index ( pReset->arg1 ) ) )
db.c:		if ( pReset->arg2 < 0 || pReset->arg2 > 6 )
db.c:		bug( "Load_resets: 'R': bad exit %d.", pReset->arg2 );
db.c:	pReset->next		= NULL;
db.c:	sprintf(query,"DELETE FROM notes WHERE %ld-timestamp>1209600",current_time);
db.c:	race_list->first = race_list;
db.c:		race_list->name = palloc_string(race_table[i].name);
db.c:		race_list->pc_race = race_table[i].pc_race;
db.c:		race_list->number = i;
db.c:				SET_BIT(race_list->act, race_table[i].act[j]);
db.c:				SET_BIT(race_list->aff, race_table[i].aff[j]);
db.c:				SET_BIT(race_list->off, race_table[i].off[j]);
db.c:				SET_BIT(race_list->imm, race_table[i].imm[j]);
db.c:				SET_BIT(race_list->res, race_table[i].res[j]);
db.c:				SET_BIT(race_list->vuln, race_table[i].vuln[j]);
db.c:				SET_BIT(race_list->form, race_table[i].form[j]);
db.c:				SET_BIT(race_list->parts, race_table[i].parts[j]);
db.c:		race_list->arms = race_table[i].arms;
db.c:		race_list->legs = race_table[i].legs;
db.c:		race_list->next = new_race_data();
db.c:		race_list->next->first = race_list->first;
db.c:		race_list = race_list->next;
db.c:	race_list->next = NULL;
db.c:	race_list = race_list->first;
db.c:		return (char)((int)('a') + i - 26);
db2.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
db2.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
db2.c:				if (pObjIndex->iprogs == NULL)
db2.c:					pObjIndex->iprogs  = new_iprog();
db2.c:					CLEAR_MEM(pObjIndex->iprogs, sizeof(IPROG_DATA));
db2.c:			if (!room->rprogs)
db2.c:				room->rprogs = new RPROG_DATA;
db2.c:				CLEAR_MEM(room->rprogs, sizeof(RPROG_DATA));
db2.c:			if (!area_last->aprogs)
db2.c:				area_last->aprogs = new APROG_DATA;
db2.c:				CLEAR_MEM(area_last->aprogs, sizeof(APROG_DATA));
db2.c:	    	if (pMobIndex->mprogs == NULL)
db2.c:	      		pMobIndex->mprogs = new MPROG_DATA;
db2.c:		  		CLEAR_MEM(pMobIndex->mprogs, sizeof(MPROG_DATA));
db2.c:				pObjIndex->spec_prog.trapvector = ispec_table[i].spec_events;
db2.c:				pObjIndex->spec_prog.func = ispec_table[i].spec_func;
db2.c:			bug("Error: Unable to load ispec for #%d.",pObjIndex->vnum);
db2.c:		if (!room->rprogs)
db2.c:			room->rprogs = palloc_struct(sizeof(RPROG_DATA));
db2.c:		if (!area_last->aprogs)
db2.c:			area_last->aprogs = palloc_struct(sizeof(APROG_DATA));
db2.c:				pMobIndex->spec_prog.trapvector = mspec_table[i].spec_events;
db2.c:				pMobIndex->spec_prog.func = mspec_table[i].spec_func;
db2.c:			bug("Error: Unable to load mspec for #%d.",pMobIndex->vnum);
db2.c:        pMobIndex->vnum                 = vnum;
db2.c:		pMobIndex->new_format			= TRUE;
db2.c:		pMobIndex->area					= area_last;
db2.c:		pMobIndex->count				= 0;
db2.c:        pMobIndex->player_name          = fread_string( fp );
db2.c:        pMobIndex->short_descr          = fread_string( fp );
db2.c:        pMobIndex->long_descr           = fread_string( fp );
db2.c:        pMobIndex->description          = fread_string( fp );
db2.c:		pMobIndex->barred_entry			= NULL;
db2.c:        pMobIndex->long_descr[0]        = UPPER(pMobIndex->long_descr[0]);
db2.c:        pMobIndex->description[0]       = UPPER(pMobIndex->description[0]);
db2.c:        pMobIndex->pShop                = NULL;
db2.c:		pMobIndex->notes				= NULL;
db2.c:        pMobIndex->alignment            = fread_number( fp );
db2.c:        pMobIndex->group                = fread_number( fp );
db2.c:		pMobIndex->xp_mod				= fread_number( fp );
db2.c:        pMobIndex->race                 = race_lookup(fread_string( fp ));
db2.c:        pMobIndex->level                = fread_number( fp );
db2.c:		pMobIndex->SetClass(CLASS_NONE);
db2.c:		pMobIndex->cabal				= 0;
db2.c:		pMobIndex->spec_prog.trapvector = 0;
db2.c:		pMobIndex->spec_prog.func		= NULL;
db2.c:        pMobIndex->hit[DICE_NUMBER]     = fread_number( fp );
db2.c:        pMobIndex->hit[DICE_TYPE]   	= fread_number( fp );
db2.c:        pMobIndex->hit[DICE_BONUS]      = fread_number( fp );
db2.c:/*    pMobIndex->mana[DICE_NUMBER]    = fread_number( fp );
db2.c:    pMobIndex->mana[DICE_TYPE]  = fread_number( fp );
db2.c:    pMobIndex->mana[DICE_BONUS] = fread_number( fp ); */
db2.c:	pMobIndex->mana[DICE_NUMBER]	=	1;
db2.c:	pMobIndex->mana[DICE_TYPE]		=	1;
db2.c:	pMobIndex->mana[DICE_BONUS]		=	99;
db2.c:	pMobIndex->damage[DICE_NUMBER]	= fread_number( fp );
db2.c:	pMobIndex->damage[DICE_TYPE]	= fread_number( fp );
db2.c:	pMobIndex->damage[DICE_BONUS]	= fread_number( fp );
db2.c:	pMobIndex->hitroll		= fread_number(fp);
db2.c:	pMobIndex->dam_mod		= fread_number(fp);
db2.c:	pMobIndex->dam_type		= attack_lookup(fread_word(fp));
db2.c:	pMobIndex->ac[AC_PIERCE]	= fread_number( fp );
db2.c:	pMobIndex->ac[AC_BASH]		= fread_number( fp );
db2.c:	pMobIndex->ac[AC_SLASH]		= fread_number( fp );
db2.c:	pMobIndex->ac[AC_EXOTIC]	= fread_number( fp );
db2.c:	copy_vector(pMobIndex->act, race_data_lookup(pMobIndex->race)->act);
db2.c:	SET_BIT(pMobIndex->act, ACT_IS_NPC);
db2.c:	copy_vector(pMobIndex->affected_by, race_data_lookup(pMobIndex->race)->aff);
db2.c:	copy_vector(pMobIndex->off_flags, race_data_lookup(pMobIndex->race)->off);
db2.c:	copy_vector(pMobIndex->imm_flags, race_data_lookup(pMobIndex->race)->imm);
db2.c:	copy_vector(pMobIndex->res_flags, race_data_lookup(pMobIndex->race)->res);
db2.c:	copy_vector(pMobIndex->vuln_flags, race_data_lookup(pMobIndex->race)->vuln);
db2.c:	pMobIndex->start_pos		= position_lookup(fread_word(fp));
db2.c:	pMobIndex->sex			= sex_lookup(fread_word(fp));
db2.c:	pMobIndex->sex			= UMAX(0, pMobIndex->sex);
db2.c:		pMobIndex->wealth = 0;
db2.c:		pMobIndex->wealth = (int)pow(10,wealth - 1);
db2.c:	fread_flag_new(pMobIndex->form, fp);
db2.c:	BITWISE_OR(pMobIndex->form, race_data_lookup(pMobIndex->race)->form);
db2.c:	fread_flag_new(pMobIndex->parts, fp);
db2.c:	BITWISE_OR(pMobIndex->parts,race_data_lookup(pMobIndex->race)->parts);
db2.c:	pMobIndex->size			= size_lookup(fread_word(fp));
db2.c:	pMobIndex->size			= UMAX(pMobIndex->size, 0);
db2.c: 	pMobIndex->mprogs		= NULL;
db2.c:	pMobIndex->restrict_low	 	= LOW_VNUM;
db2.c:	pMobIndex->restrict_high	= HIGH_VNUM;
db2.c:	zero_vector(pMobIndex->styles);
db2.c:	zero_vector(pMobIndex->progtypes);
db2.c:			SET_BIT(pMobIndex->act, pos);
db2.c:			BITWISE_OR(pMobIndex->act, race_data_lookup(pMobIndex->race)->act);
db2.c:			SET_BIT(pMobIndex->affected_by, pos);
db2.c:			BITWISE_OR(pMobIndex->affected_by, race_data_lookup(pMobIndex->race)->aff);
db2.c:			SET_BIT(pMobIndex->off_flags, pos);
db2.c:			BITWISE_OR(pMobIndex->off_flags, race_data_lookup(pMobIndex->race)->off);
db2.c:			SET_BIT(pMobIndex->imm_flags, pos);
db2.c:			BITWISE_OR(pMobIndex->imm_flags, race_data_lookup(pMobIndex->race)->imm);
db2.c:			SET_BIT(pMobIndex->res_flags, pos);
db2.c:			BITWISE_OR(pMobIndex->res_flags, race_data_lookup(pMobIndex->race)->res);
db2.c:			SET_BIT(pMobIndex->vuln_flags, pos);
db2.c:			BITWISE_OR(pMobIndex->vuln_flags, race_data_lookup(pMobIndex->race)->vuln);
db2.c:			pMobIndex->SetClass(CClass::Lookup(bword));
db2.c:			if (pMobIndex->Class()->GetIndex() == CLASS_WARRIOR)
db2.c:				SET_BIT(pMobIndex->styles, bit);
db2.c:				SET_BIT(pMobIndex->styles, bit);
db2.c:			else if (pMobIndex->Class()->GetIndex() == CLASS_SORCERER)
db2.c:				pMobIndex->ele_major = ele_name_lookup(fread_word(fp));
db2.c:				pMobIndex->ele_para = ele_name_lookup(fread_word(fp));
db2.c:			speech->mob = pMobIndex;
db2.c:			speech->name = palloc_string(bword);
db2.c:			if (!pMobIndex->speech)
db2.c:				pMobIndex->speech = speech;
db2.c:				for (sptr = pMobIndex->speech; sptr->next ; sptr = sptr->next);
db2.c:				sptr->next = speech;
db2.c:				speech->prev = sptr;
db2.c:					line->speech = speech;
db2.c:					if (!speech->first_line)
db2.c:						line->number = 0;
db2.c:						speech->first_line = line;
db2.c:						speech->current_line = line;
db2.c:						line->number = speech->current_line->number + 1;
db2.c:						speech->current_line->next = line;
db2.c:						line->prev = speech->current_line;
db2.c:						speech->current_line = line;
db2.c:					line->delay = fread_number(fp);
db2.c:					line->type = pos = flag_lookup(fread_word(fp),speech_table);
db2.c:					line->text = fread_string(fp);
db2.c:					speech->current_line = speech->first_line;
db2.c:		if(pos==-1)
db2.c:			sprintf(bugtext,"No flag in the %s table named %s was found (mob %s - %d).",
db2.c:				aword,bword,pMobIndex->player_name,pMobIndex->vnum);
db2.c:		pMobIndex->affect_sn[i]=-1;
db2.c:	/* Morg - Valgrind fix */
db2.c:		pMobIndex->cast_spell[i]=NULL;
db2.c:		    	REMOVE_BIT(pMobIndex->act,vector);
db2.c:		    	REMOVE_BIT(pMobIndex->affected_by,vector);
db2.c:		    	REMOVE_BIT(pMobIndex->off_flags,vector);
db2.c:		    	REMOVE_BIT(pMobIndex->imm_flags,vector);
db2.c:		    	REMOVE_BIT(pMobIndex->res_flags,vector);
db2.c:		    	REMOVE_BIT(pMobIndex->vuln_flags,vector);
db2.c:		    	REMOVE_BIT(pMobIndex->form,vector);
db2.c:		    	REMOVE_BIT(pMobIndex->parts,vector);
db2.c:			/* dev - mob affects */
db2.c:					if(pMobIndex->affect_sn[i]<1)
db2.c:						pMobIndex->affect_sn[i]=sn;
db2.c:						pMobIndex->affect_bit[i] = bit;
db2.c:			/* Mob casts - dev */
db2.c:				pMobIndex->cabal = cabal_lookup(fread_word(fp));
db2.c:				if(pMobIndex->cast_spell[i]==NULL)
db2.c:					pMobIndex->cast_spell[i] = palloc_string(word);
db2.c:			if(pMobIndex->barred_entry)
db2.c:			bar->type = flag_lookup(fread_word(fp),criterion_flags);
db2.c:			if(bar->type == NO_FLAG)
db2.c:			bar->comparison	= -1;
db2.c:				bar->comparison = BAR_EQUAL_TO;
db2.c:				bar->comparison = BAR_LESS_THAN;
db2.c:				bar->comparison = BAR_GREATER_THAN;
db2.c:			if(bar->comparison<0)
db2.c:			bar->value = fread_number(fp);
db2.c:			bar->vnum = fread_number(fp);
db2.c:			bar->msg_type = -1;
db2.c:				bar->msg_type = BAR_SAY;
db2.c:				bar->msg_type = BAR_EMOTE;
db2.c:				bar->msg_type = BAR_ECHO;
db2.c:				bar->message = fread_string(fp);
db2.c:				bar->message_two = fread_string(fp);
db2.c:				if(!str_cmp(bar->message_two,""))
db2.c:					bar->message_two = NULL;
db2.c:				pMobIndex->barred_entry = bar;
db2.c:			if(bar->msg_type<0)
db2.c:			bar->message = fread_string(fp);
db2.c:			pMobIndex->barred_entry = bar;
db2.c:			pMobIndex->notes = fread_string(fp);
db2.c:			pMobIndex->restrict_low = fread_number(fp);
db2.c:			pMobIndex->restrict_high = fread_number(fp);
db2.c:			pShop->open_hour = fread_number(fp);
db2.c:			pShop->close_hour = fread_number(fp);
db2.c:			pShop->direction = flag_lookup(fread_word( fp ),direction_table);
db2.c:				pShop->fIsPetShop 	= FALSE;
db2.c:				pShop->pet_cage_vnum 	= 0;
db2.c:				pShop->fIsPetShop	= TRUE;
db2.c:				pShop->pet_cage_vnum	= fread_number(fp);
db2.c:			if (pShop->direction == NO_FLAG)
db2.c:            	shop_last->next = pShop;
db2.c:			pMobIndex->pShop	= pShop;
db2.c:			pShop->pMobIndex	= pMobIndex;
db2.c:			pMobIndex->attack_yell = fread_string(fp);
db2.c:        pMobIndex->arms = race_data_lookup(pMobIndex->race)->arms;
db2.c:        pMobIndex->legs = race_data_lookup(pMobIndex->race)->legs;
db2.c:        if (!IS_SET(pMobIndex->parts,PART_ARMS))
db2.c:			pMobIndex->arms = 0;
db2.c:        if (!IS_SET(pMobIndex->parts,PART_LEGS))
db2.c:			pMobIndex->legs = 0;
db2.c:        pMobIndex->next         = mob_index_hash[iHash];
db2.c:        kill_table[URANGE(0, pMobIndex->level, MAX_LEVEL-1)].number++;
db2.c:        pObjIndex->vnum                 = vnum;
db2.c:	pObjIndex->area			= area_last;
db2.c:        pObjIndex->new_format           = TRUE;
db2.c:	pObjIndex->reset_num		= 0;
db2.c:	pObjIndex->limcount		= 0;
db2.c:	pObjIndex->limtotal		= 0;
db2.c:	pObjIndex->extra_descr	= NULL;
db2.c:	pObjIndex->name                 = fread_string( fp );
db2.c:        pObjIndex->short_descr          = fread_string( fp );
db2.c:        pObjIndex->description          = fread_string( fp );
db2.c:        pObjIndex->item_type            = item_lookup(fread_word( fp ));
db2.c:        pObjIndex->material		    = fread_string( fp );
db2.c:	pObjIndex->material_index	    = material_lookup(pObjIndex->material);
db2.c:        zero_vector(pObjIndex->extra_flags);
db2.c:	zero_vector(pObjIndex->wear_flags);
db2.c:  	zero_vector(pObjIndex->restrict_flags);
db2.c:	zero_vector(pObjIndex->imm_flags);
db2.c:	zero_vector(pObjIndex->res_flags);
db2.c:	zero_vector(pObjIndex->vuln_flags);
db2.c:        pObjIndex->start_timer		= -1;
db2.c:		pObjIndex->notes			=	NULL;
db2.c:		pObjIndex->charaffs				= NULL;
db2.c:		pObjIndex->apply				= NULL;
db2.c:        pObjIndex->wear_echo[0]         = NULL;
db2.c:        pObjIndex->remove_echo[0]       = NULL;
db2.c:        pObjIndex->wear_echo[1]         = NULL;
db2.c:        pObjIndex->remove_echo[1]       = NULL;
db2.c:		pObjIndex->wear_loc_name		= NULL;
db2.c:		pObjIndex->affected				= NULL;
db2.c:		pObjIndex->spec_prog.trapvector = 0;
db2.c:		pObjIndex->cabal				= 0;
db2.c:		pObjIndex->verb					= NULL;
db2.c:	pObjIndex->spec_prog.func = NULL;
db2.c:	switch(pObjIndex->item_type)
db2.c:	    pObjIndex->value[0]		= weapon_type(fread_word(fp));
db2.c:	    pObjIndex->value[1]		= fread_number(fp);
db2.c:	    pObjIndex->value[2]		= fread_number(fp);
db2.c:	    pObjIndex->value[3]		= attack_lookup(fread_word(fp));
db2.c:	    pObjIndex->value[4]		= fread_flag(fp);
db2.c:	    pObjIndex->value[0]		= fread_number(fp);
db2.c:	    pObjIndex->value[1]		= fread_flag(fp);
db2.c:	    pObjIndex->value[2]		= fread_number(fp);
db2.c:	    pObjIndex->value[3]		= fread_number(fp);
db2.c:	    pObjIndex->value[4]		= fread_number(fp);
db2.c:            pObjIndex->value[0]         = fread_number(fp);
db2.c:            pObjIndex->value[1]         = fread_number(fp);
db2.c:            pObjIndex->value[2]         = liq_lookup(fread_word(fp));
db2.c:            pObjIndex->value[3]         = fread_number(fp);
db2.c:            pObjIndex->value[4]         = fread_number(fp);
db2.c:	    pObjIndex->value[0]		= fread_number(fp);
db2.c:	    pObjIndex->value[1]		= fread_number(fp);
db2.c:	    pObjIndex->value[2]		= fread_number(fp);
db2.c:	    pObjIndex->value[3]		= skill_lookup(fread_word(fp));
db2.c:	    pObjIndex->value[4]		= fread_number(fp);
db2.c: 	    pObjIndex->value[0]		= fread_number(fp);
db2.c:	    pObjIndex->value[1]		= skill_lookup(fread_word(fp));
db2.c:	    pObjIndex->value[2]		= skill_lookup(fread_word(fp));
db2.c:	    pObjIndex->value[3]		= skill_lookup(fread_word(fp));
db2.c:	    pObjIndex->value[4]		= skill_lookup(fread_word(fp));
db2.c:        pObjIndex->value[0]             = fread_flag( fp );
db2.c:        pObjIndex->value[1]             = fread_flag( fp );
db2.c:        pObjIndex->value[2]             = fread_flag( fp );
db2.c:        pObjIndex->value[3]             = fread_flag( fp );
db2.c:	    pObjIndex->value[4]		    = fread_flag( fp );
db2.c:	pObjIndex->level		= fread_number( fp );
db2.c:      pObjIndex->weight               = fread_number( fp );
db2.c:      pObjIndex->cost                 = fread_number( fp );
db2.c:	pObjIndex->iprogs               = NULL;
db2.c:		zero_vector(pObjIndex->progtypes);
db2.c:	    case ('P') :		pObjIndex->condition = 100; break;
db2.c:	    case ('G') :		pObjIndex->condition =  90; break;
db2.c:	    case ('A') :		pObjIndex->condition =  75; break;
db2.c:	    case ('W') :		pObjIndex->condition =  50; break;
db2.c:	    case ('D') :		pObjIndex->condition =  25; break;
db2.c:	    case ('B') :		pObjIndex->condition =  10; break;
db2.c:	    case ('R') :		pObjIndex->condition =   0; break;
db2.c:	    default:			pObjIndex->condition = 100; break;
db2.c:				apply->location		= display_lookup(fread_word(fp),apply_locations);
db2.c:		    if(apply->location == -1)
db2.c:                apply->modifier           = fread_number( fp );
db2.c:                apply->next               = pObjIndex->apply;
db2.c:                pObjIndex->apply 	    = apply;
db2.c:                if (pObjIndex->cabal)
db2.c:                pObjIndex->cabal = cabal_lookup(fread_word(fp));
db2.c:			if (paf.type == -1)
db2.c:			paf.level		= pObjIndex->level;
db2.c:			paf.duration	= -1;
db2.c:				SET_BIT(pObjIndex->imm_flags, bit);
db2.c:				SET_BIT(pObjIndex->res_flags, bit);
db2.c:				SET_BIT(pObjIndex->vuln_flags,bit);
db2.c:                ed->keyword             = fread_string( fp );
db2.c:                ed->description         = fread_string( fp );
db2.c:                ed->next                = pObjIndex->extra_descr;
db2.c:                pObjIndex->extra_descr  = ed;
db2.c:			SET_BIT(pObjIndex->extra_flags, bit);
db2.c:			pObjIndex->wear_echo[0]	= fread_string(fp);
db2.c:			pObjIndex->wear_echo[1] = fread_string(fp);
db2.c:			pObjIndex->remove_echo[0] = fread_string(fp);
db2.c:			pObjIndex->remove_echo[1] = fread_string(fp);
db2.c:		SET_BIT(pObjIndex->restrict_flags, bit);
db2.c:		pObjIndex->limtotal 	  = fread_number(fp);
db2.c:			SET_BIT(pObjIndex->wear_flags,bit);
db2.c:		pObjIndex->verb	  = palloc_string(fread_word(fp));
db2.c:		pObjIndex->start_timer	  = fread_number(fp);
db2.c:				pObjIndex->wear_loc_name = fread_string(fp);
db2.c:				pObjIndex->notes  = fread_string(fp);
db2.c:        pObjIndex->next         = obj_index_hash[iHash];
devextra.c:	act("----------------------",ch,0,0,TO_CHAR);
devextra.c:	sprintf(buf,"Gold held by players : %ld (%ldgp mobile held)\n\r", player_gold, total_gold-player_gold);
devextra.c:				free_char(d->character);
devextra.c:	        	d->character->desc = NULL;
devextra.c:			if(d->character->level>=30)
devextra.c:				perm_death_log(d->character, 4);
devextra.c:			delete_char(d->character->true_name, TRUE);
devextra.c:			free_char(d->character);
devextra.c:		ch->true_name, autol ? "AND status = 0" : "");
devextra.c:        for(altar = object_list; altar; altar = altar->next)
devextra.c:                if(altar->in_room && altar->item_type == ITEM_ALTAR && altar->in_room == ch->in_room)
devextra.c:	if(!altar || !altar->in_room->owner || !str_cmp(altar->in_room->owner,""))
devextra.c:			altar->in_room->owner, ch->true_name);
devextra.c:	escape = (char *)escape_string(obj->short_descr);
devextra.c:		altar->in_room->owner, obj->pIndexData->vnum, escape, ch->true_name, current_time);
devextra.c:			sprintf(buf,"%4d     %-26s %-10s %ld\n\r", id, row[2], row[1], (long) mysql_affected_rows(conn2));
devextra.c:		ch->pcdata->entered_text = palloc_string("");
devextra.c:		ch->pcdata->helpid	 = atoi(arg2);
devextra.c:				sprintf(query,"%-12s",row2[0]);
devextra.c:		return send_to_char("Error:  Your comment contained a double-quotation mark.  You must use single quotes to prevent errors.\n\r",ch);
devextra.c:			ch->pcdata->helpid, ch->true_name, log_time(), escape);
devextra.c:	sprintf(query,"Your comment was added.  Use sitetrack %d to view your comments.\n\r", ch->pcdata->helpid);
devextra.c:	ch->pcdata->entered_text[0] = '\0';
devextra.c:		sprintf(buf," [Game-wide: %4s%%, ",row2[0]);
devextra.c:		sprintf(buf,"Cabal-wide: %s%%]\n\r",row2[0]);
devextra.c:	ch->pcdata->entering_text = TRUE;
devextra.c:	ch->pcdata->end_fun = end_fun;
devextra.c:	if(ch->pcdata->entered_text!=NULL && ch->pcdata->entered_text[0]!='\0')
devextra.c:		send_to_char(ch->pcdata->entered_text, ch);
devextra.c:	if(ch->level < minlevel)
devextra.c:		sprintf(message_death,"took %s own life.", (ch->sex == 2) ? "her" : "his");
devextra.c:		sprintf(message_death,"perished in %s sleep.", (ch->sex == 2) ? "her" : "his");
devextra.c:	sprintf(name,"(%s) %s%s", type_death, ch->true_name, ch->pcdata->title);
devextra.c:	if(ch->pcdata->extitle != NULL)
devextra.c:		sprintf(name,"%s%s", name, ch->pcdata->extitle);
devextra.c:	if(ch->alignment == 1000)
devextra.c:	else if(ch->alignment == 0)
devextra.c:	if(ch->pcdata->ethos == 1000)
devextra.c:	else if(ch->pcdata->ethos == 0)
devextra.c:			ch->true_name,
devextra.c:			ch->true_name,
devextra.c:			ch->pcdata->title);
devextra.c:	if(ch->pcdata->extitle != NULL)
devextra.c:		sprintf(message,"%s%s", message, ch->pcdata->extitle);
devextra.c:			ch->level,
devextra.c:			pc_race_table[ch->race].race_time,
devextra.c:			ch->pcdata->birth_date,
devextra.c:			race_table[ch->race].name,
devextra.c:			sex_table[ch->sex].name,
devextra.c:			(RSTR)ch->Class()->name);
devextra.c:	if(ch->Class()->GetIndex() == CLASS_WARRIOR)
devextra.c:			if(IS_SET(ch->pcdata->styles, style_table[i].bit))
devextra.c:	else if(ch->Class()->GetIndex() == CLASS_SORCERER)
devextra.c:		 sprintf(message, "%s%s's major elemental focus was %s and %s para-elemental focus was %s.\r",
devextra.c:				ch->true_name,
devextra.c:				sphere_table[ch->pcdata->ele_major].name,
devextra.c:				(ch->sex == 2) ? "her" : "his",
devextra.c:				sphere_table[ch->pcdata->ele_para].name);
devextra.c:	if(ch->cabal)
devextra.c:		sprintf(message,"%s\rCabal: %s, %s",message,cabal_table[ch->cabal].who_name, cabal_table[ch->cabal].long_name);
devextra.c:		if(ch->cabal == CABAL_HORDE && ch->pcdata->tribe)
devextra.c:			sprintf(message,"%s, of the %s Tribe", message, palloc_string(capitalize(tribe_table[ch->pcdata->tribe].name)));
devextra.c:	if((ch->pcdata->frags[PK_KILLS] + ch->pcdata->fragged) > 0)
devextra.c:			message,(ch->pcdata->frags[PK_KILLS]*100 / (ch->pcdata->frags[PK_KILLS] + ch->pcdata->fragged)));
devextra.c:				 ch->true_name,
devextra.c:				 ch->pcdata->frags[PK_KILLS],
devextra.c:				 ch->pcdata->frags[PK_GOOD],
devextra.c:				 ch->pcdata->frags[PK_NEUTRAL],
devextra.c:				 ch->pcdata->frags[PK_EVIL],
devextra.c:				 ch->pcdata->fragged,
devextra.c:				 ch->pcdata->killed[MOB_KILLED],
devextra.c:			&& victim->master == ch)
devextra.c:	if(IS_SET(victim->pcdata->trust,TRUST_CABAL) && is_same_cabal(ch,victim))
devextra.c:	if(IS_SET(victim->pcdata->trust,TRUST_GROUP) && is_same_group(ch,victim))
devextra.c:	if(victim->pcdata->trusting == ch)
devextra.c:        for(vote=ballot->first_vote; vote!=NULL; vote=vote->next)
devextra.c:	  sprintf(svote[0].who,"%s",vote->vote_for);
devextra.c:            if(strcmp(svote[x].who, vote->vote_for)==0)
devextra.c:             sprintf(svote[x].who,"%s",vote->vote_for);
devextra.c:			for(m = 0; m <= 200 - j; m++)                                                                     
devextra.c:				strftime(time, 200, "%m-%d-%Y %H:%M:%S", localtime(&test));
devextra.c:		cabal = victim->cabal;
devextra.c:	if (!ch->cabal || ch->cabal != CABAL_GUILD)
devextra.c:	else if (cabal != ch->cabal)
devextra.c:	sprintf(buf,"SELECT COUNT(voter) FROM votes WHERE voter='%s'", ch->true_name);
devextra.c:	escape = (char *) ((ch->pcdata->host) ? escape_string(ch->pcdata->host) : escape_string(ch->desc->host));
devextra.c:		sprintf(buf,"SELECT vote_for FROM votes WHERE voter='%s'", ch->true_name);
devextra.c:				ch->true_name, arg1, ch->cabal, current_time, escape);	
devextra.c:		sprintf(buf,"You have placed your vote for %s.\n\r", (!str_cmp(arg1,ch->true_name)) ? "yourself" : arg1);
devextra.c:    for ( d = descriptor_list; d; d = d->next )
devextra.c:        if ( d->connected == CON_PLAYING
devextra.c:        &&   d->character->in_room == ch->in_room
devextra.c:	&&   IS_AWAKE(d->character)
devextra.c:	&&   d->character != ch)
devextra.c:            if (get_trust(d->character) >= 55)
devextra.c:                send_to_char( "local mob> ",d->character);
devextra.c:            send_to_char( argument, d->character );
devextra.c:            send_to_char( "\n\r",   d->character );
devextra.c:    	for (d = descriptor_list; d; d = d->next)
devextra.c:        if (d->connected == CON_PLAYING
devextra.c:        &&  d->character->in_room != NULL && ch->in_room != NULL
devextra.c:        &&  d->character->in_room->area == ch->in_room->area)
devextra.c:            colorconv(buffer, echo, d->character);
devextra.c:            send_to_char(buffer,d->character);
devextra.c:            send_to_char("\n\r",d->character);
devextra.c:        for (d = descriptor_list; d; d = d->next)
devextra.c:        if (d->connected == CON_PLAYING
devextra.c:        &&  d->character->in_room != NULL && room != NULL
devextra.c:        &&  d->character->in_room->area == room->area)
devextra.c:            colorconv(buffer, echo, d->character);
devextra.c:            send_to_char(buffer,d->character);
devextra.c:            send_to_char("\n\r",d->character);
devextra.c:	for (d = descriptor_list; d; d = d->next) {
devextra.c:		if (d->connected == CON_PLAYING &&
devextra.c:			d->character->in_room != NULL && area != NULL &&
devextra.c:			d->character->in_room->area == area &&
devextra.c:			d->character->in_room->sector_type != SECT_INSIDE &&
devextra.c:			d->character->in_room->sector_type != SECT_UNDERWATER &&
devextra.c:			IS_AWAKE(d->character) &&
devextra.c:			!IS_SET(d->character->in_room->room_flags,ROOM_INDOORS)) {
devextra.c:			colorconv(buffer,echo,d->character);
devextra.c:			send_to_char(buffer,d->character);
devextra.c:			send_to_char("\n\r",d->character);
devextra.c:	if(!(skill=get_skill(victim,gsn_volley)) || victim->fighting || !IS_AWAKE(victim) || victim==ch)
devextra.c:	chance -= get_curr_stat(ch,STAT_INT);
devextra.c:	if (IS_SET(ch->comm, COMM_LOTS_O_COLOR))
devextra.c:		return color_table[number_range(0,MAX_COLORS-1)].color_ascii;
devextra.c:	if ( ch->desc != NULL && ch->desc->original != NULL )
devextra.c:		ch = ch->desc->original;
devextra.c:    if(!IS_SET(ch->comm,COMM_ANSI))
devextra.c:		return color_name_to_ascii(ch->pcdata->color_scheme[i]);
devextra.c:	return -1;
devextra.c:	if (IS_SET(ch->comm, COMM_LOTS_O_COLOR))
devextra.c:		return color_table[number_range(0,MAX_COLORS-1)].color_ascii;
devextra.c:	if (ch->desc != NULL && ch->desc->original != NULL)
devextra.c:		if (IS_SET(ch->desc->original->comm,COMM_ANSI))
devextra.c:		if (IS_SET(ch->comm,COMM_ANSI))
devextra.c:	WAIT_STATE(ch,ch->wait + npulse);
devextra.c:	if (!IS_NPC(ch) && ch->pcdata->energy_state == -4) {
devextra.c:	if(ch->in_room && is_affected_room(ch->in_room, gsn_gravity_well))
devextra.c:		for(raf = ch->in_room->affected; raf!=NULL; raf=raf->next)
devextra.c:			if(raf->type == gsn_gravity_well)
devextra.c:		if(ch == raf->owner)
devextra.c:	ch->wait = UMAX(ch->wait,wait);
devextra.c:		wait -= PULSE_VIOLENCE;
devextra.c:	ch->wait = UMAX(ch->wait,wait);
devextra.c:        strtime[strlen(strtime)-1] = '\0';
devextra.c:	if(!ch->pcdata->bounty_credits && ch->cabal!=CABAL_BOUNTY && !IS_IMMORTAL(ch))
devextra.c:			sprintf(buf3,"%s has %i bounty credits.\n\r",victim->name,victim->pcdata->bounty_credits);
devextra.c:			victim->pcdata->bounty_credits=atoi(buf2);
devextra.c:			sprintf(buf3,"%s now has %i bounty credits.\n\r",victim->name,victim->pcdata->bounty_credits);
devextra.c:		sprintf(buf,"%-15s - %i\n\r",capitalize(bounty_table[i].rank_name),bounty_table[i].credits_required);
devextra.c:	sprintf(buf2,"You have %i bounty credits.\n\r",ch->pcdata->bounty_credits);
devextra.c:	int i, old_credit=ch->pcdata->bounty_credits;
devextra.c:	ch->pcdata->bounty_credits+=credit;
devextra.c:		if(ch->pcdata->bounty_credits>=bounty_table[i].credits_required 
devextra.c:			sprintf(buf2,"%s has advanced to the position of %s.",ch->name,bounty_table[i].rank_extitle);
devextra.c:			sprintf(blog,"%s advances to %s.",ch->name,bounty_table[i].rank_extitle);
devextra.c:			ch->pcdata->cabal_level++;
devextra.c:			if (i > 0 && top_bounty_value[i] == top_bounty_value[i-1]) {
devextra.c:				pnum--;
devextra.c:			sprintf(buf,"%2i) %-15s %11d gold\n\r",pnum+1,top_bounty_name[i],(int)top_bounty_value[i]);
devextra.c:	if(IS_NPC(victim) || ch->cabal==CABAL_BOUNTY || ((IS_IMMORTAL(victim) || IS_HEROIMM(victim)) && !IS_IMMORTAL(ch)))
devextra.c:		sprintf(tempstr,"%ld",victim->pcdata->bounty);
devextra.c:		victim->pcdata->bounty=0;
devextra.c:		process_bounty(victim->name,victim->pcdata->bounty);
devextra.c:	if(victim->bounty_timer > 0)
devextra.c:	if(amount > ch->gold)
devextra.c:	famount = amount / (UMAX(calculate_inflation() - 1,1));
devextra.c:	victim->pcdata->bounty += (int)famount;
devextra.c:	ch->gold -= amount;
devextra.c:	sprintf(buf,"Someone has placed a bounty of %.0f gold on the life of %s.",famount,victim->name);
devextra.c:	process_bounty(victim->name, victim->pcdata->bounty);
devextra.c:    sprintf(buf2,"%s places a bounty of %.0f gold on the life of %s.",ch->true_name,famount,victim->name);	
devextra.c:	if(!victim->pcdata->bounty || ch->cabal!=CABAL_BOUNTY)
devextra.c:	sprintf(sbounty,"You claim the bounty on %s's life, receiving %ld gold!\n\r",victim->name,victim->pcdata->bounty);
devextra.c:	ch->gold+=victim->pcdata->bounty;
devextra.c:	credit= (int)((float)victim->pcdata->bounty/(float)1000);
devextra.c:	mod = 2.0 * (float)((float)victim->level / (float)100);
devextra.c:        if(victim->cabal>0)
devextra.c:        if(victim->pcdata->induct)
devextra.c:	bonus = (int)pow(2, victim->pcdata->bounty_killed);
devextra.c:	victim->pcdata->bounty_killed = 0;
devextra.c:	sprintf(buf,"Base - %.2f, Mod - %.2f, Bonus - %.2f", (float)credit, (float)mod, (float)bonus);
devextra.c:	sprintf(sbounty,"%s collects the %ld gold bounty on %s.",ch->name,victim->pcdata->bounty,victim->name);
devextra.c:	sprintf(buf,"%s has collected the %ld gold bounty on the life of %s.",ch->name,victim->pcdata->bounty,victim->true_name);
devextra.c:    victim->pcdata->bounty=0;
devextra.c:	if(victim->cabal == CABAL_BOUNTY && victim->pcdata->bounty_credits)
devextra.c:		sprintf(sbounty,"The guild takes %i of your credits to pay %s.\n\r",lostbounty,ch->name);
devextra.c:		victim->pcdata->bounty_credits -= URANGE(0,lostbounty,5);
devextra.c:	process_bounty(victim->name,victim->pcdata->bounty);
devextra.c:		fprintf(fp,"[%s] %s %s",ttime,ch->name,argument);
devextra.c:	for(loop=numMatches;loop>=1;loop--)
devextra.c:		sprintf(nlist,"%3d) %s\r",numMatches+1-loop,list[loop]);
devextra.c:                if(size>=MAX_BUF || (numMatches-loop)==numEntries)
devextra.c:	int duration = -2, sn=2, nlocation=-2, modifier=0, aftype=-2;
devextra.c:	if(cname[0]=='\0' || skill_name[0]=='\0' || saftype[0]=='\0' || sbitvector[0]=='\0' || duration<-1)
devextra.c:	if((sn=skill_lookup(skill_name))==-1)
devextra.c:	af.level	= ch->level;
devextra.c:	sprintf(returnstr,"%s has been given the %s affect.\n\r",IS_NPC(victim) ? victim->short_descr : victim->name,skill_table[sn].name);
devextra.c:	int type = -1, show = -1, i = 0;
devextra.c:		arg1, arg1, arg1, type > -1 ? "AND type=" : "", type > -1 ? buf : "");
devextra.c:			if ((show != -1 && i > show) || i>300)
devextra.c:		ch->mana-=20;
devextra.c:	if(victim->affected==NULL)
devextra.c:		ch->mana-=40;
devextra.c:	for ( paf = victim->affected; paf != NULL; paf = paf->next )
devextra.c:victim->short_descr : victim->name,skill_table[paf->type].name);
devextra.c:		if(paf->duration>-1)
devextra.c:			showdur=paf->duration+fuzzy;
devextra.c:			showdur=paf->duration-fuzzy;
devextra.c:		sprintf(buf,"%s seems to be affected by %s for about %d hours.\n\r",IS_NPC(victim) ? victim->short_descr :
devextra.c:victim->name,skill_table[paf->type].name,showdur);
devextra.c:		if(paf->duration==-1)
devextra.c:			sprintf(buf,"%s seems to be affected by %s permanently.\n\r",IS_NPC(victim) ? victim->short_descr :
devextra.c:victim->name,skill_table[paf->type].name);
devextra.c:        ch->mana-=40;
devextra.c:    if(ch->Class()->ctype!=CLASS_COMMUNER && !IS_IMMORTAL(ch))
devextra.c:	if ((level = skill_table[sn].skill_level[ch->Class()->GetIndex()]) < LEVEL_HERO + 1
devextra.c:	&&  ch->pcdata->learned[sn] > 0
devextra.c:	    level = skill_table[sn].skill_level[ch->Class()->GetIndex()];
devextra.c:	    if (ch->level < level)
devextra.c:	    	sprintf(buf,"%-18s n/a      ", skill_table[sn].name);
devextra.c:		    100/(2 + ch->level - level));
devextra.c:            sprintf(buf,"%-18s  %3d mana  ",skill_table[sn].name,mana);
devextra.c:    if ( IS_NPC(ch) && ch->desc == NULL)
devextra.c:    if(ch->Class()->ctype!=CLASS_COMMUNER && !IS_IMMORTAL(ch))
devextra.c:    if (IS_SET(ch->act,PLR_BETRAYER))
devextra.c:    if(!IS_NPC(ch) && ch->pcdata->energy_state>3)
devextra.c:    if(!IS_NPC(ch) && ch->pcdata->oalign==3 && ch->alignment==-1000)
devextra.c:    || (!IS_NPC(ch) && ch->pcdata->learned[sn] == 0))
devextra.c:		for(paf = ch->affected; paf != NULL; paf = paf->next)
devextra.c:			if(paf->type == gsn_severed)
devextra.c:			if(skill_table[sn].skill_level[ch->Class()->GetIndex()] > paf->modifier)
devextra.c:    if(skill_table[sn].skill_level[ch->Class()->GetIndex()]>=25 && !IS_SET(ch->act,PLR_EMPOWERED) && !IS_IMMORTAL(ch))
devextra.c:    if ( ch->position < skill_table[sn].minimum_position )
devextra.c:    if (ch->level + 2 == skill_table[sn].skill_level[ch->Class()->GetIndex()])
devextra.c:	    		100 / ( 2 + ch->level - skill_table[sn].skill_level[ch->Class()->GetIndex()] ) );
devextra.c:                 100 / ( 2 + ch->level - skill_table[sn].skill_level[ch->Class()->GetIndex()] ) );
devextra.c:	    if ( ( victim = ch->fighting ) == NULL )
devextra.c:        if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
devextra.c:              if(ch->Class()->GetIndex() == CLASS_ZEALOT && (skill_table[sn].target == TAR_CHAR_DEFENSIVE) && (victim != ch))
devextra.c:	if ( arg2[0] != '\0' && !is_name( target_name, ch->name ) )
devextra.c:	    if ((victim = ch->fighting) == NULL)
devextra.c:            if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
devextra.c:        if((where = direction_lookup(target_name))<0 || !(pexit=ch->in_room->exit[where]))
devextra.c:    if ( !IS_NPC(ch) && ch->mana < mana )
devextra.c:	ch->mana -= mana / 2;
devextra.c:        ch->mana -= mana;
devextra.c:/*	if (IS_SET(ch->in_room->room_flags,ROOM_NO_MAGIC) && !(ch->level > LEVEL_HERO))
devextra.c:	&& (ch->fighting == NULL || victim->fighting == NULL))
devextra.c:                        (*skill_table[sn].spell_fun) ( sn, ch->level*2, victim, ch, target);
devextra.c:            (*skill_table[sn].spell_fun) ( sn, ch->level, ch, vo,target);
devextra.c:    &&   victim->master != ch)
devextra.c:	for ( vch = ch->in_room->people; vch; vch = vch_next )
devextra.c:	    vch_next = vch->next_in_room;
devextra.c:	    if ( victim == vch && victim->fighting == NULL ) 
devextra.c:    if ( IS_NPC(ch) && ch->desc == NULL)
devextra.c:    || (!IS_NPC(ch) && ch->pcdata->learned[sn] == 0))
devextra.c:    if ( ch->position < skill_table[sn].minimum_position && get_trust(ch)<MAX_LEVEL-1)
devextra.c:    if(cabal_down(ch,ch->cabal))
devextra.c:    if (ch->level + 2 == skill_table[sn].skill_level[ch->Class()->GetIndex()])
devextra.c:	    100 / ( 2 + ch->level - skill_table[sn].skill_level[ch->Class()->GetIndex()] ) );
devextra.c:	    if ( ( victim = ch->fighting ) == NULL )
devextra.c:	if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
devextra.c:	if ( arg2[0] != '\0' && !is_name( target_name, ch->name ) )
devextra.c:	    if ((victim = ch->fighting) == NULL)
devextra.c:            if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
devextra.c:        if((where = direction_lookup(target_name))<0 || !(pexit=ch->in_room->exit[where]))
devextra.c:    if ( !IS_NPC(ch) && ch->mana < mana )
devextra.c:	ch->mana -= mana / 2;
devextra.c:        ch->mana -= mana;
devextra.c:			&& (ch->fighting == NULL || victim->fighting == NULL))
devextra.c:                        (*skill_table[sn].spell_fun) ( sn, ch->level*2, victim, ch, target);
devextra.c:            (*skill_table[sn].spell_fun) ( sn, ch->level, ch, vo,target);
devextra.c:    &&   victim->master != ch)
devextra.c:	for ( vch = ch->in_room->people; vch; vch = vch_next )
devextra.c:	    vch_next = vch->next_in_room;
devextra.c:		if ( victim == vch && victim->fighting == NULL ) {
devextra.c:	if(is_affected_room(ch->in_room,gsn_snare))
devextra.c:	if((ch->in_room->sector_type!=SECT_FOREST &&
devextra.c:	   ch->in_room->sector_type!=SECT_MOUNTAIN &&
devextra.c:	   ch->in_room->sector_type!=SECT_DESERT &&
devextra.c:	   ch->in_room->sector_type!=SECT_FIELD &&
devextra.c:	   ch->in_room->sector_type!=SECT_HILLS &&
devextra.c:	   (ch->in_room->vnum==5700 || ch->in_room->cabal))
devextra.c:   	af.level     = ch->level;
devextra.c:	new_affect_to_room(ch->in_room, &af);
devextra.c:  	snaretimer.level     = ch->level;
devextra.c:	sprintf(buf,"%s %s",ch->name,tell);
devextra.c:	do_wear(victim,obj->name);
devextra.c:		send_to_char("Example 1: createcosmetic 'on earlobe' a jewel-encrusted earring\n\rwould produce 'a jewel-encrusted earring' that's <worn on earlobe>\n\r",ch);
devextra.c:		send_to_char("Example 2: createcosmetic under arms 'as undershirt' a plain white t-shirt\n\rwould produce 'a plain white t-shirt' that's <worn as undershirt> and visible only when arms are not covered.\n\r",ch);
devextra.c:		SET_BIT(obj->extra_flags, ITEM_UNDER_CLOTHES);
devextra.c:		SET_BIT(obj->wear_flags, value);
devextra.c:		REMOVE_BIT(obj->wear_flags, ITEM_WEAR_COSMETIC);
devextra.c:	free_pstring(obj->name);
devextra.c:	obj->name = palloc_string(argument);
devextra.c:	free_pstring(obj->short_descr);
devextra.c:	obj->short_descr = palloc_string(argument);
devextra.c:		if(obj->wear_loc_name)
devextra.c:			free_pstring(obj->wear_loc_name);
devextra.c:		obj->wear_loc_name = palloc_string(wlname);
devextra.c:	for(ch = char_list; ch->next; ch = ch->next)
devextra.c:	obj = ch->carrying;
devextra.c:	if(obj->contains)
dioextra.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
dioextra.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
dioextra.c:        for (d = descriptor_list; d; d = d->next)
dioextra.c:            if ( d->connected == CON_PLAYING
dioextra.c:                    &&   d->character != ch
dioextra.c:                    &&   d->character->in_room != NULL
dioextra.c:                    &&   can_see( ch, d->character ) )
dioextra.c:                    d->character->ghost = 15;
dioextra.c:                    send_to_char("You have turned into an invincible ghost for a several minutes.\n\r",d->character);
dioextra.c:                    d->character->ghost = 0;
dioextra.c:                    send_to_char("You are no longer an invincible ghost.\n\r",d->character);
dioextra.c:        for ( d = descriptor_list; d; d = d->next )
dioextra.c:            if ( d->connected == CON_PLAYING
dioextra.c:                    &&   d->character != ch
dioextra.c:                    &&   d->character->in_room != NULL
dioextra.c:                    &&   can_see( ch, d->character )
dioextra.c:                    &&  d->character->in_room->area == ch->in_room->area )
dioextra.c:                    d->character->ghost = 15;
dioextra.c:                    send_to_char("You have turned into an invincible ghost for a several minutes.\n\r",d->character);
dioextra.c:                    d->character->ghost = 0;
dioextra.c:                    send_to_char("You are no longer an invincible ghost.\n\r",d->character);
dioextra.c:        victim->ghost = 15;
dioextra.c:        victim->ghost = 0;
dioextra.c:        if (skill_table[sn].skill_level[victim->Class()->GetIndex()] > 52)
dioextra.c:        if ( victim->level < skill_table[sn].skill_level[victim->Class()->GetIndex()]
dioextra.c:                || victim->pcdata->learned[sn] < 1 /* skill is not known */)
dioextra.c:        sprintf( buf, "%-18s %3d%%  ",
dioextra.c:                 skill_table[sn].name, victim->pcdata->learned[sn] );
dioextra.c:             victim->practice );
dioextra.c:    for ( af = victim->affected; af != NULL; af = af_next )
dioextra.c:        af_next=af->next;
dioextra.c:        if(IS_SET(af->bitvector,AFF_PERMANENT) && get_trust(ch)<MAX_LEVEL && af->type==sn)
dioextra.c:        if(af->type==sn)
dioextra.c:    sprintf(buf,"The %s affect is removed from %s.\n\r",skill_table[sn].name,victim->name);
dioextra.c:    af.level        = ch->level;
dioextra.c:        sprintf(buf,"%s is blessed with %s.\n\r",victim->name,arg2);
dioextra.c:        sprintf(buf,"%s is cursed with %s.\n\r",victim->name,arg2);
dioextra.c:            IS_NPC(ch) ? ch->short_descr : ch->name,
dioextra.c:    for (d = descriptor_list; d != NULL; d = d->next)
dioextra.c:        if (d->connected == CON_PLAYING)
dioextra.c:            if (((d->character != ch) && (!IS_SET(d->character->comm,COMM_NOCABAL)) && (d->character->cabal) && (d->character->cabal == cabal))
dioextra.c:                    || ((IS_SET(d->character->comm,COMM_ALL_CABALS)) && (d->character != ch)))
dioextra.c:                        PERS(ch,d->character),
dioextra.c:                        get_char_color(d->character,"channels"),
dioextra.c:                send_to_char(buf, d->character);
dioextra.c:    if (!ch->cabal) {
dioextra.c:        if ((level = skill_table[sn].skill_level[ch->Class()->GetIndex()]) < LEVEL_HERO + 1
dioextra.c:                &&  ch->pcdata->learned[sn] > 0)
dioextra.c:            level = skill_table[sn].skill_level[ch->Class()->GetIndex()];
dioextra.c:            if (ch->level < level)
dioextra.c:                sprintf(buf,"%-18s n/a      ", skill_table[sn].name);
dioextra.c:                sprintf(buf,"%-18s %3d%%      ",skill_table[sn].name,	ch->pcdata->learned[sn]);
dioextra.c:        af.level = victim->level;
dioextra.c:        af.duration = victim->level / 10;
dioextra.c:        damage_old(victim,ch,(victim->level + 10),gsn_shroud_of_light,DAM_HOLY,TRUE);
dioextra.c:    if (get_trust(ch) < MAX_LEVEL-2) {
dioextra.c:    SET_BIT(victim->act,PLR_HEROIMM);
dioextra.c:    SET_BIT(victim->act,PLR_HOLYLIGHT);
dioextra.c:    victim->max_hit = 10000;
dioextra.c:    victim->hit = victim->max_hit;
dioextra.c:    victim->max_mana = 10000;
dioextra.c:    victim->mana = victim->max_mana;
dioextra.c:    victim->max_move = 10000;
dioextra.c:    victim->move = victim->max_move;
dioextra.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
dioextra.c:        for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
dioextra.c:                if (ch->cabal != gch->cabal && !IS_IMMORTAL(ch)) {
dioextra.c:                for (obj = gch->carrying; obj != NULL; obj = obj_next )
dioextra.c:                    obj_next = obj->next_content;
dioextra.c:                    if ((obj->pIndexData->vnum) && isCabalItem(obj))
dioextra.c:                            sprintf(pbuf,"%s, ",obj->short_descr);
dioextra.c:                                sprintf(pbuf,"%s.",obj->short_descr);
dioextra.c:                                sprintf(pbuf,"and %s.",obj->short_descr);
dioextra.c:        for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
dioextra.c:                if (ch->cabal == gch->cabal || IS_IMMORTAL(ch)) {
dioextra.c:	sprintf(buf1,"%s is the guardian.", guardian->short_descr);
dioextra.c:	for (obj = object_list; obj != NULL; obj = obj->next)
dioextra.c:		if(obj->pIndexData->cabal != guardian->cabal) {
dioextra.c:		if (obj->carried_by!=NULL) {
dioextra.c:				obj->short_descr,
dioextra.c:				IS_NPC(obj->carried_by) ? obj->carried_by->short_descr : obj->carried_by->name);
dioextra.c:    if (!ch->cabal)
dioextra.c:    gn = group_lookup(cabal_table[ch->cabal].name);
dioextra.c:        if (skill_table[sn].skill_level[ch->Class()->GetIndex()] < LEVEL_HERO + 1
dioextra.c:                &&  ch->pcdata->learned[sn] > 0)
dioextra.c:            ch->pcdata->learned[sn] = -2;
dioextra.c:    group_remove(ch,cabal_table[ch->cabal].name);
dioextra.c:    ch->cabal = 0;
dioextra.c:    if (!IS_NPC(victim) && victim->level >= get_trust(ch))
dioextra.c:            victim->wait = 0;
dioextra.c:    if (ch->Class()->ctype == CLASS_COMMUNER)
dioextra.c:    return -1;
dioextra.c:    int align = -1, class_index = -1, ethos = -1, kills = -1, gkills = -1, nkills = -1, ekills = -1;
dioextra.c:    int	pkilled	= -1, mkilled = -1, level = -1, played = -1, cabal = 0, induct = -1, race = -1;
dioextra.c:    int con = 0, stat = 25, died = 0,agemod = 0, bcredits = 0, hometown = 0, aobj = -1, lobj = -1, timeplayed = -1;
dioextra.c:    int i, x = 0, born = 0, dtime = 0, souls = -1;
dioextra.c:                    sprintf(buf2,"%s%s (%d)\n\r",get_where_name(i), pObjIndex ? pObjIndex->short_descr : "# NON-EXISTANT #", vnum);
dioextra.c:                while((i=fread_number(fp))!=-1)
dioextra.c:        if(level >= ch->level) {
dioextra.c:                strcat(questtext," -- ");
dioextra.c:                strcat(questtext,quest_table[i].stages[quests[i]-1]);
dioextra.c:                dead && IS_SET(act,PLR_DENY) && con < CON_DIE_BOUND ? "  *** CON-DEAD CHARACTER: ***\n\r" :
dioextra.c:                dead && died == HAS_DIED ? "  *** AGE-DEAD CHARACTER: ***\n\r" :
dioextra.c:                (RSTR)CClass::GetClass(class_index)->who_name,
dioextra.c:        sprintf(buf2,"  Align: %-16s Ethos: %-20s Sex:  %s\n\r",
dioextra.c:        sprintf(buf3,"%d (b%d)",time_info.year - born, born);
dioextra.c:        sprintf(buf2,"  Hours: %-16s Age:   %-20s Objs: %d (%d L)\n\r",
dioextra.c:        sprintf(buf2,"  Town:  %-16s Flag: %-21s Room: %d\n\r",
dioextra.c:        sprintf(buf2,"  PKr:   %-16s ",buf3);
dioextra.c:        sprintf(buf2,"PKs:   %-20s MOBd: %d\n\r",buf3,mkilled);
dioextra.c:            perc[2] = 100 - perc[1] - perc[0];
dioextra.c:    ch->last_fight_time = current_time;
dioextra.c:    ch->last_fight_name = ch2->true_name;
dioextra.c:    ch2->last_fight_time = current_time;
dioextra.c:    ch2->last_fight_name = ch->true_name;
dioextra.c:        for (counter = 0; counter < (int)(strlen(results) - 10); counter++)
dioextra.c:    str[strlen(str)-1] = '\0';
dioextra.c:    for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
dioextra.c:        if (limited && obj->pIndexData->limtotal <= 0)
dioextra.c:    for (d = descriptor_list; d != NULL; d = d->next)
dioextra.c:        if (d == d_check || d->character == NULL)
dioextra.c:        if (!str_cmp(host,d->host))
dioextra.c:    d->character->desc = NULL;
dioextra.c:    d->character->next = char_list;
dioextra.c:    char_list = d->character;
dioextra.c:    d->outsize = 2000;
dioextra.c:    d->outbuf = new char [d->outsize];
dioextra.c:    d->connected = CON_PLAYING;
dioextra.c:    reset_char(d->character);
dioextra.c:    victim = d->character;
dioextra.c:    d->character->pcdata->host = palloc_string("PLOAD");
dioextra.c:    if (ch->fighting == victim)
dioextra.c:    if (victim->fighting == ch)
dioextra.c:    for (d = descriptor_list; d; d = d->next)
dioextra.c:        if (d->connected == CON_PLAYING
dioextra.c:                &&  d->character->in_room != NULL
dioextra.c:                &&  d->character->in_room->area == area)
dioextra.c:            colorconv(buffer,echo,d->character);
dioextra.c:            send_to_char(buffer,d->character);
dioextra.c:            send_to_char("\n\r",d->character);
dioextra.c:    for (room = room_list; room != NULL; room = room->next_room)
dioextra.c:        if (room->area != area)
dioextra.c:            if ((pexit = room->exit[dir]) != NULL)
dioextra.c:                if ((to_room = pexit->u1.to_room) != NULL)
dioextra.c:                    if (to_room->area == area2)
dioextra.c:        if (area->adjacent[i] == area2)
dioextra.c:        if(range > 1 && area!=NULL && area->adjacent[i]!=NULL)
dioextra.c:            range -= 1;
dioextra.c:            if(is_adj_range(area->adjacent[i], area2, range))
dioextra.c:        if (area->adjacent[i] == area2)
druid.c:	if(obj->value[0] != 0)
druid.c:	if(obj->item_type != ITEM_STONE)
druid.c:		obj->value[0] = 1;
druid.c:   		obj->value[0] = 2;
druid.c:		obj->value[0] = 3;
druid.c:	charges = (ch->level * .8);		// number of uses stonesyield, stored in V1
druid.c:	obj->value[1] = charges;
druid.c:	oaf.duration = (336 - ((ch->level -51) * 5));
druid.c:	oaf.level = ch->level;
druid.c:	af.level = ch->level;
druid.c:	int dam = (int)((float)((float)ch->level * (float).6) + (dice(10, (int)(level/4))));
druid.c:	act("The ground beneath your feet begins to rumble.",ch->in_room->people,NULL,NULL,TO_ALL);
effects.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
effects.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
effects.c:	for (obj = room->contents; obj != NULL; obj = obj_next)
effects.c:	    obj_next = obj->next_content;
effects.c:	for (obj = victim->carrying; obj != NULL; obj = obj_next)
effects.c:	    obj_next = obj->next_content;
effects.c:	    chance = (chance - 25) / 2 + 25;
effects.c:	    chance = (chance - 50) / 2 + 50;
effects.c:	    chance -= 5;
effects.c:	chance -= obj->level * 2;
effects.c:	switch (obj->item_type)
effects.c:		chance -= 10;
effects.c:	if (obj->carried_by != NULL)
effects.c:	    act(msg,obj->carried_by,obj,NULL,TO_ALL);
effects.c:	else if (obj->in_room != NULL && obj->in_room->people != NULL)
effects.c:	    act(msg,obj->in_room->people,obj,NULL,TO_ALL);
effects.c:	if (obj->item_type == ITEM_ARMOR)  /* etch it */
effects.c:	    for ( paf = obj->affected; paf != NULL; paf = paf->next)
effects.c:                if ( paf->location == APPLY_AC)
effects.c:                    paf->type = -1;
effects.c:                    paf->modifier += 1;
effects.c:                    paf->level = UMAX(paf->level,level);
effects.c:                paf->type       = -1;
effects.c:                paf->level      = level;
effects.c:                paf->duration   = -1;
effects.c:                paf->location   = APPLY_AC;
effects.c:                paf->modifier   =  1;
effects.c:                paf->next       = obj->affected;
effects.c:                obj->affected   = paf;
effects.c:            if (obj->carried_by != NULL && obj->wear_loc != WEAR_NONE)
effects.c:                    obj->carried_by->armor[i] += 1;
effects.c:	if (obj->contains)  /* dump contents */
effects.c:	    for (t_obj = obj->contains; t_obj != NULL; t_obj = n_obj)
effects.c:		n_obj = t_obj->next_content;
effects.c:		if (obj->in_room != NULL)
effects.c:		    obj_to_room(t_obj,obj->in_room);
effects.c:		else if (obj->carried_by != NULL)
effects.c:		    obj_to_room(t_obj,obj->carried_by->in_room);
effects.c:        for (obj = room->contents; obj != NULL; obj = obj_next)
effects.c:            obj_next = obj->next_content;
effects.c:            af.modifier  = -1;
effects.c:	for (obj = victim->carrying; obj != NULL; obj = obj_next)
effects.c:	    obj_next = obj->next_content;
effects.c:	    chance = (chance - 25) / 2 + 25;
effects.c:	    chance = (chance - 50) / 2 + 50;
effects.c:	    chance -= 5;
effects.c: 	chance -= obj->level * 2;
effects.c:	switch(obj->item_type)
effects.c:	if (obj->carried_by != NULL)
effects.c:	    act(msg,obj->carried_by,obj,NULL,TO_ALL);
effects.c:	else if (obj->in_room != NULL && obj->in_room->people != NULL)
effects.c:	    act(msg,obj->in_room->people,obj,NULL,TO_ALL);
effects.c:	for (obj = room->contents; obj != NULL; obj = obj_next)
effects.c:	    obj_next = obj->next_content;
effects.c:            af.modifier     = -4;
effects.c:	for (obj = victim->carrying; obj != NULL; obj = obj_next)
effects.c:	    obj_next = obj->next_content;
effects.c:            chance = (chance - 25) / 2 + 25;
effects.c:            chance = (chance - 50) / 2 + 50;
effects.c:            chance -= 5;
effects.c:        chance -= obj->level * 2;
effects.c:        switch ( obj->item_type )
effects.c:	if (obj->carried_by != NULL)
effects.c:            act( msg, obj->carried_by, obj, NULL, TO_ALL );
effects.c:	else if (obj->in_room != NULL && obj->in_room->people != NULL)
effects.c:	    act(msg,obj->in_room->people,obj,NULL,TO_ALL);
effects.c:        if (obj->contains)
effects.c:            for (t_obj = obj->contains; t_obj != NULL; t_obj = n_obj)
effects.c:                n_obj = t_obj->next_content;
effects.c:		if (obj->in_room != NULL)
effects.c:                    obj_to_room(t_obj,obj->in_room);
effects.c:		else if (obj->carried_by != NULL)
effects.c:		    obj_to_room(t_obj,obj->carried_by->in_room);
effects.c:        for (obj = room->contents; obj != NULL; obj = obj_next)
effects.c:            obj_next = obj->next_content;
effects.c:            af.modifier  = -1;
effects.c:	for (obj = victim->carrying; obj != NULL; obj = obj_next)
effects.c:	    obj_next = obj->next_content;
effects.c:	    chance = (chance - 25) / 2 + 25;
effects.c:	    chance = (chance - 50) / 2 + 50;
effects.c:	chance -= obj->level * 2;
effects.c:	switch (obj->item_type)
effects.c:		if (obj->value[0] == obj->value[1])
effects.c:	obj->value[3] = 1;
effects.c:	for (obj = room->contents; obj != NULL; obj = obj_next)
effects.c:	    obj_next = obj->next_content;
effects.c:	for (obj = victim->carrying; obj != NULL; obj = obj_next)
effects.c:	    obj_next = obj->next_content;
effects.c:	    chance = (chance - 25) / 2 + 25;
effects.c:	    chance = (chance - 50) /2 + 50;
effects.c:	    chance -= 5;
effects.c: 	chance -= obj->level * 2;
effects.c:	switch(obj->item_type)
effects.c:		chance -= 10;
effects.c:	if (obj->carried_by != NULL)
effects.c:	    act(msg,obj->carried_by,obj,NULL,TO_ALL);
effects.c:	else if (obj->in_room != NULL && obj->in_room->people != NULL)
effects.c:	    act(msg,obj->in_room->people,obj,NULL,TO_ALL);
fight.c:*       ROM 2.4 is copyright 1993-1996 Russ Taylor                         *
fight.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
fight.c:*            Riftshadow MUD code copyright (c) 2000-2001 and is			   *
fight.c:    for ( ch = char_list; ch != NULL; ch = ch->next )
fight.c:        ch_next = ch->next;
fight.c:	if (ch->regen_rate != 0)
fight.c:		if (ch->regen_rate > 0)
fight.c:			ch->hit = UMIN(ch->hit + number_range(1,ch->regen_rate),ch->max_hit);
fight.c:			ch->hit = UMIN(ch->hit - number_range(1,ch->regen_rate),ch->max_hit);
fight.c:	if (ch->fighting != NULL) {
fight.c:		check_analyze(ch,ch->fighting);
fight.c:			check_style_improve(ch,ch->pcdata->style,6);
fight.c:		ch->balance = UMAX(ch->balance - 4,0);
fight.c:		ch->balance = UMAX(ch->balance - 3,0);
fight.c:		af = affect_find(ch->affected, gsn_unbalance);
fight.c:		af->modifier--;
fight.c:		if (af->modifier < 0)
fight.c:        if ( ( victim = ch->fighting ) == NULL || ch->in_room == NULL )
fight.c:	if (IS_NPC(ch) && (!IS_NPC(ch->fighting))
fight.c:	&& !IS_SET(ch->off_flags,NO_TRACK)
fight.c:	&& !IS_SET(ch->act,ACT_IS_HEALER)
fight.c:	&& !IS_SET(ch->act,ACT_BANKER)) {
fight.c:		ch->last_fought = ch->fighting;
fight.c:		ch->tracktimer = 144;
fight.c:	update_pc_last_fight(ch,ch->fighting);
fight.c:        if ( IS_AWAKE(ch) && ch->in_room == victim->in_room )
fight.c:        if ( ( victim = ch->fighting ) == NULL )
fight.c:	for (obj = ch->carrying;obj != NULL; obj = obj->next_content)
fight.c:	   if(ch->Class()->GetIndex() == CLASS_PALADIN && obj->item_type == ITEM_WEAPON && is_worn(obj))
fight.c:   	   if (IS_SET(obj->progtypes,IPROG_FIGHT))
fight.c:		(obj->pIndexData->iprogs->fight_prog) (obj,ch);
fight.c:	if (IS_SET(ch->progtypes,MPROG_FIGHT) && (ch->wait <= 0))
fight.c:	   	(ch->pIndexData->mprogs->fight_prog) (ch,victim);
fight.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch_next)
fight.c:        rch_next = rch->next_in_room;
fight.c:	if (!IS_NPC(rch) && rch->ghost > 0)
fight.c:	if (IS_NPC(rch) && rch->pIndexData->vnum == ACADEMY_PET && ch->ghost > 0)
fight.c:        if (IS_AWAKE(rch) && rch->fighting == NULL)
fight.c:			if((rch->pIndexData->vnum == 2979) && (number_percent() > 50)) {
fight.c:				do_gore(rch,victim->name);
fight.c:       	&& IS_SET(rch->off_flags,ASSIST_PLAYERS)
fight.c:       	&&  rch->level + 6 > victim->level)
fight.c:			if (rch->defending != NULL)
fight.c:				fch = ch->fighting;
fight.c:				if (rch->defending != NULL
fight.c:				&& rch->defending == ch
fight.c:				&& fch->fighting == ch
fight.c:            if ( ( (!IS_NPC(rch) && IS_SET(rch->act,PLR_AUTOASSIST))
fight.c:					sprintf(store,"Help!  %s is assisting %s!", rch->name, ch->name);
fight.c:					victim->law_pass = TRUE;
fight.c:                if ( (IS_NPC(rch) && IS_SET(rch->off_flags,ASSIST_ALL))
fight.c:                ||   (IS_NPC(rch) && rch->group && rch->group == ch->group
fight.c:				     && IS_SET(rch->off_flags, ASSIST_GROUP))
fight.c:                ||   (IS_NPC(rch) && rch->race == ch->race
fight.c:                   		     && IS_SET(rch->off_flags,ASSIST_RACE))
fight.c:                ||   (IS_NPC(rch) && IS_SET(rch->off_flags,ASSIST_ALIGN)
fight.c:                ||   (rch->pIndexData == ch->pIndexData
fight.c:		                     && IS_SET(rch->off_flags,ASSIST_VNUM)))
fight.c:		    for(vch = ch->in_room->people; vch; vch = vch->next)
fight.c:                    for (vch = ch->in_room->people; vch; vch = vch->next)
fight.c:			sprintf(buf,rch->short_descr);
fight.c:			if(!str_prefix("a ",rch->short_descr))
fight.c:			else if(!str_prefix("the ",rch->short_descr))
fight.c:    if (ch->desc == NULL)
fight.c:        ch->wait = UMAX(0,ch->wait - PULSE_VIOLENCE);
fight.c:	if (ch->level == MAX_LEVEL) 
fight.c:		ch->wait = 0;
fight.c:    if(ch->in_room!=victim->in_room)
fight.c:		ch->fighting=NULL;
fight.c:		victim->fighting=NULL;
fight.c:		ch->position=POS_STANDING;
fight.c:		victim->position=POS_STANDING;
fight.c:    if(!IS_NPC(victim) && victim->pcdata->entering_text && IS_SET(victim->act, PLR_AUTOABORT)) {
fight.c:     	if(victim->pcdata->end_fun)
fight.c:     		(*victim->pcdata->end_fun) (victim, victim->pcdata->entered_text);
fight.c:           	victim->pcdata->entering_text = FALSE;
fight.c:        	victim->pcdata->end_fun = NULL;
fight.c:	/* no attacks for stunnies -- just a check */
fight.c:    if (ch->position < POS_RESTING)
fight.c:		ch->cabal==victim->cabal) {
fight.c:		sprintf(buf,"How DARE you attack me, %s!",ch->name);
fight.c:	attacks = number_range(1,form_table[ch->pcdata->shifted].attacks);
fight.c:		attacks--;
fight.c:	attacks	= URANGE(1,attacks,form_table[ch->pcdata->shifted].attacks);
fight.c:    if ( ch->fighting != victim || dt == gsn_backstab || (dt ==  gsn_ambush) )
fight.c:		if (check_posture(ch) == POSTURE_DEFENSE && style_check(gsn_posture, ch->pcdata->style)) {
fight.c:       		if ( ch->fighting != victim ) return;
fight.c:	&& ch->pcdata->learned[gsn_second_attack] > 10) {
fight.c:			if (ch->fighting != victim) return;
fight.c:    if (ch->pcdata->learned[gsn_second_attack] > 10) {
fight.c:        	if ( ch->fighting != victim)	return;
fight.c:		&& ch->pcdata->learned[gsn_third_attack] > 10) {
fight.c:				if (ch->fighting != victim)	return;
fight.c:	if (ch->pcdata->learned[gsn_third_attack] > 10) {
fight.c:			if (ch->fighting != victim ) return;
fight.c:			ch->pcdata->learned[gsn_fourth_attack] > 10) {
fight.c:				if (ch->fighting != victim) return;
fight.c:		if (style_check(gsn_fifth_attack,ch->pcdata->style)) {
fight.c:		    chance = get_skill(ch,gsn_fifth_attack)/4 + (get_curr_stat(ch,STAT_DEX) - 18) * 3;
fight.c:				if (ch->fighting != victim )	return;
fight.c:			 ch->pcdata->learned[gsn_fifth_attack] > 10) {
fight.c:					if (ch->fighting != victim) return;
fight.c:		style_check(gsn_posture, ch->pcdata->style)) {
fight.c:    if (ch->fighting != victim)
fight.c:    /* Area attack -- BALLS nasty! */
fight.c:    if (IS_SET(ch->off_flags,OFF_AREA_ATTACK))
fight.c:        for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
fight.c:            vch_next = vch->next;
fight.c:            if ((vch != victim && vch->fighting == ch))
fight.c:    if (IS_AFFECTED(ch,AFF_HASTE) || (IS_SET(ch->off_flags,OFF_FAST) &&
fight.c:    if (ch->fighting != victim || dt == gsn_backstab)
fight.c:    dual_chance = ch->level*2/3;
fight.c:    if (IS_AFFECTED(ch,AFF_SLOW) && !IS_SET(ch->off_flags,OFF_FAST))
fight.c:        if (ch->fighting != victim)
fight.c:	if (ch->fighting != victim)
fight.c:        if (ch->fighting != victim)
fight.c:	if (ch->fighting != victim)
fight.c:    if (ch->wait > 0)
fight.c:	if (IS_SET(ch->act,ACT_INTELLIGENT))
fight.c:		switch (ch->pIndexData->Class()->GetIndex()) {
fight.c:				warrior_ai(ch, ch->fighting);
fight.c:				thief_ai(ch, ch->fighting);
fight.c:        if (IS_SET(ch->off_flags,OFF_BASH))
fight.c:	else if (IS_SET(ch->off_flags,OFF_TAIL))
fight.c:        if (IS_SET(ch->off_flags,OFF_BERSERK) && !IS_AFFECTED(ch,AFF_BERSERK))
fight.c:        if (IS_SET(ch->off_flags,OFF_DISARM))
fight.c:        if (IS_SET(ch->off_flags,OFF_KICK))
fight.c:        if (IS_SET(ch->off_flags,OFF_KICK_DIRT))
fight.c:        if (IS_SET(ch->off_flags,OFF_TAIL))
fight.c:        if (IS_SET(ch->off_flags,OFF_TRIP))
fight.c:/* De-Ceranized by Cal on 10/24/01 
fight.c:	   || victim->position == POS_DEAD
fight.c:	   || (ch->in_room != victim->in_room && dt != gsn_hurl)
fight.c:		if ( wield != NULL && wield->item_type == ITEM_WEAPON )
fight.c:			dt += wield->value[3];
fight.c:			dt += ch->dam_type;
fight.c:		dam_type = attack_table[wield->value[3]].damage;
fight.c:		dam_type = attack_table[ch->dam_type].damage;
fight.c:	if (dam_type == -1)
fight.c:            dam = dice(ch->damage[DICE_NUMBER],ch->damage[DICE_TYPE]);
fight.c:		if (sn != -1)
fight.c:			dam = dice(wield->value[1],wield->value[2]) * skill/100;
fight.c:			if (wield->level - ch->level >= 35)
fight.c:			else if (wield->level - ch->level >= 25)
fight.c:			else if (wield->level - ch->level >= 15)
fight.c:			else if (wield->level - ch->level >= 5)
fight.c:			dam = number_range( 1 + 4 * skill/100, 2 * ch->level/3 * skill/100);
fight.c:		if (ch->Class()->name == "thief")
fight.c:		   && style_check(gsn_brutality, ch->pcdata->style)
fight.c:		   && ((wield != NULL) && (wield->weight >= 15)))
fight.c:	    && (af = affect_find(ch->affected, gsn_hardenfist)))
fight.c:			dam = (dice((af->level/4), 4) + 10) * skill/100;
fight.c:		dam *= pc_race_table[ch->race].racialDam;
fight.c:	   && ch->pcdata->tribe == TRIBE_BOAR && number_percent()<10)
fight.c:		dam *= ch->level/20;
fight.c:	if(wield && ch->Class()->GetIndex() == CLASS_PALADIN 
fight.c:	if(result == -1) //death
fight.c:		return -1;
fight.c:	if (wield && IS_SET(wield->progtypes, IPROG_HIT))
fight.c:		(wield->pIndexData->iprogs->hit_prog) (wield, ch, victim, result);
fight.c:		if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_POISON))
fight.c:            	if ((poison = affect_find_obj(wield->affected,gsn_poison)) == NULL)
fight.c:                		level = wield->level;
fight.c:                		level = poison->level;
fight.c:                		af.modifier  = -3;
fight.c:				poison->level = UMAX(0,poison->level - 2);
fight.c:				poison->duration = UMAX(0,poison->duration - 1);
fight.c:				if (poison->level == 0 || poison->duration == 0)
fight.c:    if ( victim->position == POS_DEAD )
fight.c:		dam *= (ch->level + 49);
fight.c:    if ( victim != ch && ch->in_room == victim->in_room)
fight.c:        if ( victim->position > POS_STUNNED &&
fight.c:			 dnoun[strlen(dnoun)-1] == '*')) {
fight.c:            if ( victim->fighting == NULL )
fight.c:            if (victim->timer <= 4)
fight.c:                victim->position = POS_FIGHTING;
fight.c:        if ( victim->position > POS_STUNNED && victim != ch) {
fight.c:            if ( ch->fighting == NULL &&
fight.c:				 dnoun && dnoun[strlen(dnoun)-1] == '*'))
fight.c:        if ( victim->master == ch && !(dnoun && dnoun[strlen(dnoun)-1] == '*'))
fight.c:		 ch->in_room == victim->in_room && dam>0)  {
fight.c:		for (gch = ch->in_room->people; gch; gch = gch->next_in_room)
fight.c:		ch->batter = 0;
fight.c:		for(laf = victim->affected; laf != NULL; laf = laf->next)
fight.c:			if(laf->type == gsn_empathy)
fight.c:		damage_new(ch,laf->owner,(int)((float)dam*.25),gsn_empathy,DAM_INTERNAL,
fight.c:		victim->mana += (short)dam / 10;
fight.c:    if (is_affected(victim,gsn_diamondskin) && (daf = affect_find(victim->affected, gsn_diamondskin))) 
fight.c:	diamondskin = daf->modifier;
fight.c:		if (diamondskin > 500 && diamondskin - dam < 500)
fight.c:		    send_to_char("Your diamond skin begins to fracture - it may not hold much longer.\n\r",victim);
fight.c:		daf->modifier -= (short)dam;
fight.c:		diamondskin -= (short)dam;
fight.c:		    damage_new(victim,victim,victim->max_hit/2,gsn_diamondskin,DAM_TRUESTRIKE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,NULL);
fight.c:			if (victim->ghost > 0)
fight.c:		af = affect_find(victim->affected,gsn_holy_shroud);
fight.c:		if(af->owner == victim && IS_EVIL(ch))
fight.c:		if(af->owner == victim && !IS_EVIL(ch))
fight.c:		if(af->owner != victim && IS_EVIL(ch))
fight.c:		if(af->owner != victim && !IS_EVIL(ch))
fight.c:		&& (af = affect_find(ch->affected,gsn_divine_ward)) != NULL
fight.c:		&& af->owner == victim
fight.c:		if (af->modifier == 1)
fight.c:		else if (af->modifier == 2)
fight.c:	if (!IS_NPC(victim) && victim->pcdata->greaterdata[GREATER_CIMERIES] >=2)
fight.c:		&& IS_SET(victim->act,PLR_BETRAYER)
fight.c:		dam *= victim->dam_mod;
fight.c:    if(dam > 1 && !IS_NPC(victim) && victim->pcdata->condition[COND_DRUNK] > 10)
fight.c:        dam -= dam / 4;
fight.c:        	dam -= dam/3;
fight.c:			dam -= dam/3;
fight.c:    if(wield && IS_SET(victim->vuln_flags, VULN_IRON) && !str_cmp(wield->material,"iron"))
fight.c:    if(wield && IS_SET(victim->vuln_flags, VULN_MITHRIL) && !str_cmp(wield->material,"mithril"))
fight.c:			kineticdam = dice(victim->level / 12, 6);
fight.c:			kineticdam = dice(victim->level / 12, 6);
fight.c:	AFFECT_DATA *paf = affect_find(ch->affected, gsn_retribution);
fight.c:	if(paf && paf->owner == victim)
fight.c:		paf->modifier = UMIN((int)dam + paf->modifier, paf->owner->level * 8);
fight.c:    victim->hit -= (short)dam;
fight.c:    &&   victim->level >= LEVEL_IMMORTAL
fight.c:    &&   victim->hit < 1 )
fight.c:        victim->hit = 1;
fight.c:    switch( victim->position )
fight.c:        if ( dam > victim->max_hit / 4 ) {
fight.c:        if ( victim->hit < victim->max_hit / 4 ) {
fight.c:    if ( victim->position == POS_DEAD )
fight.c:                victim->name,
fight.c:                (IS_NPC(ch) ? ch->short_descr : ch->name),
fight.c:                ch->in_room->vnum );
fight.c:        &&  (corpse = get_obj_list(ch,"corpse",ch->in_room->contents)) != NULL
fight.c:        &&  corpse->item_type == ITEM_CORPSE_NPC && can_see_obj(ch,corpse))
fight.c:            corpse = get_obj_list( ch, "corpse", ch->in_room->contents );
fight.c:            if ( IS_SET(ch->act, PLR_AUTOLOOT) &&
fight.c:                 corpse && corpse->contains) /* exists and not empty */
fight.c:            if (IS_SET(ch->act,PLR_AUTOGOLD) &&
fight.c:                corpse && corpse->contains  && /* exists and not empty */
fight.c:                !IS_SET(ch->act,PLR_AUTOLOOT))
fight.c:                if ((coins = get_obj_list(ch,"gcash",corpse->contains)) != NULL)
fight.c:            if ( IS_SET(ch->act, PLR_AUTOSAC) )
fight.c:              if ( IS_SET(ch->act,PLR_AUTOLOOT) && corpse && corpse->contains)
fight.c:	return -1; //death
fight.c:    if(ch->in_room != victim->in_room || dt == gsn_parting_blow)
fight.c:    if ( IS_NPC(victim) && dam > 0 && victim->wait < 1 /* same thing on pcs...is this right? PULSE_VIOLENCE / 2 */)
fight.c:        if ( (( IS_SET(victim->act, ACT_WIMPY) && number_bits( 2 ) == 0
fight.c:        &&   victim->hit < victim->max_hit / 5))
fight.c:        ||   (( IS_AFFECTED(victim, AFF_CHARM) && victim->master != NULL
fight.c:        &&     victim->master->in_room != victim->in_room)
fight.c:    &&   victim->hit > 0
fight.c:    &&   victim->hit <= victim->wimpy
fight.c:    &&   victim->wait < 1 
fight.c:    if (victim->invis_level >= LEVEL_HERO)
fight.c:    if (victim->in_room == NULL)
fight.c:    if (is_affected(ch, gsn_shroud_of_light) && !ch->fighting)
fight.c:    if ((IS_NPC(ch) && IS_SET(ch->act,ACT_WARD_MOB))
fight.c:		|| (IS_NPC(victim) && IS_SET(victim->act,ACT_WARD_MOB)))
fight.c:    if (IS_NPC(ch) && victim->invis_level >= LEVEL_HERO)
fight.c:	if (IS_NPC(victim) && IS_SET(victim->act, ACT_IS_HEALER))
fight.c:		if (ch->pcdata->death_status == HAS_DIED)
fight.c:		if (victim->pcdata->death_status == HAS_DIED)
fight.c:		&& !IS_AFFECTED(victim,AFF_CHARM) && !ch->desc
fight.c:		&& !ch->hunting && !victim->hunting && victim!=ch
fight.c:		&& ch->fighting != victim
fight.c:		&& victim->fighting != ch
fight.c:		&& !ch->desc && !victim->desc)
fight.c:/* Handle Link dead players , only saves from PKS, not mobs -Ceran */
fight.c:    if (!IS_NPC(victim) && victim->desc == NULL && !IS_NPC(ch)
fight.c:		&& victim->fighting != ch && ch->fighting != victim) {
fight.c:    if (IS_IMMORTAL(ch) && !victim->ghost)
fight.c:    if (victim->fighting == ch || victim == ch)
fight.c:    if (IS_NPC(ch) && ch->last_fought == victim)
fight.c:    if ((victim->ghost > 0)
fight.c:    if (ch->ghost > 0) {
fight.c:        if (IS_AFFECTED(victim,AFF_CHARM) && victim->master != NULL
fight.c:			&& !IS_NPC(victim->master)) {
fight.c:				&& victim->master
fight.c:				&& !can_pk(ch,victim->master))
fight.c:				&& !can_pk(ch->master,victim->master))
fight.c:            if (IS_AFFECTED(ch,AFF_CHARM) && ch->master != NULL
fight.c:            	&&  ch->master->fighting != victim) 
fight.c:	if(victim && IS_SET(victim->in_room->area->progtypes, APROG_AGGRESS))
fight.c:		((victim->in_room->area->aprogs->aggress_prog) (victim->in_room->area, ch, victim));
fight.c:	if(victim && IS_SET(victim->progtypes,MPROG_AGGRESS))
fight.c:		if (((victim->pIndexData->mprogs->aggress_prog) (victim,ch)) == TRUE)
fight.c:    if (victim->in_room == NULL || ch->in_room == NULL)
fight.c:    if (victim->fighting == ch || victim == ch)
fight.c:    if (IS_IMMORTAL(ch) && ch->level > LEVEL_IMMORTAL && !area)
fight.c:    if (!IS_NPC(victim) && victim->pcdata->newbie==TRUE && !IS_NPC(ch))
fight.c:    if (!IS_NPC(ch) && ch->pcdata->newbie==TRUE && !IS_NPC(victim))
fight.c:        if (IS_SET(victim->in_room->room_flags,ROOM_SAFE))
fight.c:        if (victim->pIndexData->pShop != NULL)
fight.c:        if (IS_SET(victim->act,ACT_TRAIN)
fight.c:        ||  IS_SET(victim->act,ACT_PRACTICE)
fight.c:        ||  IS_SET(victim->act,ACT_IS_HEALER))
fight.c:            if (IS_SET(victim->act,ACT_PET))
fight.c:            if (IS_AFFECTED(victim,AFF_CHARM) && (area || ch != victim->master))
fight.c:            /* legal kill? -- cannot hit mob fighting non-group member */
fight.c:            if (victim->fighting != NULL && !is_same_group(ch,victim->fighting))
fight.c:            if (area && !is_same_group(victim,ch->fighting))
fight.c:        if (area && IS_IMMORTAL(victim) && victim->level > LEVEL_IMMORTAL)
fight.c:            if (IS_AFFECTED(ch,AFF_CHARM) && ch->master != NULL
fight.c:            &&  ch->master->fighting != victim)
fight.c:            if (IS_SET(victim->in_room->room_flags,ROOM_SAFE))
fight.c:            /* legal kill? -- mobs only hit players grouped with opponent*/
fight.c:            if (ch->fighting != NULL && !is_same_group(ch->fighting,victim))
fight.c:            if (IS_SET(victim->act,PLR_KILLER) || IS_SET(victim->act,PLR_THIEF))
fight.c:            if (ch->level > victim->level + 8)
fight.c:			armor = victim->armor[AC_BASH]; break;
fight.c:			armor = victim->armor[AC_SLASH]; break;
fight.c:			armor = victim->armor[AC_PIERCE]; break;
fight.c:			armor = victim->armor[AC_EXOTIC]; break;
fight.c:	chance  = -((.00075 * pow(armor,3) - .275 * pow(armor,2) + 1) / 100);
fight.c:	if((wield = get_eq_char(ch,WEAR_WIELD)) && wield->weight>=10)
fight.c:		chance *= 1 - ((float)wield->weight/100.001);
fight.c:    if (IS_AFFECTED(ch, AFF_HASTE))		chance-=15;
fight.c:    chance += ch->defense_mod;
fight.c:    if (!IS_NPC(ch) && abs(ch->pcdata->energy_state)>1)
fight.c:		chance-= pow(3,abs(ch->pcdata->energy_state));
fight.c:	chance-=5*abs((ch->size-victim->size));
fight.c:		switch (wield->value[0]) {
fight.c:			case (WEAPON_DAGGER): 	chance-=5;		break;
fight.c:			case (WEAPON_MACE):		chance-=10;		break;
fight.c:			case (WEAPON_AXE):		chance-=10;		break;
fight.c:			case (WEAPON_POLEARM):	chance-=5;		break;
fight.c:	    switch (victimwield->value[0]) {
fight.c:			case (WEAPON_DAGGER): 	chance-=20;		break;
fight.c:			case (WEAPON_MACE):		chance-=10;		break;
fight.c:			case (WEAPON_AXE):		chance-=10;		break;
fight.c:			case (WEAPON_FLAIL):	chance-=10;		break;
fight.c:			case (WEAPON_WHIP):		chance-=20;		break;
fight.c:			default: 				chance-=20;		break;
fight.c:		if (check_posture(ch) == POSTURE_DEFENSE && style_check(gsn_posture, ch->pcdata->style))
fight.c:		if (check_posture(victim) == POSTURE_DEFENSE && style_check(gsn_posture, victim->pcdata->style))
fight.c:		if (check_posture(victim) == POSTURE_OFFENSE && style_check(gsn_posture, victim->pcdata->style))
fight.c:			chance -= 20;
fight.c:	if (IS_EVIL(victim) && (ch->level > victim->level) && is_affected(ch, gsn_awe))
fight.c:		chance -= 10;	
fight.c:	chance -= victim->balance;
fight.c:	chance += ch->balance;
fight.c:	chance -= ch->batter;
fight.c:	chance -= ch->analyze;
fight.c:	if (victim->analyzePC == ch) 	chance += victim->analyze;
fight.c:	if (!IS_NPC(victim) && IS_SET(victim->act,PLR_MORON))
fight.c:	chance+=form_table[ch->pcdata->shifted].parry_modifier;
fight.c:    chance*=(1-((float)GET_HITROLL(ch) / (float) 250));
fight.c:	diff = (int)((float)chance - (float)roll);
fight.c:    if(IS_SET(victim->wiznet,WIZ_PERCENT))
fight.c:    if(IS_SET(ch->wiznet,WIZ_PERCENT))
fight.c:		if (style_check(gsn_batter,ch->pcdata->style)) {
fight.c:	} else if (IS_SET(ch->progtypes,MPROG_FIGHT) && !str_cmp(ch->pIndexData->mprogs->fight_name,"fight_prog_barbarian")) {
fight.c:		if (check_posture(ch) == POSTURE_DEFENSE && style_check(gsn_posture, ch->pcdata->style))
fight.c:		if (check_posture(victim) == POSTURE_DEFENSE && style_check(gsn_posture, victim->pcdata->style))
fight.c:		if (check_posture(victim) == POSTURE_OFFENSE && style_check(gsn_posture, victim->pcdata->style))
fight.c:			chance -= 20;
fight.c:	if(IS_EVIL(victim) && (ch->level > victim->level) && is_affected(ch, gsn_awe))
fight.c:		chance -= 20;
fight.c:		chance += (victim->level - ch->level);
fight.c:	chance *= (float)((float)1 - ((float)GET_HITROLL(ch) / (float)250));
fight.c:	chance -= victim->balance;
fight.c:	chance += ch->balance;
fight.c:	chance -= ch->batter;
fight.c:	chance -= ch->analyze;
fight.c:	if (victim->analyzePC == ch)
fight.c:		chance += victim->analyze;
fight.c:    if(IS_SET(victim->wiznet,WIZ_PERCENT))
fight.c:    if(IS_SET(ch->wiznet,WIZ_PERCENT))
fight.c:		if (style_check(gsn_batter,ch->pcdata->style)) 
fight.c:	} else if (IS_SET(ch->progtypes,MPROG_FIGHT) && !str_cmp(ch->pIndexData->mprogs->fight_name,"fight_prog_barbarian")) {
fight.c:    chance+=dex-dexa;
fight.c:    chance+=(ch->size-victim->size)*5;
fight.c:	chance-=check_terrain_mastery(ch);
fight.c:	if (is_affected_room(ch->in_room,gsn_blanket))
fight.c:        if (check_posture(ch) == POSTURE_DEFENSE && style_check(gsn_posture, ch->pcdata->style))
fight.c:	if(IS_EVIL(victim) && (ch->level > victim->level) && is_affected(ch,gsn_awe))
fight.c:		chance -=20;
fight.c:		if (check_posture(victim) == POSTURE_DEFENSE && style_check(gsn_posture, victim->pcdata->style))
fight.c:		if (check_posture(victim) == POSTURE_OFFENSE && style_check(gsn_posture, victim->pcdata->style))
fight.c:			chance -= 20;
fight.c:	if (!IS_NPC(victim) && IS_SET(victim->act,PLR_MORON))
fight.c:    chance+=ch->defense_mod;
fight.c:    chance *= (1-((float)GET_HITROLL(ch) / (float) 250));
fight.c:			encumb -= (int)((float)encumb * (float) 0.005 * (float)get_skill(victim,gsn_ease));
fight.c:		chance *= (float)(300 + (10 * (str - 18)) - encumb)/(float)250;
fight.c:		chance += (victim->level - ch->level);
fight.c:	chance -= 5*abs((ch->size-victim->size));
fight.c:	chance -= victim->balance;
fight.c:	chance += ch->balance;
fight.c:	chance -= ch->analyze;
fight.c:	if (victim->analyzePC == ch)	chance += victim->analyze;
fight.c:	if (!IS_NPC(victim) && style_check(gsn_evasion,victim->pcdata->style))
fight.c:	diff = (int)chance - roll;
fight.c:    if(IS_SET(victim->wiznet,WIZ_PERCENT))
fight.c:        sprintf(buf1,"You dodge $n's %s. (%d%% -- %d%% needed)",attack,roll,(int)chance);
fight.c:    if(IS_SET(ch->wiznet,WIZ_PERCENT))
fight.c:        sprintf(buf2,"$N dodges your %s. (%d%% -- %d%% needed)",attack,roll,(int)chance);
fight.c:    chance+=dex-dexa;
fight.c:    chance+=(ch->size-victim->size)*5;
fight.c:	if (is_affected_room(ch->in_room,gsn_blanket))
fight.c:        if (check_posture(ch) == POSTURE_DEFENSE && style_check(gsn_posture, ch->pcdata->style))
fight.c:		if (check_posture(victim) == POSTURE_DEFENSE && style_check(gsn_posture, victim->pcdata->style))
fight.c:		if (check_posture(victim) == POSTURE_OFFENSE && style_check(gsn_posture, victim->pcdata->style))
fight.c:			chance -= 20;
fight.c:    chance+=ch->defense_mod;
fight.c:    chance*=(1-((float)GET_HITROLL(ch) / (float) 250));
fight.c:		chance *= (float)(300 + (10 * (str - 18)) - encumb)/(float)250;
fight.c:	if (IS_NPC(victim) || IS_NPC(ch)) chance += (victim->level - ch->level);
fight.c:    chance -= 5*abs((ch->size-victim->size));
fight.c:	chance -= victim->balance;
fight.c:	chance += ch->balance;
fight.c:	chance -= ch->analyze;
fight.c:	if (victim->analyzePC == ch)	chance += victim->analyze;
fight.c:		if (style_check(gsn_evasion,victim->pcdata->style))
fight.c:	diff = (int)chance - roll;
fight.c:	float nododge = 100 - chance;		// chance of NOT dodging
fight.c:		if (weapon->weight > skirmisher_max_weapweight(ch))	
fight.c:		if (dual->weight > skirmisher_max_weapweight(ch))		
fight.c:		nododge *= ((float)1 - 0.05 * (float)(dex - 18));
fight.c:		chance = 100 - (int)nododge;
fight.c:		if(!style_check(gsn_fend, victim->pcdata->style))
fight.c:		switch (wield2->value[0])
fight.c:	if (ch->size > victim->size + 1)
fight.c:		skill /= pow(2,(ch->size - (victim->size - 1)));
fight.c:	if (victim->analyzePC == ch)    
fight.c:		skill += victim->analyze;
fight.c:	if(IS_SET(victim->wiznet,WIZ_PERCENT))
fight.c:	if(IS_SET(ch->wiznet,WIZ_PERCENT))
fight.c:	act(buf1,ch,weapon_name_lookup(wield->value[0]),victim,TO_VICT);
fight.c:	act(buf2,ch,weapon_name_lookup(wield->value[0]),victim,TO_CHAR);
fight.c:		if(!style_check(gsn_deflect,victim->pcdata->style))
fight.c:	if (material_table[sleeves->pIndexData->material_index].mat_hardness <= 2)
fight.c:			&& style_check(gsn_posture, ch->pcdata->style))
fight.c:		chance += (victim->level - ch->level);
fight.c:	chance *= (float)(1-(float)((float)GET_HITROLL(ch) / (float) 250));
fight.c:	chance -= victim->balance;
fight.c:	chance += ch->balance;
fight.c:	if (victim->analyzePC == ch)
fight.c:		chance += victim->analyze;
fight.c:	chance *= (float)((float) 1- (float)((float)GET_HITROLL(ch) / (float) 250));
fight.c:		skill = 30 + ch->level;
fight.c:		if (number_percent () > (skill - 125 + (5 * get_curr_stat(ch,STAT_INT)))) return;
fight.c:		if (victim != ch->analyzePC) ch->analyze = 0;
fight.c:		ch->analyzePC = ch->fighting;
fight.c:		if (ch->analyze < 50)   ch->analyze++; */
fight.c:	if (!style_check(gsn_analyze, ch->pcdata->style)) return;
fight.c:	if (number_percent () > (skill - 125 + (5 * intel))) return;
fight.c:	if (victim != ch->analyzePC) {
fight.c:		ch->analyze = 0;
fight.c:	ch->analyzePC = ch->fighting;
fight.c:	if (ch->analyze < 50)	ch->analyze++;
fight.c:    if ( victim->hit > 0 )
fight.c:        if ( victim->position <= POS_STUNNED )
fight.c:            victim->position = POS_STANDING;
fight.c:	if(victim->hit > (victim->mana * -1))
fight.c:    if ( IS_NPC(victim) && victim->hit < 1)
fight.c:		victim->position = POS_DEAD;
fight.c:	else if ( victim->hit <= -11 )
fight.c:        victim->position = POS_DEAD;
fight.c:	else if ( victim->hit <= -6 ) 
fight.c:		victim->position = POS_MORTAL;
fight.c:    else if ( victim->hit <= -3 ) 
fight.c:		victim->position = POS_INCAP;
fight.c:		victim->position = POS_STUNNED;
fight.c:	if ( ch->fighting != NULL )
fight.c:	if ((IS_NPC(victim) && IS_SET(victim->act,ACT_GUILDGUARD))) {
fight.c:    ch->fighting = victim;
fight.c:    ch->position = POS_FIGHTING;
fight.c:		ch->pause = UMAX(ch->pause, 3);
fight.c:		ch->pause = UMAX(ch->pause, 7);
fight.c:		victim->pause = UMAX(victim->pause, 3);
fight.c:		victim->pause = UMAX(ch->pause, 7);
fight.c:	if(victim && IS_SET(victim->progtypes,MPROG_ATTACK))
fight.c:		(victim->pIndexData->mprogs->attack_prog) (victim,ch);
fight.c:    for ( fch = char_list; fch != NULL; fch = fch->next )
fight.c:        if ( fch == ch || ( fBoth && fch->fighting == ch ) )
fight.c:            fch->fighting       = NULL;
fight.c:            fch->position       = POS_STANDING;
fight.c:        name            = ch->short_descr;
fight.c:        corpse->timer   = number_range( 5, 8 );
fight.c:		//free_pstring(corpse->talked);
fight.c:			corpse->talked = palloc_string(killer->short_descr);
fight.c:			corpse->talked = palloc_string(killer->true_name);
fight.c:		if ( ch->gold > 0 )
fight.c:            obj_to_obj( create_money( ch->gold ), corpse );
fight.c:            ch->gold = 0;
fight.c:        corpse->cost = 0;
fight.c:		corpse->mob_vnum = ch->pIndexData->vnum;
fight.c:        name            = ch->name;
fight.c:        corpse->timer   = number_range( 20, 35 );
fight.c:    	if(ch->in_room && IS_EXPLORE(ch->in_room))
fight.c:			corpse->timer   = number_range(6,9);
fight.c:		corpse->value[4] = ch->hometown;
fight.c:        REMOVE_BIT(ch->act,PLR_CANLOOT);
fight.c:		//free_pstring(corpse->talked);
fight.c:			corpse->talked = palloc_string(killer->short_descr);
fight.c:			corpse->talked = palloc_string(killer->true_name);
fight.c:      	corpse->owner = palloc_string(ch->true_name);
fight.c:		if (ch->gold > 1)
fight.c:			obj_to_obj(create_money(ch->gold), corpse);
fight.c:			ch->gold = 0;
fight.c:        corpse->cost = 0;
fight.c:    corpse->level = URANGE(1,ch->level,100);
fight.c:     if (IS_NPC(ch) && (IS_SET(ch->act,ACT_UNDEAD) || IS_SET(ch->form,FORM_UNDEAD)))
fight.c:	SET_BIT(corpse->extra_flags,CORPSE_NO_ANIMATE);
fight.c:    corpse->value[2] = ch->size;
fight.c:    sprintf( buf, corpse->short_descr, name );
fight.c:    free_pstring( corpse->short_descr );
fight.c:    corpse->short_descr = palloc_string( buf );
fight.c:    sprintf( buf, corpse->description, name );
fight.c:    free_pstring( corpse->description );
fight.c:    corpse->description = palloc_string( buf );
fight.c:    corpse->ohp	= ch->max_hit;
fight.c:    for ( obj = ch->carrying; obj != NULL; obj = obj_next )
fight.c:        obj_next = obj->next_content;
fight.c:		if (IS_SET(obj->extra_flags,ITEM_BRAND))
fight.c:		if (!IS_NPC(ch) && IS_SET(obj->extra_flags,ITEM_FIXED)) {
fight.c:			equip_char(ch,obj,obj->wear_loc,FALSE);
fight.c:        if (obj->item_type == ITEM_POTION)
fight.c:            obj->timer = number_range(500,1000);
fight.c:        if (obj->item_type == ITEM_SCROLL)
fight.c:            obj->timer = number_range(1000,2500);
fight.c:	if (obj->pIndexData->vnum == OBJ_VNUM_HYDRA_SLAYER)
fight.c:		obj->timer = number_range(500,1500);
fight.c:	else if (obj->pIndexData->vnum == OBJ_VNUM_HYDRA_HEAD)
fight.c:		obj->timer = number_range(300,900);
fight.c:        if (IS_SET(obj->extra_flags,ITEM_ROT_DEATH) && !floating)
fight.c:            obj->timer = 1;
fight.c:            REMOVE_BIT(obj->extra_flags,ITEM_ROT_DEATH);
fight.c:	if (obj->pIndexData->start_timer > 0 && IS_NPC(ch))
fight.c:		obj->timer = obj->pIndexData->start_timer;
fight.c:        REMOVE_BIT(obj->extra_flags,ITEM_VIS_DEATH);
fight.c:	if (obj->pIndexData->limcount > obj->pIndexData->limtotal
fight.c:		 && obj->pIndexData->limtotal > 0)
fight.c:                if (obj->contains != NULL)
fight.c:                    for (in = obj->contains; in != NULL; in = in_next)
fight.c:                        in_next = in->next_content;
fight.c:                        obj_to_room(in,ch->in_room);
fight.c:                obj_to_room(obj,ch->in_room);
fight.c://	else if (obj->wear_loc == WEAR_BRAND)
fight.c:	else if (IS_SET(obj->extra_flags,ITEM_BRAND))
fight.c:	} else if (!IS_NPC(ch) && IS_SET(obj->extra_flags,ITEM_FIXED))
fight.c:    obj_to_room( corpse, ch->in_room );
fight.c:		oaf.duration     = -1;
fight.c:        if (ch->material == 0)
fight.c:        if (IS_SET(ch->parts,PART_GUTS))
fight.c:        if (IS_SET(ch->parts,PART_HEAD) && !infidels)
fight.c:        if (IS_SET(ch->parts,PART_HEART))
fight.c:        if (IS_SET(ch->parts,PART_ARMS))
fight.c:        if (IS_SET(ch->parts,PART_LEGS))
fight.c:        if (IS_SET(ch->parts,PART_BRAINS))
fight.c:        name            = IS_NPC(ch) ? ch->short_descr : ch->name;
fight.c:        obj->timer      = number_range( 4, 7 );
fight.c:		obj->level      = ch->level;
fight.c:        sprintf( buf, obj->short_descr, name );
fight.c:        free_pstring( obj->short_descr );
fight.c:        obj->short_descr = palloc_string( buf );
fight.c:        sprintf( buf, obj->description, name );
fight.c:        free_pstring( obj->description );
fight.c:        obj->description = palloc_string( buf );
fight.c:        if (obj->item_type == ITEM_FOOD)
fight.c:            if (IS_SET(ch->form,FORM_POISON))
fight.c:                obj->value[3] = 1;
fight.c:            else if (!IS_SET(ch->form,FORM_EDIBLE))
fight.c:                obj->item_type = ITEM_TRASH;
fight.c:        obj_to_room( obj, ch->in_room );
fight.c:    was_in_room = ch->in_room;
fight.c:        if ( ( pexit = was_in_room->exit[door] ) != NULL
fight.c:        &&   pexit->u1.to_room != NULL
fight.c:        &&   pexit->u1.to_room != was_in_room )
fight.c:            ch->in_room = pexit->u1.to_room;
fight.c:    ch->in_room = was_in_room;
fight.c:    	if(number_percent() < (10 + (get_skill(ch,gsn_infidels_fate) - 30 )))
fight.c:    if (IS_NPC(ch) && ch->pIndexData->vnum == 23630) 
fight.c:		victim->hit = 1;
fight.c:		if (victim->pcdata->imm_death) 
fight.c:			act("$T",victim,NULL,victim->pcdata->imm_death,TO_ROOM);
fight.c:			act("$T",victim,NULL,victim->pcdata->imm_death,TO_CHAR);
fight.c:	for (obj = victim->carrying;obj != NULL;obj = obj->next_content) 
fight.c:		if (IS_SET(obj->progtypes,IPROG_DEATH))
fight.c:			if ((obj->pIndexData->iprogs->death_prog) (obj,victim)) 
fight.c:	if(IS_NPC(ch) && IS_AFFECTED(ch,AFF_CHARM) && ch->master
fight.c:		&& ch->master->in_room && ch->master->in_room == ch->in_room)
fight.c:			ch = ch->master;
fight.c:	if ( IS_SET(victim->progtypes,MPROG_DEATH))
fight.c:		if ((victim->pIndexData->mprogs->death_prog) (victim,ch)) 
fight.c:		if(ch->pcdata->bounty && victim->cabal == CABAL_BOUNTY)
fight.c:			ch->pcdata->bounty_killed++;
fight.c:	if(!IS_NPC(victim) && ch->in_room == victim->in_room && !IS_NPC(ch) && get_skill(ch,gsn_trophy) > 20)
fight.c:            	(IS_NPC(victim) ? victim->short_descr : victim->name),
fight.c:            	(IS_NPC(ch) ? ch->short_descr : ch->name),
fight.c:            	ch->in_room->name, ch->in_room->vnum);
fight.c:		gch_next = gch->next;
fight.c:		if (IS_NPC(gch) && gch->master == victim && gch->pIndexData->vnum != ACADEMY_PET && !IS_NPC(victim))
fight.c:			victim->pcdata->killed[MOB_KILLED]++;
fight.c:	 	 victim->pIndexData->killed++;
fight.c:	  	kill_table[URANGE(0, victim->level, MAX_LEVEL-1)].killed++;
fight.c:    	for (paf = victim->affected; paf != NULL; paf = paf_next)
fight.c:		paf_next = paf->next;
fight.c:		if(IS_SET(paf->bitvector,AFF_PERMANENT))
fight.c:	for (paf = victim->affected; paf != NULL; paf = paf_next)
fight.c:		paf_next = paf->next;
fight.c:		if(IS_SET(paf->bitvector,AFF_PERMANENT))
fight.c:    	victim->talismanic = 0;
fight.c:    	BITWISE_OR(victim->affected_by, race_data_lookup(victim->race)->aff);
fight.c:        	victim->armor[i]= 0;
fight.c:    	victim->position    					= 	POS_RESTING;
fight.c:    	victim->hit         					= 	victim->pcdata->perm_hit;
fight.c:    	victim->mana        					= 	victim->pcdata->perm_mana;
fight.c:    	victim->move        					= 	victim->pcdata->perm_move;
fight.c:    	victim->pcdata->condition[COND_THIRST]		=	0;
fight.c:    	victim->pcdata->condition[COND_HUNGER]		=	0;
fight.c:    	victim->pcdata->condition[COND_DRUNK] 		= 	0;
fight.c:    	victim->ghost = 20;
fight.c:    	victim->bounty_timer = 100;
fight.c:    	if (victim->hometown)
fight.c:		location = get_room_index(hometown_table[victim->hometown].recall);
fight.c:    	af.level = victim->level;
fight.c:	victim->last_fight_name = NULL;
fight.c:	(int)victim->last_fight_time = NULL;
fight.c:		victim->pcdata->death_count++;
fight.c:		if ((victim->pcdata->death_count >= 4)
fight.c:		     && !(victim->perm_stat[STAT_CON] < 3))
fight.c:			victim->perm_stat[STAT_CON] -= 1;
fight.c:			victim->pcdata->death_count = 0;
fight.c:		if (victim->perm_stat[STAT_CON] < CON_DIE_BOUND)
fight.c:			SET_BIT(victim->act, PLR_DENY);
fight.c:			victim->pause = 0;
fight.c:			cname = palloc_string(victim->true_name);
fight.c:		if (victim->perm_stat[STAT_CON] < 5)
fight.c:    	if(IS_NPC(ch) && IS_AFFECTED(ch,AFF_CHARM) && ch->master)
fight.c:		ch = ch->master;
fight.c:			obj2 = create_object(get_obj_index(2999),ch->level);
fight.c:			obj2->timer = ch->level;
fight.c:			obj_to_room(obj2,ch->in_room);
fight.c:			raf.duration = ch->level;
fight.c:			affect_to_room(ch->in_room,&raf);
fight.c:			aaf.duration = ch->level;
fight.c:			affect_to_area(ch->in_room->area,&aaf);
fight.c:			sprintf(buf,obj2->short_descr,victim->name);
fight.c:			free_pstring(obj2->short_descr);
fight.c:			obj2->short_descr = palloc_string(buf);
fight.c:			sprintf(buf,obj2->description,victim->name);
fight.c:			free_pstring(obj2->description);
fight.c:			obj2->description = palloc_string(buf);
fight.c:			sprintf(buf2,"{RA hush falls over your surroundings as %s is raised.{x",obj2->short_descr);
fight.c:			zone_echo(ch->in_room->area,buf2);
fight.c:	if(!IS_NPC(victim) && IS_NPC(ch) && victim->level < 51)
fight.c:			if (victim->pcdata->learned[sn] > 10 &&
fight.c:			   (number_percent() > (8 * get_curr_stat(victim,STAT_WIS) - 120)))
fight.c:				  victim->pcdata->learned[sn]--;
fight.c:	for (wch = char_list; wch; wch = wch->next) {
fight.c:			&& ((wch->in_room == ch->in_room)
fight.c:			|| (wch->ghost > 0))) {
fight.c:			sprintf(buf,"Adding %s to killer_group",wch->name);
fight.c:		if (is_same_group(wch,ch) && wch->in_room == ch->in_room && !IS_NPC(wch)) {
fight.c:			sprintf(buf,"Adding %s to killer_in_room",wch->name);
fight.c:			&& ((wch->in_room == victim->in_room)
fight.c:			|| (wch->ghost > 0))) {
fight.c:			sprintf(buf,"Adding %s to victim_group.",wch->name);
fight.c:	victim->pcdata->fragged += victim_credit;
fight.c:	for (wch = char_list; wch; wch = wch->next) {
fight.c:			&& wch->in_room == ch->in_room) {
fight.c:			wch->pcdata->frags[PK_KILLS] += killer_credit;
fight.c:				wch->pcdata->frags[PK_GOOD] += killer_credit;
fight.c:				wch->pcdata->frags[PK_NEUTRAL] += killer_credit;
fight.c:				wch->pcdata->frags[PK_EVIL] += killer_credit;
fight.c:			if (wch->level < 51)
fight.c:					if (wch->pcdata->recentkills[i] == NULL)
fight.c:					if (*(wch->pcdata->recentkills[i]) == '\0')
fight.c:					wch->pcdata->recentkills[i] = palloc_string(victim->name);
fight.c:	ch->pcdata->kills[PK_KILLS]++;
fight.c:	if (victim->alignment > 0)
fight.c:		ch->pcdata->kills[PK_GOOD]++;
fight.c:	else if (victim->alignment == 0)
fight.c:		ch->pcdata->kills[PK_NEUTRAL]++;
fight.c:	else if (victim->alignment < 0)
fight.c:		ch->pcdata->kills[PK_EVIL]++;
fight.c:	victim->pcdata->killed[PK_KILLED]++;
fight.c:	if (ch->level < 51) {
fight.c:			if (ch->pcdata->recentkills[i] == NULL)
fight.c:			if (*(ch->pcdata->recentkills[i]) == '\0')
fight.c:			ch->pcdata->recentkills[i] = palloc_string(victim->name);
fight.c:     * P-killing doesn't help either.
fight.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room ) {
fight.c:            group_levels += (IS_NPC(gch) && gch->master) ? gch->master->level : gch->level;
fight.c:    lch = (ch->leader != NULL) ? ch->leader : ch;
fight.c:	if (ch->in_room == NULL)	return;
fight.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room ) {
fight.c:        if ( gch->level - lch->level > 8 ) {
fight.c:        if ( gch->level - lch->level < -8 )
fight.c:		if (gch->level < 51) {
fight.c:	for (i=0; ch->pcdata->recentkills[i] && *(ch->pcdata->recentkills[i]) != '\0' && i<95;i++)
fight.c:		if (!str_cmp(ch->pcdata->recentkills[i],victim->name)) {
fight.c:	/* We don't want to encourage low-level PKing */
fight.c:	if (victim->level < 15)
fight.c:	else if (victim->level < 20)
fight.c:		xp = victim->level;
fight.c:	else if (victim->level < 25)
fight.c:		xp = victim->level * 2;
fight.c:	else if (victim->level < 30)
fight.c:		xp = victim->level * 4;
fight.c:	else if (victim->level < 35)
fight.c:		xp = victim->level * 8;
fight.c:	else if (victim->level < 40)
fight.c:		xp = victim->level * 12;
fight.c:	else if (victim->level < 45)
fight.c:		xp = victim->level * 16;
fight.c:		xp = victim->level * 20;
fight.c:	xp *= (float) (1 + (float) (0.05 * (victim->level - ch->level)));
fight.c:		xp += 5 * victim->pcdata->kills[PK_GOOD];
fight.c:			if (ch->pcdata->kills[PK_GOOD] < ch->pcdata->kills[PK_EVIL])
fight.c:			if (ch->pcdata->kills[PK_GOOD] > ch->pcdata->kills[PK_EVIL])
fight.c:			if (ch->pcdata->kills[PK_GOOD] > ch->pcdata->kills[PK_EVIL])
fight.c:			if (ch->pcdata->kills[PK_GOOD] < ch->pcdata->kills[PK_EVIL])
fight.c:	if (ch->cabal && !victim->cabal)
fight.c:	if (!ch->cabal && victim->cabal)
fight.c:	netpk = victim->pcdata->frags[PK_KILLS] - victim->pcdata->fragged;
fight.c:	totalpk = victim->pcdata->frags[PK_KILLS] + victim->pcdata->fragged;
fight.c:	mult = (100 - (gavg > gch->level ? gavg - gch->level : gch->level - gavg) * 6) / 100;
fight.c:    level_range = victim->level - gch->level;
fight.c:        case -9 :       base_exp =   2;         break;
fight.c:        case -8 :       base_exp =   4;         break;
fight.c:        case -7 :       base_exp =   7;         break;
fight.c:        case -6 :       base_exp =  12;         break;
fight.c:        case -5 :       base_exp =  14;         break;
fight.c:        case -4 :       base_exp =  25;         break;
fight.c:        case -3 :       base_exp =  36;         break;
fight.c:        case -2 :       base_exp =  55;         break;
fight.c:        case -1 :       base_exp =  85;         break;
fight.c://	xp *= (float)victim->pIndexData->xp_mod / (float)100;
fight.c:    if(IS_NPC(victim) && victim->law_pass)
fight.c:		xp /= (group_amount - 2);
fight.c:	for(cPeers = char_list; cPeers; cPeers = cPeers->next)
fight.c:			cPeers->level > gch->level - PEER_BALANCE_DISTANCE &&
fight.c:			cPeers->level < gch->level + PEER_BALANCE_DISTANCE)
fight.c:				peer_factor = UMAX(1, peer_factor - .25);
fight.c:		gch->name,group_amount,peer_factor*100);
fight.c:    if (ch == NULL || victim == NULL || !victim->in_room || !ch->in_room)
fight.c:/* Now quickly set dual wield weapon dt to real weapon dt - this allows
fight.c:-Ceran
fight.c:			dt += wield->value[3];
fight.c:			dt += ch->dam_type;
fight.c:			if (prop < victim->max_hit) {
fight.c:			for (gch = victim->in_room->people; gch != NULL;
fight.c:				gch = gch->next_in_room) {
fight.c:					if (prop < victim->max_hit) {
fight.c:            attack      = attack_table[dt - TYPE_HIT].noun;
fight.c:		if (attack && attack[strlen(attack)-1] == '$') {
fight.c:		} else if (attack && attack[strlen(attack)-1] == '#') {
fight.c:		    if (attack && attack[strlen(attack)-1] == '*') {
fight.c:	    	if (attack && attack[strlen(attack)-1] == '*') {
fight.c:				for (gch = victim->in_room->people; gch != NULL;
fight.c:					gch = gch->next_in_room) {
fight.c:						if (prop < victim->max_hit)						
fight.c:					if (prop < victim->max_hit)
fight.c:					if (prop < victim->max_hit)
fight.c:				if (prop < victim->max_hit)
fight.c:				for (gch = victim->in_room->people; gch != NULL;
fight.c:					gch = gch->next_in_room) {
fight.c:						if (prop < victim->max_hit)
fight.c:				if (prop < victim->max_hit)
fight.c:				for (gch = victim->in_room->people; gch != NULL;
fight.c:					gch = gch->next_in_room) {
fight.c:						if (prop < victim->max_hit)
fight.c:				if (prop < victim->max_hit)
fight.c:				if (prop < victim->max_hit)
fight.c:		sprintf(buf97,"Log: Damage without noun. Char: %s, Victim: %s, DT: %d",ch->true_name,victim->true_name,dt);
fight.c:		if (!(asterisk && ch->in_room != victim->in_room))
fight.c:		if (IS_SET(mob->pIndexData->styles,style_table[style].bit)
fight.c:			&& mob->mobstyle != style
fight.c:			mob->mobstyle = style;
fight.c:	health = victim->hit * 100 / victim->max_hit;
fight.c:	switch(mob->mobstyle) {
fight.c:			if ((victim->Class()->GetIndex() == CLASS_SORCERER
fight.c:				|| victim->Class()->GetIndex() == CLASS_NECROMANCER
fight.c:				|| victim->Class()->GetIndex() == CLASS_HEALER
fight.c:				|| victim->Class()->GetIndex() == CLASS_ZEALOT
fight.c:				|| victim->Class()->GetIndex() == CLASS_ANTI_PALADIN)
fight.c:				&& (mobweap->value[0] != WEAPON_AXE
fight.c:					&& mobweap->value[0] != WEAPON_WHIP
fight.c:					&& mobweap->value[0] != WEAPON_EXOTIC
fight.c:					&& mobweap->value[0] != WEAPON_POLEARM)
fight.c:				&& str_cmp(race_table[victim->race].name,"minotaur"))
fight.c:					if (mob->in_room->exit[dir]
fight.c:						&& mob->in_room->exit[dir]->u1.to_room) {
fight.c:			if ((victim->Class()->GetIndex() == CLASS_SORCERER
fight.c:				|| victim->Class()->GetIndex() == CLASS_NECROMANCER)
fight.c:				&& mobweap->weight >= 15
fight.c:				&& (mobweap->value[0] == WEAPON_MACE
fight.c:					|| mobweap->value[0] == WEAPON_AXE
fight.c:					|| mobweap->value[0] == WEAPON_FLAIL
fight.c:					|| mobweap->value[0] == WEAPON_STAFF)
fight.c:				&& mobweap->weight >= 15
fight.c:				&& mobweap->value[0] != WEAPON_WHIP
fight.c:				&& mobweap->value[0] != WEAPON_POLEARM
fight.c:				&& mobweap->value[0] != WEAPON_DAGGER
fight.c:				&& mobweap->value[0] != WEAPON_EXOTIC
fight.c:				&& mobweap->value[0] != WEAPON_SPEAR)
fight.c:			else if (mobweap && mobweap->weight >= 15
fight.c:				&& (mobweap->value[0] == WEAPON_SPEAR
fight.c:					|| mobweap->value[0] == WEAPON_POLEARM)
fight.c:			else if (mobweap && mobweap->weight >= 15
fight.c:				&& mobweap->value[0] != WEAPON_DAGGER
fight.c:				&& mobweap->value[0] != WEAPON_WHIP
fight.c:				&& mobweap->value[0] != WEAPON_EXOTIC
fight.c:			for (gch = mob->in_room->people; gch; gch = gch->next_in_room) {
fight.c:				&& mobweap->value[0] == WEAPON_WHIP
fight.c:						if (mob->in_room->exit[dir]
fight.c:							&& mob->in_room->exit[dir]->u1.to_room
fight.c:							&& !IS_SET(mob->in_room->exit[dir]->exit_info,EX_CLOSED)) {
fight.c:			else if (mobweap && mobweap->weight < 10
fight.c:				&& (mobweap->value[0] == WEAPON_DAGGER
fight.c:				|| mobweap->value[0] == WEAPON_AXE
fight.c:				|| mobweap->value[0] == WEAPON_MACE
fight.c:				|| mobweap->value[0] == WEAPON_SWORD))
fight.c:					|| (mobweap->value[0] == WEAPON_STAFF
fight.c:						|| mobweap->value[0] == WEAPON_POLEARM
fight.c:						|| mobweap->value[0] == WEAPON_SPEAR)))
fight.c:		&& mobweap->value[0] == WEAPON_DAGGER)
fight.c:		&& mobweap->value[0] == WEAPON_DAGGER))
fight.c:		&& victim->fighting != mob)
fight.c:	if (victim->position < POS_FIGHTING
fight.c:		|| ch->size + 1 < victim->size
fight.c:		|| ch->size - 1 > victim->size
fight.c:	    	obj_to_room( obj, victim->in_room );
fight.c:			if (IS_NPC(victim) && victim->wait == 0 && can_see_obj(victim,obj))
fight.c:    ||  (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_BERSERK))
fight.c:    &&   ch->level < skill_table[gsn_berserk].skill_level[ch->Class()->GetIndex()]))
fight.c:    if (ch->mana < 50)
fight.c:    if (ch->position == POS_FIGHTING)
fight.c:    /* damage -- below 50% of hp helps, above hurts */
fight.c:    if (ch->max_hit == 0)
fight.c:    hp_percent = 100 * ch->hit/ch->max_hit;
fight.c:    chance += 25 - hp_percent/2;
fight.c:        ch->mana -= 50;
fight.c:        ch->move = (short)(ch->move / 1.2);
fight.c:        ch->hit += ch->level*2;
fight.c:        ch->hit = UMIN(ch->hit,ch->max_hit);
fight.c:        af.level        = ch->level;
fight.c:		af.duration 	= (ch->level / 10);
fight.c:        af.modifier     = UMAX(1,ch->level/5);
fight.c:        ch->mana -= 25;
fight.c:        victim = ch->fighting;
fight.c:    if (victim->position < POS_FIGHTING)
fight.c:    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
fight.c:	if (ch->size + 1 < victim->size)
fight.c:	if (ch->size - 1 > victim->size)
fight.c:		avoid += 5 * (get_curr_stat(ch,STAT_DEX) - 20);
fight.c:	ch->hit = UMAX(ch->hit - dice(5,10),0);
fight.c:        act("Your hear your bones crack as you slam into a rock-hard shield around $n.",victim,0,ch,TO_VICT);
fight.c:	af.level     = ch->level;
fight.c:	af.duration  = ch->level/5;
fight.c:	af.modifier  = -1;
fight.c:	af.modifier  = -1;
fight.c:        victim->hit = UMIN(victim->hit + dam,victim->max_hit);
fight.c:                ch->pcdata->condition[COND_THIRST] += 8;
fight.c:                ch->pcdata->condition[COND_THIRST] = UMIN(ch->pcdata->condition[COND_THIRST],COND_HUNGRY);
fight.c:    (*skill_table[gsn_chill].spell_fun) ( gsn_chill, ch->level, victim,ch,TAR_CHAR_OFFENSIVE);
fight.c:    chance += ch->carry_weight / 250;
fight.c:    chance -= victim->carry_weight / 200;
fight.c:    if (ch->size < victim->size)
fight.c:        chance += (ch->size - victim->size) * 20;
fight.c:        chance += (ch->size - victim->size) * 10;
fight.c:    chance -= (get_curr_stat(victim,STAT_DEX) * 4)/3;
fight.c:    chance -= GET_AC(victim,AC_BASH) /25;
fight.c:    if (IS_SET(ch->off_flags,OFF_FAST) || is_affected(ch,skill_lookup("haste")))
fight.c:    if (IS_SET(victim->off_flags,OFF_FAST) || is_affected(victim,skill_lookup("haste")))
fight.c:        chance -= 40;
fight.c:    chance += (ch->level - victim->level);
fight.c:	&& (victim->fighting == NULL || ch->fighting == NULL))
fight.c:        chance -= 3 * (get_skill(victim,gsn_dodge) - chance);
fight.c:        damage_old(ch,victim,number_range(2,(int)(2 + 2 * ch->size + chance/20)),gsn_bash,DAM_BASH,TRUE);
fight.c:		LAG_CHAR(victim,UMIN(2,number_range(1,2) + ch->size - victim->size) * PULSE_VIOLENCE);
fight.c:        victim->position = POS_RESTING;
fight.c:		victim->disrupted = TRUE;
fight.c:	if (!IS_NPC(ch) && (ch->Class()->GetIndex() == CLASS_WARRIOR)
fight.c:	&& (number_percent() < ch->level))
fight.c:		ch->pcdata->sp++;
fight.c:        ch->position = POS_RESTING;
fight.c:        victim = ch->fighting;
fight.c:    if(victim->position==POS_SLEEPING) {
fight.c:    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
fight.c:    chance -= 2 * get_curr_stat(victim,STAT_DEX);
fight.c:    if (IS_SET(ch->off_flags,OFF_FAST) || is_affected(ch,skill_lookup("haste")))
fight.c:    if (IS_SET(victim->off_flags,OFF_FAST) || is_affected(victim,skill_lookup("haste")))
fight.c:        chance -= 30;
fight.c:    chance += (ch->level - victim->level) * 2;
fight.c:    switch(ch->in_room->sector_type)
fight.c:        case(SECT_INSIDE):              chance -= 20;   break;
fight.c:        case(SECT_CITY):                chance -= 10;   break;
fight.c:        case(SECT_MOUNTAIN):            chance -= 10;   break;
fight.c:	if (IS_SET(victim->act,ACT_UNDEAD) || IS_SET(victim->form,FORM_UNDEAD) ) {
fight.c:	( (victim->fighting == NULL) || (ch->fighting == NULL)))
fight.c:        af.level        = ch->level;
fight.c:        af.modifier     = -4;
fight.c:-Ceran
fight.c:	&& (victim->fighting == NULL || ch->fighting == NULL))
fight.c:    	|| (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_TRIP) 
fight.c:		&& ch->pIndexData->vnum!=MOB_VNUM_TEMPLAR)
fight.c:        && ch->level < skill_table[gsn_trip].skill_level[ch->Class()->GetIndex()]))
fight.c:        victim = ch->fighting;
fight.c:    if (victim->position < POS_FIGHTING)
fight.c:    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
fight.c:    if (ch->size < victim->size)
fight.c:        chance += (ch->size - victim->size) * 10;  /* bigger = harder to trip */
fight.c:    chance -= get_curr_stat(victim,STAT_DEX) * 3 / 2;
fight.c:    if (IS_SET(ch->off_flags,OFF_FAST) || is_affected(ch,skill_lookup("haste")))
fight.c:    if (IS_SET(victim->off_flags,OFF_FAST) || is_affected(victim,skill_lookup("haste")))
fight.c:        chance -= 40;
fight.c:    chance += (ch->level - victim->level) * 2;
fight.c:			&& (ch->fighting == NULL 
fight.c:			|| victim->fighting == NULL))
fight.c:			victim->position = POS_RESTING;
fight.c:			victim->disrupted = TRUE;
fight.c:        damage(ch,victim,number_range(2, 2 +  2 * victim->size),gsn_trip, DAM_BASH,TRUE);
fight.c:			&& (ch->fighting == NULL || victim->fighting == NULL))
fight.c:    if ( ch->position != POS_FIGHTING )
fight.c:    if ( victim->fighting != ch )
fight.c:	if (victim == ch->fighting) {
fight.c:    ch->fighting = victim;
fight.c:    ch->batter = 0;
fight.c:    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
fight.c:    if ( ch->position == POS_FIGHTING )
fight.c:    if ((IS_AFFECTED(ch,AFF_CHARM) || (IS_NPC(ch) && IS_SET(ch->act,ACT_PET))))
fight.c:    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
fight.c:    if ( ch->position == POS_FIGHTING )
fight.c:    if (is_affected(ch, gsn_rage) && !IS_NPC(ch) && ch->pcdata->tribe == TRIBE_FOX)
fight.c:	af.duration	= ch->level / 20;
fight.c:	af.level	= ch->level;
fight.c:	af.modifier	= -2;
fight.c:        sprintf(buf, "Help!  I am being attacked by %s!",ch->short_descr);
fight.c:-Ceran
fight.c:    if (ch->fighting != NULL)
fight.c:    if (victim->fighting != NULL
fight.c:	|| ch->level < skill_table[gsn_moving_ambush].skill_level[ch->Class()->GetIndex()]))
fight.c:    if (victim->fighting != NULL
fight.c:	if (!IS_NPC(ch) && !IS_NPC(victim) && victim->fighting == NULL)
fight.c:    if ( ( fch = victim->fighting ) == NULL )
fight.c:    if (is_safe(ch,victim->fighting))
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:	dam = ch->level/2;
fight.c:	dam += number_range(0,ch->level/6);
fight.c:	dam += number_range(0,ch->level/6);
fight.c:	dam += number_range(0,ch->level/6);
fight.c:	dam += number_range(0,ch->level/6);
fight.c:	dam += number_range(0,ch->level/6);
fight.c:	dam += number_range(0,ch->level/6);
fight.c:	dam += number_range(ch->level/5,ch->level/4);
fight.c:	if (ch->Class()->name == "shapeshifter")
fight.c:	if (ch->Class()->name == "necromancer")
fight.c:	if (ch->Class()->name == "sorcerer")
fight.c:    ||    (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_DISARM) && ch->pIndexData->vnum!=MOB_VNUM_TEMPLAR)))
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:		(!IS_NPC(victim) && victim->pcdata->greaterdata[GREATER_GERYON] == GERYON_EYE))
fight.c:    chance += (ch_vict_weapon/2 - vict_weapon) / 2;
fight.c:    chance -= 1.25 * get_curr_stat(victim,STAT_STR);
fight.c:    chance += (ch->level - victim->level) * 2;
fight.c:    if ( (mob = ch->fighting) == NULL )
fight.c:    if ( !IS_NPC(victim) && victim->level >= get_trust(ch))
fight.c:	if (saves_spell(level-1,victim,DAM_NEGATIVE) )
fight.c:    if(IS_IMMORTAL(ch) && (victim->level<ch->level)) { saves=0; }
fight.c:        || (ch->level < skill_table[gsn_bandage].skill_level[ch->Class()->GetIndex()]) )
fight.c:        if (ch->mana < 15)
fight.c:        ch->mana -= 7;
fight.c:        ch->mana -= 15;
fight.c:        victim->hit = UMIN(victim->hit + (5*ch->level), victim->max_hit);
fight.c:        af.level = ch->level;
fight.c:        || (ch->level < skill_table[gsn_herb].skill_level[ch->Class()->GetIndex()]) )
fight.c:        if ((ch->in_room->sector_type != SECT_FOREST)
fight.c:        && (ch->in_room->sector_type != SECT_HILLS)
fight.c:        && (ch->in_room->sector_type != SECT_MOUNTAIN) )
fight.c:        victim->hit = UMIN(victim->hit + (4*ch->level), victim->max_hit);
fight.c:        af.level = ch->level;
fight.c:        || (ch->level < skill_table[gsn_cleave].skill_level[ch->Class()->GetIndex()]) )
fight.c:        if ((weapon->value[0] != WEAPON_SWORD)
fight.c:        && (weapon->value[0] != WEAPON_AXE) )
fight.c:        if (victim->fighting != NULL)
fight.c:        if (victim->hit > 10000)
fight.c:        if ((ch->level - victim->level) < 0)
fight.c:                chance -= (ch->level - victim->level)*3;
fight.c:                chance += (ch->level - victim->level);
fight.c:        chance -= get_curr_stat(victim,STAT_DEX)/3;  /* Improve evasion */
fight.c:        chance -= get_curr_stat(victim,STAT_STR)/4;  /* Improve repelling */
fight.c:        chance -= get_curr_stat(victim,STAT_CON)/4;  /* Shock survival */
fight.c:        dam_type = attack_table[weapon->value[3]].damage;
fight.c:        chance -= dice(2,6);
fight.c:	victim->last_fought = ch;
fight.c:        if (weapon->pIndexData->new_format)
fight.c:                dam = dice(weapon->value[1],weapon->value[2])*skill/100;
fight.c:                dam = number_range(weapon->value[1]*skill/100,weapon->value[2]*skill/100);
fight.c:        dam *= number_range(ch->level/10,ch->level/7);
fight.c:        if (!IS_NPC(victim) && !IS_NPC(ch) && victim->hit > 1)
fight.c:  	chance -= number_range(5,15);
fight.c:        if (ch->level < skill_table[gsn_ground_control].skill_level[ch->Class()->GetIndex()])
fight.c:        dam -= 10;
fight.c:        victim = ch->fighting;
fight.c:    chance += (ch->level - victim->level);
fight.c:    chance -= get_curr_stat(victim,STAT_DEX);
fight.c:    dam = dice(ch->level, 3);
fight.c:    knock = (ch->level + 15);
fight.c:    || ch->level < skill_table[gsn_throw].skill_level[ch->Class()->GetIndex()]))
fight.c:        victim = ch->fighting;
fight.c:    if ((victim->fighting != ch) && (ch->fighting != victim))
fight.c:	ch->hit = UMAX(ch->hit - dice(5,10),0);
fight.c:        act("Your hear your bones crack as you slam into a rock-hard shield around $n.",victim,0,ch,TO_VICT);
fight.c:	af.level     = ch->level;
fight.c:	af.duration  = ch->level/5;
fight.c:	af.modifier  = -1;
fight.c:	af.modifier  = -1;
fight.c:        victim->hit = UMIN(victim->hit + dam,victim->max_hit);
fight.c:                ch->pcdata->condition[COND_THIRST] += 8;
fight.c:                ch->pcdata->condition[COND_THIRST] = UMIN(ch->pcdata->condition[COND_THIRST],COND_HUNGRY);
fight.c:    (*skill_table[gsn_chill].spell_fun) ( gsn_chill, ch->level, victim,ch,TAR_CHAR_OFFENSIVE);
fight.c:    chance += (ch->level - victim->level);
fight.c:    chance -= get_curr_stat(victim,STAT_DEX);
fight.c:        if (ch->level <= 18)    dam = 30;
fight.c:        else if (ch->level <= 22)   dam = 35;
fight.c:        else if (ch->level <= 25)   dam = 40;
fight.c:        else if (ch->level <= 28)   dam = 45;
fight.c:        else if (ch->level <= 32)   dam = 48;
fight.c:        else if (ch->level <= 35)   dam = 52;
fight.c:        else if (ch->level <= 38)   dam = 56;
fight.c:        else if (ch->level <= 40)   dam = 60;
fight.c:        else if (ch->level <= 43)   dam = 64;
fight.c:        else if (ch->level <= 45)   dam = 68;
fight.c:        else if (ch->level <= 48)   dam = 70;
fight.c:    if (ch->fighting == victim)
fight.c:    || ch->level < skill_table[gsn_nerve].skill_level[ch->Class()->GetIndex()])
fight.c:        victim = ch->fighting;
fight.c:    chance += (ch->level - victim->level)*3;
fight.c:    chance -= get_curr_stat(victim,STAT_DEX)/3;
fight.c:    chance -= get_curr_stat(victim,STAT_CON)/3;
fight.c:    af.duration = (ch->level/5);
fight.c:    af.modifier = -3;
fight.c:    af.level = ch->level;
fight.c:	&& (ch->fighting == NULL
fight.c:	|| victim->fighting == NULL) )
fight.c:    if (victim->fighting == NULL)
fight.c:    || ch->level < skill_table[gsn_endure].skill_level[ch->Class()->GetIndex()])
fight.c:    if (ch->mana < 30)
fight.c:        ch->mana -= 15;
fight.c:    af.modifier = -20;
fight.c:    af.level = ch->level;
fight.c:    af.duration = ch->level;
fight.c:    ch->mana -= 30;
fight.c:        || ch->level < skill_table[gsn_blindness_dust].skill_level[ch->Class()->GetIndex()])
fight.c:        if (ch->mana < 18)
fight.c:        ch->mana -= 9;
fight.c:        if (ch->fighting != NULL)
fight.c:        af.level = ch->level;
fight.c:        af.duration = ch->level/10;
fight.c:        af.modifier = -3;
fight.c:        ch->mana -= 18;
fight.c:        for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
fight.c:        vch_next = vch->next_in_room;
fight.c:        && !saves_spell(ch->level,vch,DAM_OTHER))
fight.c:        && (vch->fighting == NULL || (!fighting)))
fight.c:                if (vch->fighting == NULL)
fight.c:        || ch->level < skill_table[gsn_poison_dust].skill_level[ch->Class()->GetIndex()])
fight.c:        if (ch->mana < 20)
fight.c:        ch->mana -= 10;
fight.c:          if (ch->fighting != NULL)
fight.c:        af.level = ch->level;
fight.c:        af.duration = ch->level/5;
fight.c:        af.modifier = -5;
fight.c:        ch->mana -= 20;
fight.c:        for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
fight.c:        vch_next = vch->next_in_room;
fight.c:        && !saves_spell(ch->level,vch,DAM_POISON))
fight.c:        && (vch->fighting == NULL || (!fighting)))
fight.c:                if (vch->fighting == NULL)
fight.c:        || ch->level < skill_table[gsn_warcry].skill_level[ch->Class()->GetIndex()])
fight.c:        if (ch->mana < 20)
fight.c:        ch->mana -= 10;
fight.c:        af.modifier = ch->level/7;
fight.c:        af.duration = ch->level;
fight.c:        af.level = ch->level;
fight.c:        af.modifier = -(ch->level/5);
fight.c:        ch->mana -= 20;
fight.c:		|| ch->level < skill_table[gsn_strangle].skill_level[ch->Class()->GetIndex()])
fight.c:	if (victim->position == POS_FIGHTING)
fight.c:	af.level = ch->level;
fight.c:	chance += ( 2*ch->level - 2*victim->level);
fight.c:	chance -= get_curr_stat(victim,STAT_DEX)/2;
fight.c:	victim->position = POS_SLEEPING;
fight.c:    || ch->level < skill_table[gsn_enlist].skill_level[ch->Class()->GetIndex()])
fight.c:    for (check = char_list; check != NULL; check = check->next)
fight.c:	if (is_affected(check,gsn_enlist) && check->master == ch)
fight.c:    level = ch->level;
fight.c:        level -= 4;
fight.c:    if ( (victim->level + 8) > level)
fight.c:    victim->leader = ch;
fight.c:    victim->master = ch;
fight.c:    af.level = ch->level;
fight.c:    af.duration = ch->level;
fight.c:                victim = ch->fighting;
fight.c:        else if (!IS_SET(victim->act,ACT_AGGRESSIVE)
fight.c:        && !IS_SET(victim->off_flags,SPAM_MURDER))
fight.c:        chance += (ch->level - victim->level)*3;
fight.c:     victim->last_fought = NULL;
fight.c:        REMOVE_BIT(victim->act,ACT_AGGRESSIVE);
fight.c:        REMOVE_BIT(victim->off_flags,SPAM_MURDER);
fight.c:        || ch->level < skill_table[gsn_find_water].skill_level[ch->Class()->GetIndex()])
fight.c:        if (ch->mana < 15)
fight.c:        if (ch->in_room->sector_type == SECT_WATER
fight.c:        || ch->in_room->sector_type == SECT_UNDERWATER)
fight.c:        ch->mana -= 7;
fight.c:        ch->mana -= 15;
fight.c:        obj_to_room(spring,ch->in_room);
fight.c:                victim = ch->fighting;
fight.c:        || ch->level < skill_table[gsn_shield_cleave].skill_level[ch->Class()->GetIndex()])
fight.c:        || (weapon->value[0] != WEAPON_SWORD
fight.c:        && weapon->value[0] != WEAPON_AXE) )
fight.c:        chance += (ch->level - victim->level)*3;
fight.c:        chance -= shield->level;
fight.c:                chance -= 15;
fight.c:	if (!IS_NPC(victim) && ch->fighting != victim)
fight.c:    	multi_hit(victim,ch,-1);
fight.c:    multi_hit(victim,ch,-1);
fight.c:		for (vch = ch->in_room->people; vch; vch = vch_next)
fight.c:			vch_next = vch->next_in_room;
fight.c:        pRoomIndex = get_room_index(hometown_table[ch->hometown].recall);
fight.c:    for (obj = ch->carrying; obj != NULL; obj = obj_next)
fight.c:        obj_next = obj->next_content;
fight.c:    || (ch->level < skill_table[gsn_forage].skill_level[ch->Class()->GetIndex()]) )
fight.c:    if (ch->in_room->sector_type != SECT_FOREST)
fight.c:        || (ch->level < skill_table[gsn_defend].skill_level[ch->Class()->GetIndex()]) )
fight.c:    if (ch->defending == NULL)
fight.c:    sprintf(buf,"You are defending %s.\n\r",ch->defending->name);
fight.c:    ch->defending = NULL;
fight.c:    if (ch->defending != NULL)
fight.c:        act("You stop defending $N.",ch,0,ch->defending,TO_CHAR);
fight.c:        act("$n stops defending you.",ch,0,ch->defending,TO_VICT);
fight.c:    sprintf(buf,"You start defending %s.\n\r",victim->name);
fight.c:    ch->defending = victim;
fight.c:                victim = ch->fighting;
fight.c:        else if (!IS_SET(victim->act,ACT_AGGRESSIVE)
fight.c:        && !IS_SET(victim->off_flags,SPAM_MURDER))
fight.c:        else if (IS_SET(victim->off_flags,OFF_INTIMIDATED))
fight.c:        chance += (ch->level*3 - victim->level*3);
fight.c:            chance -= 20;
fight.c:        victim->last_fought = NULL;
fight.c:        SET_BIT(victim->off_flags,OFF_INTIMIDATED);
fight.c:    if ( ( victim = ch->fighting ) == NULL ) {
fight.c:        if (ch->position == POS_FIGHTING) {
fight.c:			ch->position = POS_STANDING;
fight.c:    was_in = ch->in_room;
fight.c:    for(panther = ch->in_room->people; panther; panther=panther->next_in_room) {
fight.c:			panther->pcdata->tribe == TRIBE_PANTHER && panther->fighting == ch) ||
fight.c:			(IS_NPC(panther) && panther->fighting == ch && panther->pIndexData->vnum == 3002))
fight.c:        if ( ( pexit = was_in->exit[door] ) == 0
fight.c:        ||   pexit->u1.to_room == NULL
fight.c:        ||   ( IS_SET(pexit->exit_info, EX_CLOSED)
fight.c:        &&   IS_SET(pexit->u1.to_room->room_flags, ROOM_NO_MOB) ) )
fight.c:		if(!is_carrying_type(ch, ITEM_BOAT) && (ch->in_room->exit[door]->u1.to_room->sector_type == SECT_WATER) 
fight.c:		if ( ( now_in = ch->in_room ) == was_in )
fight.c:		ch->last_fought = NULL;
fight.c:		ch->batter = 0;
fight.c:  		ch->in_room = was_in;
fight.c:		ch->in_room = now_in;
fight.c:			if(panther->in_room != ch->in_room)
fight.c:changed if you plan on using this on a PK mud. -Ceran
fight.c:        || ch->level < skill_table[gsn_assassinate].skill_level[ch->Class()->GetIndex()])
fight.c:        if (victim->fighting != NULL || victim->position == POS_FIGHTING)
fight.c:        if (victim->hit < victim->max_hit - 50)
fight.c:        chance += (ch->level * 3);
fight.c:        chance -= (victim->level * 4);
fight.c:        if (victim->position == POS_FIGHTING)
fight.c:                chance -= 10;
fight.c:        else if (victim->position == POS_SLEEPING)
fight.c:        if (victim->level > (ch->level + 8))
fight.c:	if (ch->level == MAX_LEVEL) {
fight.c:        dam = ch->damroll*2;
fight.c:        if (!IS_NPC(victim) && !IS_NPC(ch) && (victim->ghost == 0))
fight.c:    &&    ch->level < skill_table[gsn_lash].skill_level[ch->Class()->GetIndex()])
fight.c:    if (weapon == NULL || (weapon->value[0] != WEAPON_WHIP
fight.c:    && weapon->value[0] != WEAPON_FLAIL) )
fight.c:        chance -= 15;
fight.c:    if (weapon->value[0] != WEAPON_WHIP && weapon->value[0] != WEAPON_FLAIL)
fight.c:        victim = ch->fighting;
fight.c:    if (victim->position == POS_SLEEPING
fight.c:	|| victim->position == POS_RESTING)
fight.c:    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
fight.c:    if (IS_SET(ch->off_flags,OFF_FAST) || is_affected(ch,skill_lookup("haste")))
fight.c:    if (IS_SET(victim->off_flags,OFF_FAST) || IS_AFFECTED(victim,AFF_HASTE))
fight.c:        chance -= 35;
fight.c:    chance -= get_curr_stat(victim,STAT_DEX)/2;
fight.c:        chance -= 30;
fight.c:	&& (ch->Class()->GetIndex() !=CLASS_WARRIOR) )
fight.c:		chance -= 30;
fight.c:       && (ch->Class()->GetIndex()==CLASS_ASSASSIN))
fight.c:    chance += (ch->level - victim->level)*3;
fight.c:    //chance -= 25;
fight.c:	if (!IS_NPC(ch) && !IS_NPC(victim) && (victim->fighting == NULL || ch->fighting == NULL))
fight.c:		if(ch->fighting==NULL)
fight.c:		if(ch->fighting==NULL)
fight.c:        victim->position = POS_RESTING;
fight.c:    ||  (!IS_NPC(ch) && ch->level < skill_table[gsn_pugil].skill_level[ch->Class()->GetIndex()]) )
fight.c:	victim = ch->fighting;
fight.c:    if (ch->fighting == NULL)
fight.c:   if (obj == NULL || obj->value[0] != WEAPON_STAFF)
fight.c:    chance += (ch->level - victim->level);
fight.c:	dam = dice(obj->value[1],obj->value[2]);
fight.c:        if (ch->level <= 20)
fight.c:        else if (ch->level <= 25)
fight.c:        else if (ch->level <= 30)
fight.c:        else if (ch->level <= 35)
fight.c:        else if (ch->level <= 40)
fight.c:        damage_old(ch,victim,dam,gsn_pugil, attack_table[obj->value[3]].damage, TRUE);
fight.c:	|| ch->level <skill_table[gsn_protection_heat_cold].skill_level[ch->Class()->GetIndex()])
fight.c:    af.level = ch->level;
fight.c:    af.duration = ch->level;
fight.c:    if (ch->mana < 10)
fight.c:    if ( ch->fighting == NULL )
fight.c:    if (IS_SET(ch->act,PLR_CRIMINAL))
fight.c:   for (target = ch->in_room->people; target != NULL; target = target_next)
fight.c:    target_next = target->next_in_room;
fight.c:    if (is_same_group(ch,target) || target->position < POS_RESTING)
fight.c:    if (target->position == POS_FIGHTING)
fight.c:    if (ch->mana < 15)
fight.c:    if (ch->fighting == NULL)
fight.c:    if ( target->level > (ch->level + 12) )
fight.c:       if ( number_percent() > ( ch->level - target->level + 70) )
fight.c:       ch->mana -= 15;
fight.c:       act("$n screams and rushes to attack $N!", target, NULL, ch->fighting, TO_NOTVICT);
fight.c:       act("$n screams and rushes forwards to attack you!", target, NULL, ch->fighting, TO_VICT);
fight.c:       multi_hit(target, ch->fighting, TYPE_UNDEFINED);
fight.c:    if (ch->mana < 100)
fight.c:        ch->mana -= 50;
fight.c:    af.level = ch->level;
fight.c:    af.duration = ch->level/3;
fight.c:    ch->mana -= 100;
fight.c:    || ch->level < skill_table[gsn_quiet_movement].skill_level[ch->Class()->GetIndex()])
fight.c:    if (ch->in_room->sector_type == SECT_FOREST)
fight.c:    else if (ch->in_room->sector_type == SECT_MOUNTAIN)
fight.c:    else if (ch->in_room->sector_type == SECT_HILLS)
fight.c:    af.duration = ch->level;
fight.c:    af.level = ch->level;
fight.c:	if(ch->in_room != victim->in_room)
fight.c:		if(one_hit_new(victim,ch,gsn_parting_blow,HIT_NOSPECIALS,HIT_UNBLOCKABLE,HIT_NOADD,100,NULL) == -1) //death
fight.c:	for(cabalguardian=char_list;cabalguardian!=NULL;cabalguardian=cabalguardian->next)
fight.c:		if(IS_NPC(cabalguardian) && cabalguardian->cabal==cabal && IS_CABAL_GUARD(cabalguardian))
fight.c:                damage_old(victim,ch,dice(victim->level,5),gsn_blade_barrier,DAM_SLASH,TRUE);
fight.c:		if(!style_check(gsn_maneuvering, victim->pcdata->style))
fight.c:        for (vch = victim->in_room->people; vch != NULL; vch = vch_next)
fight.c:                vch_next = vch->next_in_room;
fight.c:				if(vch->fighting == victim && victim->fighting != vch)
fight.c:	chance -= ch->level - victim->level;
fight.c:	if(ch == victim->fighting || !ableth)
fight.c:	chance -= (int)((float) chance * .35);
fight.c:		IS_NPC(victim->fighting) ? victim->fighting->short_descr : victim->fighting->name,
fight.c:		IS_NPC(ch) ? ch->short_descr : ch->name);
fight.c:		IS_NPC(victim) ? victim->short_descr : victim->name);
fight.c:		if(!style_check(gsn_catch, ch->pcdata->style))
fight.c:			ch,weapon_name_lookup(obj->value[0]),victim,TO_CHAR);
fight.c:			ch,weapon_name_lookup(obj->value[0]),victim,TO_VICT);
fight.c:			ch,weapon_name_lookup(obj->value[0]),victim,TO_NOTVICT);
fight.c:	if(!attack_lookup(form_table[ch->pcdata->shifted].attack_type))
fight.c:	return attack_table[attack_lookup(form_table[ch->pcdata->shifted].attack_type)].noun;
fight.c:          tmp_dt += wield->value[3];
fight.c:          tmp_dt += ch->dam_type;
fight.c:          attack = attack_table[tmp_dt - TYPE_HIT].noun;
fight.c://	return attack_lookup(form_table[ch->pcdata->shifted].attack_type);
fight.c:          tmp_dt += wield->value[3];
fight.c:          tmp_dt += ch->dam_type;
fight.c:      	return (tmp_dt - TYPE_HIT);
fight.c:	for(corpse = ch->in_room->contents; corpse; corpse = corpse->next_content)
fight.c:		if(!str_cmp(corpse->owner, victim->true_name))
fight.c:	if(!corpse || !belt || belt->pIndexData->vnum != OBJ_VNUM_TROPHY_BELT)
fight.c:	if (!ch->pcdata->trophy)
fight.c:		belt->value[4] = 0;
fight.c:	scalps = belt->value[4];
fight.c:	newbelt->value[4] = scalps;
fight.c:	oaf.level		= ch->level;
fight.c:	oaf.duration	= -1;
fight.c:	oaf.modifier	= (newbelt->value[4] + 1) / 2;
fight.c:	oaf.modifier	= UMAX((newbelt->value[4] + 1) / 2 - (newbelt->value[4] % 2) + 1,1);
fight.c:	if(newbelt->value[4] == 0)
fight.c:		ch->pcdata->trophy = new_trophy_data(victim->true_name);
fight.c:		placeholder = ch->pcdata->trophy;
fight.c:		for (i=1;i < newbelt->value[4];i++)
fight.c:			if (!ch->pcdata->trophy)
fight.c:			if (!ch->pcdata->trophy->next)
fight.c:			ch->pcdata->trophy = ch->pcdata->trophy->next;
fight.c:		ch->pcdata->trophy = ch->pcdata->trophy->next = new_trophy_data(victim->true_name);
fight.c:		ch->pcdata->trophy = placeholder;
fight.c:	newbelt->value[4]++;
fight.c:	if(!style_check(gsn_sidestep, victim->pcdata->style))
fight.c:	if (victim->fighting)
fight.c:	if(victim->pcdata->energy_state < -4)
fight.c:		if(!style_check(gsn_terrain_mastery, ch->pcdata->style))
fight.c:			total+=ch->pcdata->sect_time[i];
fight.c:		sect_per=(float)(ch->pcdata->sect_time[ch->in_room->sector_type])/(float)total * 100;
fight.c:		return (int)(sect_per / (10 - 0.36*(ch->mod_stat[STAT_INT])));
fight.c:		(IS_SET(ch->act,ACT_UNDEAD) || IS_SET(ch->form,FORM_UNDEAD)))
fight.c:	if (!af->owner)
fight.c:		af->owner = ch;
fight.c:	damage_new(af->owner,ch,af->level,gsn_bleeding,DAM_OTHER,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,NULL);
fight.c:	if ((!IS_NPC(ch)) && str_cmp(race_table[ch->race].name,"minotaur")
fight.c:		&& !IS_SET(ch->parts,PART_HORNS))
fight.c:	if (ch->fighting)
fight.c:		dam = dice(ch->level,5);
fight.c:			af.level		=	ch->level;
fight.c:			af.modifier		=	-ch->level/10;
fight.c:		ch->position = POS_RESTING;
fight.c:	if ((victim = ch->fighting) == NULL)
fight.c:	if (ch->size < (victim->size - 1))
fight.c:	if (ch->size > (victim->size + 1))
fight.c:		act("You slam your forehead into $N with bone-jarring force!",ch,0,victim,TO_CHAR);
fight.c:		act("$n slams $s forehead into $N with bone-jarring force!",ch,0,victim,TO_NOTVICT);
fight.c:		dam = dice(ch->level/2,3);
fight.c:		if (number_percent() < 3 && !IS_SET(victim->imm_flags,IMM_BASH
fight.c:			&& !IS_SET(victim->imm_flags,IMM_SLEEP))) {
fight.c:			af.level		=	ch->level;
fight.c:			victim->position = POS_SLEEPING;
fight.c:			af.level		=	ch->level;
fight.c:			ch->position = POS_SLEEPING;
fight.c:	if (!ch->fighting)
fight.c:	if (ch->fighting->fighting == ch)
fight.c:	act("You cease attacking $N.",ch,0,ch->fighting,TO_CHAR);
fight.c:	act("$n ceases attacking you.",ch,0,ch->fighting,TO_VICT);
fight.c:	act("$n ceases attacking $N.",ch,0,ch->fighting,TO_NOTVICT);
fight.c:	if (wield->value[0] == weapon)
fight.c:	if (wield->value[0] == weapon)
file.c:				ungetc(*pbuf--, fp); //clever!
flags.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
flags.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
flags.c:    if (type == '=' || type == '-' || type == '+')
flags.c:	send_to_char("  flag mob  <name> <field> <+/-/=> <flags>\n\r",ch);
flags.c:	send_to_char("  flag char <name> <field> <+/-/=> <flags>\n\r",ch);
flags.c:	send_to_char("  flag obj  <name> <field> <+/-/=> <flags>\n\r",ch);
flags.c:	send_to_char("  +: add flag, -: remove flag, = set equal to\n\r",ch);
flags.c:	    flag = &victim->act[0];
flags.c:	    flag = &victim->act[0];
flags.c:            flag = &victim->affected_by[0];
flags.c:            flag = &victim->imm_flags[0];
flags.c:            flag = &victim->res_flags[0];
flags.c:            flag = &victim->vuln_flags[0];
flags.c:            flag = &victim->off_flags[0];
flags.c:            flag = &victim->form[0];
flags.c:            flag = &victim->parts[0];
flags.c:            flag = &victim->comm[0];
flags.c:            	flag = &obj->wear_flags[0];
flags.c:		flag = &obj->extra_flags[0];
flags.c:	send_to_char("  flag mob  <name> <field> <+/-/=> <flags>\n\r",ch);
flags.c:	send_to_char("  flag char <name> <field> <+/-/=> <flags>\n\r",ch);
flags.c:	send_to_char("  flag obj  <name> <field> <+/-/=> <flags>\n\r",ch);
flags.c:	send_to_char("  +: add flag, -: remove flag, = set equal to\n\r",ch);
flags.c:		    case '-':
handler.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
handler.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
handler.c:/* friend stuff -- for NPC's mostly */
handler.c:	if (IS_SET(ch->off_flags,ASSIST_PLAYERS))
handler.c:    if (IS_SET(ch->off_flags,ASSIST_ALL))
handler.c:    if (ch->group && ch->group == victim->group)
handler.c:    if (IS_SET(ch->off_flags,ASSIST_VNUM)
handler.c:    &&  ch->pIndexData == victim->pIndexData)
handler.c:    if (IS_SET(ch->off_flags,ASSIST_RACE) && ch->race == victim->race)
handler.c:    if (IS_SET(ch->off_flags,ASSIST_ALIGN)
handler.c:    &&  !IS_SET(ch->act,ACT_NOALIGN) && !IS_SET(victim->act,ACT_NOALIGN)
handler.c:    if (obj->in_room == NULL)
handler.c:    for (fch = obj->in_room->people; fch != NULL; fch = fch->next_in_room)
handler.c:	if (fch->on == obj)
handler.c:   return -1;
handler.c:   return -1;
handler.c:    return -1;
handler.c:    return -1;
handler.c:    return -1;
handler.c:    return -1;
handler.c:    	    case '-': 	
handler.c:   three other cases -- wood, silver, and iron -- are checked in fight.c */
handler.c:    immune = -1;
handler.c:	if (IS_SET(ch->imm_flags,IMM_WEAPON))
handler.c:	else if (IS_SET(ch->res_flags,RES_WEAPON))
handler.c:	else if (IS_SET(ch->vuln_flags,VULN_WEAPON))
handler.c:	if (IS_SET(ch->imm_flags,IMM_MAGIC))
handler.c:	else if (IS_SET(ch->res_flags,RES_MAGIC))
handler.c:	else if (IS_SET(ch->vuln_flags,VULN_MAGIC))
handler.c:    /* set bits to check -- VULN etc. must ALL be the same or this will fail */
handler.c:    if (IS_SET(ch->imm_flags,bit))
handler.c:    else if (IS_SET(ch->res_flags,bit) && immune != IS_IMMUNE)
handler.c:    else if (IS_SET(ch->vuln_flags,bit))
handler.c:    if (immune == -1)
handler.c:    return ch->cabal;
handler.c:    if (cabal_table[ch->cabal].independent)
handler.c:        return (ch->cabal == victim->cabal);
handler.c:    if (ch->pIndexData == NULL)
handler.c:    else if (ch->pIndexData->new_format)
handler.c:    if(IS_NPC(ch) && ch->desc && ch->desc->original && IS_SET(ch->comm, COMM_SWITCHSKILLS))
handler.c:	ch = ch->desc->original;
handler.c:    if (sn == -1) /* shorthand for level based skills */
handler.c:		skill = ch->level * 5 / 2;
handler.c:    else if (sn < -1 || sn > MAX_SKILL) {
handler.c:		if (ch->level < skill_table[sn].skill_level[ch->Class()->GetIndex()] && !IS_IMMORTAL(ch))
handler.c:			skill = ch->pcdata->learned[sn];
handler.c:		if (skill == -2)
handler.c:	} else if (ch->pIndexData->Class()->GetIndex() > CLASS_NONE) {
handler.c:		if (ch->level < skill_table[sn].skill_level[ch->pIndexData->Class()->GetIndex()])
handler.c:		else if (ch->pIndexData->Class()->GetIndex() == CLASS_WARRIOR) {
handler.c:			if (!style_check(sn,ch->mobstyle))	
handler.c:				skill = URANGE(0, 50 + 2 * (ch->level - skill_table[sn].skill_level[ch->pIndexData->Class()->GetIndex()]), 100);
handler.c:		} else if (ch->pIndexData->Class()->GetIndex() == CLASS_SORCERER) {
handler.c:			skill = URANGE(0, 50 + 2 * (ch->level - skill_table[sn].skill_level[ch->pIndexData->Class()->GetIndex()]), 100);
handler.c:	    		skill = 40 + 2 * ch->level;
handler.c:			skill = ch->level * 2 + 20;
handler.c:		else if ((sn == gsn_dodge && IS_SET(ch->off_flags,OFF_DODGE))
handler.c:			|| (sn == gsn_parry && IS_SET(ch->off_flags,OFF_PARRY)))
handler.c:			skill = ch->level * 2;
handler.c:			skill = 25 + 2 * ch->level;
handler.c:		else if ((sn == gsn_trip && IS_SET(ch->off_flags,OFF_TRIP)) ||
handler.c:			(sn == gsn_bash && IS_SET(ch->off_flags,OFF_BASH)) ||
handler.c:			(sn == gsn_disarm && IS_SET(ch->off_flags,OFF_DISARM)) ||
handler.c:			(sn == gsn_berserk && IS_SET(ch->off_flags,OFF_BERSERK)) ||
handler.c:			(sn == gsn_tail && IS_SET(ch->off_flags,OFF_TAIL)))
handler.c:			skill = 35 + 2 * ch->level;
handler.c:			skill = 50 + 5 * ch->level / 2;
handler.c:			&& IS_SET(ch->progtypes,MPROG_FIGHT) ) {
handler.c:			if ((!str_cmp(group_table[gn].name,"gladiator") && !str_cmp(ch->pIndexData->mprogs->fight_name,"fight_prog_gladiator"))
handler.c:				||  (!str_cmp(group_table[gn].name,"barbarian") && !str_cmp(ch->pIndexData->mprogs->fight_name,"fight_prog_barbarian"))
handler.c:				||  (!str_cmp(group_table[gn].name,"duelist") && !str_cmp(ch->pIndexData->mprogs->fight_name,"fight_prog_duelist"))
handler.c:				||  (!str_cmp(group_table[gn].name,"skirmisher") && !str_cmp(ch->pIndexData->mprogs->fight_name,"fight_prog_skirmisher"))
handler.c:				||  (!str_cmp(group_table[gn].name,"dragoon") && !str_cmp(ch->pIndexData->mprogs->fight_name,"fight_prog_dragoon"))
handler.c:				||  (!str_cmp(group_table[gn].name,"tactician") && !str_cmp(ch->pIndexData->mprogs->fight_name,"fight_prog_tactician")))
handler.c:				skill = ch->level + 50;
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK]  > 10 )
handler.c:		skill-= 5;
handler.c:	if(is_affected_room(ch->in_room,gsn_infidels_fate) && IS_GOOD(ch))
handler.c:	if (ch->fighting && is_affected(ch->fighting,gsn_traitors_luck)) 
handler.c:		af = affect_find(ch->fighting->affected,gsn_traitors_luck);
handler.c:		if (ch == af->owner)
handler.c:	if(ch->fighting && (IS_EVIL(ch) && is_affected(ch->fighting,gsn_awe)) 
handler.c:			&& (ch->level > ch->fighting->level) && number_percent() > 96)
handler.c:    if (wield == NULL || wield->item_type != ITEM_WEAPON)
handler.c:    else switch (wield->value[0])
handler.c:        default :               sn = -1;                break;
handler.c:     /* -1 is exotic */
handler.c:	if (sn == -1)
handler.c:	    skill = 3 * ch->level;
handler.c:	    skill = 40 + 2 * ch->level;
handler.c:	    skill = 40 + 5 * ch->level / 2;
handler.c:	if (sn == -1)
handler.c:	    skill = 3 * ch->level;
handler.c:	    skill = ch->pcdata->learned[sn];
handler.c:/* used to de-screw characters */
handler.c:    if (ch->pcdata->perm_hit == 0
handler.c:    ||	ch->pcdata->perm_mana == 0
handler.c:    ||  ch->pcdata->perm_move == 0
handler.c:    ||	ch->pcdata->last_level == 0)
handler.c:	    for ( af = obj->charaffs; af != NULL; af = af->next )
handler.c:			affect_strip(ch, af->type);
handler.c:		for ( app = obj->apply; app != NULL; app = app->next )
handler.c:			modify_location(ch, app->location, app->modifier, FALSE);
handler.c:	ch->pcdata->perm_hit 	= ch->max_hit;
handler.c:	ch->pcdata->perm_mana 	= ch->max_mana;
handler.c:	ch->pcdata->perm_move	= ch->max_move;
handler.c:	ch->pcdata->last_level	= ch->played/3600;
handler.c:	if (ch->pcdata->true_sex < 0 || ch->pcdata->true_sex > 2)
handler.c:		if (ch->sex > 0 && ch->sex < 3)
handler.c:	    	    ch->pcdata->true_sex	= ch->sex;
handler.c:		    ch->pcdata->true_sex 	= 0;
handler.c:	ch->mod_stat[stat] = 0;
handler.c:    if (ch->pcdata->true_sex < 0 || ch->pcdata->true_sex > 2)
handler.c:	ch->pcdata->true_sex = 0;
handler.c:    ch->sex		= ch->pcdata->true_sex;
handler.c:    ch->max_hit 	= ch->pcdata->perm_hit;
handler.c:    ch->max_mana	= ch->pcdata->perm_mana;
handler.c:    ch->max_move	= ch->pcdata->perm_move;
handler.c:    	ch->armor[i]	= 0;
handler.c:    ch->hitroll		= 0;
handler.c:    ch->damroll		= 0;
handler.c:    ch->saving_throw	= 0;
handler.c:	    ch->armor[i] += apply_ac( obj, loc, i );
handler.c:	for ( af = obj->charaffs; af != NULL; af = af->next )
handler.c:	for ( app = obj->apply; app != NULL; app = app->next )
handler.c:		modify_location(ch, app->location, app->modifier, TRUE);
handler.c:    for (af = ch->affected; af != NULL; af = af->next)
handler.c:	modify_location(ch, af->location, af->modifier, TRUE);
handler.c:    if (ch->sex < 0 || ch->sex > 2)
handler.c:	ch->sex = ch->pcdata->true_sex;
handler.c:    if ( ch->desc != NULL && ch->desc->original != NULL )
handler.c:		ch = ch->desc->original;
handler.c:    if (ch->trust)
handler.c:		return ch->trust;
handler.c:    if ( IS_NPC(ch) && ch->level >= LEVEL_HERO )
handler.c:		return LEVEL_HERO - 1;
handler.c:		return ch->level;
handler.c:    iClass = ch->Class()->GetIndex();
handler.c:    if (IS_NPC(ch) || ch->level > LEVEL_IMMORTAL)
handler.c:	max = pc_race_table[ch->race].max_stats[stat];
handler.c:    if (!str_cmp(race_table[ch->race].name,"human"))
handler.c:	switch(ch->Class()->attr_prime) {
handler.c:			(ch->Class()->GetIndex() == CLASS_WARRIOR ||
handler.c:			ch->Class()->GetIndex() == CLASS_ANTI_PALADIN ||
handler.c:			ch->Class()->GetIndex() == CLASS_RANGER ||
handler.c:			ch->Class()->GetIndex() == CLASS_PALADIN))
handler.c:			(ch->Class()->GetIndex() == CLASS_SORCERER ||
handler.c:			ch->Class()->GetIndex() == CLASS_NECROMANCER ||
handler.c:			ch->Class()->GetIndex() == CLASS_SHAPESHIFTER))             
handler.c:                        (ch->Class()->GetIndex() == CLASS_HEALER || 
handler.c:                        ch->Class()->GetIndex() == CLASS_ZEALOT)) 
handler.c:                        (ch->Class()->GetIndex() == CLASS_ASSASSIN || 
handler.c:                        ch->Class()->GetIndex() == CLASS_THIEF))   
handler.c:	if (ch->fighting && is_affected(ch->fighting,gsn_traitors_luck)) {
handler.c:		af = affect_find(ch->fighting->affected,gsn_traitors_luck);
handler.c:		if (ch == af->owner)
handler.c:    return UMIN(URANGE(3,ch->perm_stat[stat] + ch->mod_stat[stat], max) + mod,25);
handler.c:    iClass = (ch->Class()->GetIndex() + 1);
handler.c:    if (IS_NPC(ch) || ch->level > LEVEL_IMMORTAL)
handler.c:    max = pc_race_table[ch->race].max_stats[stat];
handler.c:    if (!str_cmp(race_table[ch->race].name,"human"))
handler.c:        switch(ch->Class()->attr_prime) {
handler.c:                        (ch->Class()->name == "warrior" ||
handler.c:                        ch->Class()->name == "anti-paladin" ||
handler.c:                        ch->Class()->name == "ranger" ||
handler.c:                        ch->Class()->name == "paladin"))
handler.c:                        (ch->Class()->name == "sorcerer" ||
handler.c:                        ch->Class()->name == "necromancer" ||
handler.c:                        ch->Class()->name == "shapeshifter"))
handler.c:                        (ch->Class()->name == "healer" ||
handler.c:                        ch->Class()->name == "zealot"))
handler.c:                        (ch->Class()->name == "assassin" ||
handler.c:                        ch->Class()->name == "thief"))
handler.c:    if ( !IS_NPC(ch) && ch->level >= LEVEL_IMMORTAL )
handler.c:    if ( IS_NPC(ch) && IS_SET(ch->act, ACT_PET) )
handler.c:    return MAX_WEAR + ch->level/6 + dex_app[get_curr_stat(ch,STAT_DEX)].carry;
handler.c:    if ( !IS_NPC(ch) && ch->level >= LEVEL_IMMORTAL )
handler.c:    if ( IS_NPC(ch) && IS_SET(ch->act, ACT_PET) )
handler.c:    return MAX_WEAR + ch->level*2 + str_app[get_curr_stat(ch,STAT_STR)].carry;
handler.c:	|| (ch->ghost > 0)
handler.c:	|| (victim->ghost > 0)
handler.c:	|| (ch->level < MIN_LEVEL_TO_PK)
handler.c:	|| (victim->level < MIN_LEVEL_TO_PK)
handler.c:	|| abs(victim->level - ch->level) > 9)
handler.c:		&& ch->level == LEVEL_HERO 
handler.c:		&& victim->level == LEVEL_HERO)
handler.c:    xp = ch->exp;
handler.c:    vxp = victim->exp;
handler.c:        if (ch->level - victim->level < MIN_LEVEL_TO_PK
handler.c:            && ch->level - victim->level > -MIN_LEVEL_TO_PK)
handler.c:	paf->where		= TO_AFFECTS;
handler.c:	paf->name		= NULL;
handler.c:	paf->type		= 0;
handler.c:	paf->aftype		= AFT_SPELL;
handler.c:	paf->level		= 0;
handler.c:	paf->init_duration = 0;
handler.c:	paf->duration	= 0;
handler.c:	paf->location	= 0;
handler.c:	paf->modifier	= 0;
handler.c:	paf->mod_name	= MOD_NONE;
handler.c:	zero_vector(paf->bitvector);
handler.c:	paf->tick_fun	= NULL;
handler.c:	paf->pulse_fun	= NULL;
handler.c:	paf->end_fun	= NULL;
handler.c:	paf->owner		= NULL;
handler.c:	paf->beat_fun	= NULL;
handler.c:    mod = paf->modifier;
handler.c:	switch (paf->where)
handler.c:	    BITWISE_OR(ch->affected_by, paf->bitvector);
handler.c:	    BITWISE_OR(ch->imm_flags,paf->bitvector);
handler.c:	    BITWISE_OR(ch->res_flags,paf->bitvector);
handler.c:	    BITWISE_OR(ch->vuln_flags,paf->bitvector);
handler.c:        switch (paf->where)
handler.c:            BITWISE_XAND(ch->affected_by, paf->bitvector);
handler.c:            BITWISE_XAND(ch->imm_flags, paf->bitvector);
handler.c:            BITWISE_XAND(ch->res_flags, paf->bitvector);
handler.c:            BITWISE_XAND(ch->vuln_flags, paf->bitvector);
handler.c:    modify_location(ch, paf->location, paf->modifier, fAdd);
handler.c:	    depth--;
handler.c:	    depth--;
handler.c:	if ((wield = get_eq_char(ch,WEAR_WIELD)) != NULL && ch->arms < 1)
handler.c:			depth--;
handler.c:	if ((wield = get_eq_char(ch,WEAR_DUAL_WIELD)) != NULL && ch->arms < 2)
handler.c:			depth--;
handler.c:	if ((wield = get_eq_char(ch,WEAR_WIELD)) != NULL && ch->arms < 2 && ch->size < SIZE_LARGE
handler.c:		|| wield->value[0] == WEAPON_STAFF
handler.c:		|| wield->value[0] == WEAPON_POLEARM
handler.c:		|| wield->value[0] == WEAPON_SPEAR) )
handler.c:			depth--;
handler.c:    for ( paf_find = paf; paf_find != NULL; paf_find = paf_find->next )
handler.c:        if ( paf_find->type == sn )
handler.c:	for (paf_find = paf; paf_find != NULL; paf_find = paf_find->next ) {
handler.c:		if (paf_find->type == sn )
handler.c:    for ( paf_find = paf; paf_find != NULL; paf_find = paf_find->next )
handler.c:        if ( paf_find->type == sn )
handler.c:	for (paf_find = paf; paf_find != NULL; paf_find = paf_find->next)
handler.c:		if (paf_find->type == sn)
handler.c:    for (paf = ch->affected; paf != NULL; paf = paf->next)
handler.c:		if (paf->where == where && vector_equal(paf->bitvector, vector)) {
handler.c:		    BITWISE_OR(ch->affected_by,vector);
handler.c:		    BITWISE_OR(ch->imm_flags,vector);
handler.c:		    BITWISE_OR(ch->res_flags,vector);
handler.c:		    BITWISE_OR(ch->vuln_flags,vector);
handler.c:    if(IS_SET(ch->imm_flags,IMM_SLEEP) && IS_SET(paf->bitvector,AFF_SLEEP) && paf->where==TO_AFFECTS)
handler.c:		&& IS_SET(paf->bitvector,AFF_SLEEP)
handler.c:		&& ch->position==POS_SLEEPING)
handler.c:	if(is_affected(ch,gsn_indom) && paf->aftype != AFT_TIMER) 
handler.c:	paf->init_duration = paf->duration;
handler.c:    paf_new->next	= ch->affected;
handler.c:    ch->affected	= paf_new;
handler.c:	/* Morg - Valgrind fix */
handler.c:	paf_new->valid	= TRUE;
handler.c:    if ( ch->affected == NULL )
handler.c:    if(paf->end_fun != NULL)
handler.c:		(*paf->end_fun) (ch, paf);
handler.c:    where = paf->where;
handler.c:    copy_vector(vector, paf->bitvector);
handler.c:    if ( paf == ch->affected )
handler.c:		ch->affected	= paf->next;
handler.c:		for ( prev = ch->affected; prev != NULL; prev = prev->next )
handler.c:	    	if ( prev->next == paf )
handler.c:				prev->next = paf->next;
handler.c:    for ( paf = ch->affected; paf != NULL; paf = paf_next )
handler.c:	paf_next = paf->next;
handler.c:	if ( paf->type == sn ) {
handler.c:    for ( paf = ch->affected; paf != NULL; paf = paf->next )
handler.c:	if ( paf->type == sn )
handler.c:    for ( paf = obj->affected; paf != NULL; paf = paf->next )
handler.c:	if ( paf->type == sn )
handler.c:	paf->owner = NULL;
handler.c:	paf->end_fun = NULL;
handler.c:	for ( paf_old = ch->affected; paf_old != NULL; paf_old = paf_old->next )
handler.c:	if ( paf_old->type == paf->type )
handler.c:	    paf->level = (paf->level + paf_old->level) / 2;
handler.c:	    paf->duration += paf_old->duration;
handler.c:	    paf->modifier += paf_old->modifier;
handler.c:    ROOM_INDEX_DATA *prev_room = ch->in_room;
handler.c:    if ( ch->in_room == NULL )
handler.c:		--ch->in_room->area->nplayer;
handler.c:	for (obj = ch->carrying; obj; obj = obj->next_content)
handler.c:		if (obj->wear_loc != WEAR_NONE)
handler.c:			if ((obj->item_type == ITEM_LIGHT || IS_OBJ_STAT(obj,ITEM_GLOW))
handler.c:				&& ch->in_room)
handler.c:				ch->in_room->light = UMAX(0,ch->in_room->light - 3);
handler.c:	if(IS_SET(ch->progtypes,MPROG_MOVE))
handler.c:	for(mob = ch->in_room->people; mob; mob = mob->next_in_room)
handler.c:		if(mob != ch && IS_SET(mob->progtypes,MPROG_MOVE))
handler.c:		ch->in_room->move_progs = FALSE;
handler.c:    if ( ch == ch->in_room->people )
handler.c:	ch->in_room->people = ch->next_in_room;
handler.c:	for ( prev = ch->in_room->people; prev; prev = prev->next_in_room )
handler.c:	    if ( prev->next_in_room == ch )
handler.c:		prev->next_in_room = ch->next_in_room;
handler.c:    ch->in_room      = NULL;
handler.c:    ch->next_in_room = NULL;
handler.c:    ch->on 	     = NULL;  /* sanity check! */
handler.c:        for ( af = prev_room->affected; af != NULL; af = af->next )
handler.c:             if (af->type == gsn_gravity_well)
handler.c:        if(ch == af->owner)
handler.c:		for (aaf = ch->affected; aaf != NULL; aaf = aaf->next)
handler.c:			if (aaf->type == gsn_entwine && (aaf->modifier == 1 || aaf->location == APPLY_DEX))
handler.c:		do_uncoil(aaf->owner,"automagic");
handler.c:    ch->in_room		= pRoomIndex;
handler.c:    ch->next_in_room	= pRoomIndex->people;
handler.c:    pRoomIndex->people	= ch;
handler.c:		if (ch->in_room->area->empty)
handler.c:	    		ch->in_room->area->empty = FALSE;
handler.c:		++ch->in_room->area->nplayer;
handler.c:	if (ch->home_room == NULL)
handler.c:		ch->home_room = pRoomIndex;
handler.c:	for (obj = ch->carrying; obj; obj = obj->next_content)
handler.c:		if (obj->wear_loc != WEAR_NONE)
handler.c:			if ((obj->item_type == ITEM_LIGHT || IS_OBJ_STAT(obj,ITEM_GLOW))
handler.c:				&& ch->in_room)
handler.c:				ch->in_room->light += 3;
handler.c:    if(IS_SET(ch->progtypes,MPROG_MOVE))
handler.c:	ch->in_room->move_progs = TRUE;
handler.c:		for ( af = ch->affected; af; af = af->next)
handler.c:            if (af->tick_fun == plague_tick) {
handler.c:            REMOVE_BIT(ch->affected_by,AFF_PLAGUE);
handler.c:    if ((!IS_ZERO_VECTOR(ch->in_room->affected_by) || ch->in_room->has_rune) && IS_IMMORTAL(ch))
handler.c:    obj->next_content	 = ch->carrying;
handler.c:    ch->carrying	 = obj;
handler.c:    obj->carried_by	 = ch;
handler.c:    obj->in_room	 = NULL;
handler.c:    obj->in_obj		 = NULL;
handler.c:    ch->carry_number	+= get_obj_number( obj );
handler.c:    ch->carry_weight	+= get_obj_weight( obj );
handler.c:    if ( ( ch = obj->carried_by ) == NULL )
handler.c:    if ( obj->wear_loc != WEAR_NONE )
handler.c:    if ( ch->carrying == obj )
handler.c:	ch->carrying = obj->next_content;
handler.c:	for ( prev = ch->carrying; prev != NULL; prev = prev->next_content )
handler.c:	    if ( prev->next_content == obj )
handler.c:		prev->next_content = obj->next_content;
handler.c:    obj->carried_by	 = NULL;
handler.c:    obj->next_content	 = NULL;
handler.c:    ch->carry_number	-= get_obj_number( obj );
handler.c:    ch->carry_weight	-= get_obj_weight( obj );
handler.c:    if ( obj->item_type != ITEM_ARMOR )
handler.c:    case WEAR_STRAPPED: return     obj->value[type];
handler.c:    case WEAR_BODY:	return 3 * obj->value[type];
handler.c:    case WEAR_HEAD:	return     obj->value[type];
handler.c:    case WEAR_LEGS:	return     obj->value[type];
handler.c:    case WEAR_FEET:	return     obj->value[type];
handler.c:    case WEAR_HANDS:	return     obj->value[type];
handler.c:    case WEAR_ARMS:	return     obj->value[type];
handler.c:    case WEAR_SHIELD:	return     obj->value[type];
handler.c:    case WEAR_NECK_1:	return     obj->value[type];
handler.c:    case WEAR_NECK_2:	return     obj->value[type];
handler.c:    case WEAR_ABOUT:	return 2 * obj->value[type];
handler.c:    case WEAR_WAIST:	return     obj->value[type];
handler.c:    case WEAR_WRIST_L:	return     obj->value[type];
handler.c:    case WEAR_WRIST_R:	return     obj->value[type];
handler.c:    case WEAR_HOLD:	return     obj->value[type];
handler.c:    case WEAR_FINGER_L: return     obj->value[type];
handler.c:    case WEAR_FINGER_R: return     obj->value[type];
handler.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
handler.c:	if ( obj->wear_loc == iWear )
handler.c:    if(obj->wear_loc > WEAR_NONE)
handler.c:	sprintf(buf,"Equip_char: already equipped (%d) -- %s -- %s.",iWear,ch->name, ch->in_room->area->file_name);
handler.c:    ||   ( IS_OBJ_STAT(obj, ITEM_ANTI_LAWFUL)  && (ch->pcdata->ethos > 0))
handler.c:    ||   ( IS_OBJ_STAT(obj, ITEM_ANTI_NEUT)    && (ch->pcdata->ethos == 0))
handler.c:    ||   ( IS_OBJ_STAT(obj, ITEM_ANTI_CHAOTIC) && (ch->pcdata->ethos < 0))
handler.c:	obj_to_room( obj, ch->in_room );
handler.c:	obj->wear_loc = iWear;
handler.c:	if (show && IS_SET(obj->progtypes,IPROG_WEAR))
handler.c:		(obj->pIndexData->iprogs->wear_prog) (obj,ch);
handler.c:	BITWISE_OR(ch->imm_flags, obj->imm_flags);
handler.c:	BITWISE_OR(ch->res_flags, obj->res_flags);
handler.c:	BITWISE_OR(ch->vuln_flags, obj->vuln_flags);
handler.c:    	ch->armor[i]      	+= apply_ac( obj, iWear,i );
handler.c:	for ( app = obj->apply; app ; app = app->next)
handler.c:		modify_location( ch, app->location, app->modifier, TRUE);
handler.c:	for ( paf = obj->charaffs; paf != NULL; paf = paf->next )
handler.c:	if ((obj->item_type == ITEM_LIGHT || IS_OBJ_STAT(obj,ITEM_GLOW))
handler.c:		&& ch->in_room)
handler.c:		ch->in_room->light += 3;
handler.c:    if(show && obj->pIndexData->wear_echo[0]!=NULL)
handler.c:        act(palloc_string(obj->pIndexData->wear_echo[0]),ch,obj,0,TO_CHAR);
handler.c:    if(show && obj->pIndexData->wear_echo[1]!=NULL)
handler.c:        act(palloc_string(obj->pIndexData->wear_echo[1]),ch,obj,0,TO_ROOM);
handler.c:    int i, wearloc = obj->wear_loc;
handler.c:    if ( obj->wear_loc == WEAR_NONE )
handler.c:	if ( obj->wear_loc == WEAR_WIELD && check_entwine(obj->carried_by,0))
handler.c:		do_uncoil(obj->carried_by,"automagic");
handler.c:	obj->wear_loc = -1;
handler.c:	if (show && IS_SET(obj->progtypes,IPROG_REMOVE))
handler.c:        (obj->pIndexData->iprogs->remove_prog) (obj,ch);
handler.c:	if(obj->wear_loc == WEAR_COSMETIC)
handler.c:    	ch->armor[i]	-= apply_ac( obj, wearloc, i );
handler.c:	BITWISE_XOR(ch->imm_flags, obj->imm_flags);
handler.c:	BITWISE_XOR(ch->res_flags, obj->res_flags);
handler.c:	BITWISE_XOR(ch->vuln_flags, obj->vuln_flags);
handler.c:	for (app = obj->apply; app; app = app->next)
handler.c:		modify_location(ch, app->location, app->modifier, FALSE);
handler.c:	for ( paf = obj->charaffs; paf != NULL; paf = paf->next )
handler.c:		affect_strip(ch, paf->type);
handler.c:	if ((obj->item_type == ITEM_LIGHT || IS_OBJ_STAT(obj, ITEM_GLOW))
handler.c:		&& ch->in_room)
handler.c:		ch->in_room->light = UMAX(0, ch->in_room->light - 3);
handler.c:    if(show && obj->pIndexData->remove_echo[0]!=NULL)
handler.c:        act(palloc_string(obj->pIndexData->remove_echo[0]),ch,obj,0,TO_CHAR);
handler.c:    if(show && obj->pIndexData->remove_echo[1]!=NULL)
handler.c:        act(palloc_string(obj->pIndexData->remove_echo[1]),ch,obj,0,TO_ROOM);
handler.c:    for ( obj = list; obj != NULL; obj = obj->next_content )
handler.c:	if ( obj->pIndexData == pObjIndex )
handler.c:    if ((in_room = obj->in_room) == NULL)
handler.c:    for (ch = in_room->people; ch != NULL; ch = ch->next_in_room)
handler.c:		if (ch->on == obj)
handler.c:	    	ch->on = NULL;
handler.c:    if ( obj == in_room->contents ) {
handler.c:		in_room->contents = obj->next_content;
handler.c:		for ( prev = in_room->contents; prev; prev = prev->next_content ) {
handler.c:		    if ( prev->next_content == obj ) {
handler.c:				prev->next_content = obj->next_content;
handler.c:    obj->in_room      = NULL;
handler.c:    obj->next_content = NULL;
handler.c:    obj->next_content		= pRoomIndex->contents;
handler.c:    pRoomIndex->contents	= obj;
handler.c:    obj->in_room		= pRoomIndex;
handler.c:    obj->carried_by		= NULL;
handler.c:    obj->in_obj			= NULL;
handler.c:	obj->next_content		= obj_to->contains;
handler.c:    obj_to->contains		= obj;
handler.c:    obj->in_obj			= obj_to;
handler.c:    obj->in_room		= NULL;
handler.c:    obj->carried_by		= NULL;
handler.c:	if (obj_to->pIndexData->vnum == OBJ_VNUM_PIT)
handler.c:        obj->cost = 0;
handler.c:    for ( ; obj_to != NULL; obj_to = obj_to->in_obj )
handler.c:		if ( obj_to->carried_by != NULL )
handler.c:	    	obj_to->carried_by->carry_weight += get_obj_weight( obj );
handler.c:    if ( ( obj_from = obj->in_obj ) == NULL )
handler.c:    if ( obj == obj_from->contains )
handler.c:	obj_from->contains = obj->next_content;
handler.c:	for ( prev = obj_from->contains; prev; prev = prev->next_content )
handler.c:	    if ( prev->next_content == obj )
handler.c:		prev->next_content = obj->next_content;
handler.c:    obj->next_content = NULL;
handler.c:    obj->in_obj       = NULL;
handler.c:    for ( ; obj_from != NULL; obj_from = obj_from->in_obj )
handler.c:	if ( obj_from->carried_by != NULL )
handler.c:	    obj_from->carried_by->carry_weight -= get_obj_weight( obj );
handler.c:    if ( obj->in_room != NULL )
handler.c:    else if ( obj->carried_by != NULL )
handler.c:    else if ( obj->in_obj != NULL )
handler.c:    obj->pIndexData->limcount -= 1;
handler.c:    for ( obj_content = obj->contains; obj_content; obj_content = obj_next )
handler.c:	obj_next = obj_content->next_content;
handler.c:	object_list = obj->next;
handler.c:	for ( prev = object_list; prev != NULL; prev = prev->next )
handler.c:	    if ( prev->next == obj )
handler.c:		prev->next = obj->next;
handler.c:	    bug( "Extract_obj: obj %d not found.", obj->pIndexData->vnum );
handler.c:	if ( ch->in_room == NULL )
handler.c:			sprintf(vn,"%d",ch->pIndexData->vnum);
handler.c:			IS_NPC(ch) ? "Vnum is " : "Name is ", IS_NPC(ch) ? vn : ch->name);
handler.c:    for (tch = char_list; tch != NULL; tch = tch->next)
handler.c:		if (tch->last_fought == ch)
handler.c:			tch->last_fought = NULL;
handler.c:		if (!IS_NPC(ch) && !IS_NPC(tch) && tch->last_fight_name == ch->true_name)
handler.c:			tch->last_fight_name = NULL;
handler.c:		if (!IS_NPC(tch) && !IS_NPC(ch) && tch->pcdata->trusting == ch)
handler.c:			tch->pcdata->trusting = NULL;
handler.c:    ch->pet = NULL; /* just in case */
handler.c:    for ( obj = ch->carrying; obj != NULL; obj = obj_next ) {
handler.c:		obj_next = obj->next_content;
handler.c:        if (!(obj->wear_loc == WEAR_BRAND
handler.c:			|| IS_SET(obj->extra_flags,ITEM_FIXED)) && !IS_NPC(ch)) {
handler.c:				obj->pIndexData->limcount++;
handler.c:	bug("Attempt at extracting mob %d while it has queue events pending.",ch->pIndexData->vnum);
handler.c:	ch->hit = ch->max_hit;
handler.c:	ch->position = POS_STANDING;
handler.c:		--ch->pIndexData->count;
handler.c:		total_wealth -= ch->pIndexData->wealth;
handler.c:    if ( ch->desc != NULL && ch->desc->original != NULL ) {
handler.c:		ch->desc = NULL;
handler.c:    for ( wch = char_list; wch != NULL; wch = wch->next )
handler.c:		if ( wch->reply == ch )
handler.c:			wch->reply = NULL;
handler.c:	for (room = top_affected_room; room ; room = room->aff_next ) {
handler.c:		for ( raf = room->affected; raf != NULL; raf = raf->next ) {
handler.c:			if (raf->owner == ch) {
handler.c:       char_list = ch->next;
handler.c:		for ( prev = char_list; prev != NULL; prev = prev->next ) {
handler.c:			if ( prev->next == ch ) {
handler.c:				prev->next = ch->next;
handler.c:    if ( ch->desc != NULL )
handler.c:		ch->desc->character = NULL;
handler.c:    for ( rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room )
handler.c:        if ( !can_see( ch, rch ) || (arg[0] != '\0' && !is_name( arg, rch->name )))
handler.c:    for ( wch = char_list; wch != NULL ; wch = wch->next )
handler.c:		sprintf(name,wch->true_name);
handler.c:		sprintf(name,wch->name);
handler.c:	if ( wch->in_room == NULL || !can_see( ch, wch ) || !is_name( arg, name ) )
handler.c:	if (IS_NPC(wch) && wch->pIndexData->vnum == MOB_VNUM_DECOY && IS_IMMORTAL(ch))
handler.c: * Used by area-reset 'P' command.
handler.c:    for ( obj = object_list; obj != NULL; obj = obj->next )
handler.c:	if ( obj->pIndexData == pObjIndex )
handler.c:    for ( obj = list; obj != NULL; obj = obj->next_content )
handler.c:			 && (arg[0] == '\0' || is_name( arg, obj->name )) )
handler.c:	for( obj2 = room->contents; obj2 != NULL; obj2 = obj2->next_content)
handler.c:		if(obj->pIndexData->vnum == obj2->pIndexData->vnum)
handler.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
handler.c:	if ( obj->wear_loc == WEAR_NONE
handler.c:        &&   (arg[0] == '\0' || is_name( arg, obj->name )) )
handler.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
handler.c:	if ( obj->wear_loc != WEAR_NONE
handler.c:        &&   (arg[0] == '\0' || is_name( arg, obj->name )) )
handler.c:    obj = get_obj_list( ch, argument, ch->in_room->contents );
handler.c:    for ( obj = object_list; obj != NULL; obj = obj->next )
handler.c:	if ( can_see_obj( ch, obj ) && is_name( arg, obj->name ) )
handler.c:    gold = UMIN(ch->gold,cost);
handler.c:    ch->gold -= gold;
handler.c:    if (ch->gold < 0)
handler.c:	bug("deduct costs: gold %d < 0",ch->gold);
handler.c:	ch->gold = 0;
handler.c:        sprintf( buf, obj->short_descr, gold );
handler.c:        free_pstring( obj->short_descr );
handler.c:        obj->short_descr        = palloc_string( buf );
handler.c:        obj->value[1]           = gold;
handler.c:        obj->cost               = gold;
handler.c:	obj->weight		= gold/1000;
handler.c:    if (obj->wear_loc == WEAR_BRAND || obj->item_type == ITEM_MONEY
handler.c:    ||  obj->item_type == ITEM_GEM || obj->item_type == ITEM_JEWELRY)
handler.c:    weight = obj->weight;
handler.c:    for ( tobj = obj->contains; tobj != NULL; tobj = tobj->next_content )
handler.c:    weight = obj->weight;
handler.c:    for ( obj = obj->contains; obj != NULL; obj = obj->next_content )
handler.c:	for ( stuff = obj->contains; stuff != NULL; stuff = stuff->next_content )
handler.c:	for ( stuff = obj->contains; stuff != NULL; stuff = stuff->next_content )
handler.c:	if (pRoomIndex->light > 2)
handler.c:    if ( IS_SET(pRoomIndex->room_flags, ROOM_DARK) )
handler.c:    if ( pRoomIndex->sector_type == SECT_INSIDE
handler.c:    ||   pRoomIndex->sector_type == SECT_CITY )
handler.c:    if (room->owner == NULL || room->owner[0] == '\0')
handler.c:    return is_name(ch->name,room->owner);
handler.c:    if (pRoomIndex->owner != NULL && pRoomIndex->owner[0] != '\0')
handler.c:    for ( rch = pRoomIndex->people; rch != NULL; rch = rch->next_in_room )
handler.c:    if ( IS_SET(pRoomIndex->room_flags, ROOM_PRIVATE)  && count >= 2 )
handler.c:    if ( IS_SET(pRoomIndex->room_flags, ROOM_SOLITARY) && count >= 1 )
handler.c:    if ( IS_SET(pRoomIndex->room_flags, ROOM_IMP_ONLY) )
handler.c:/* visibility on a room -- for entering and exits */
handler.c:    if (IS_SET(pRoomIndex->room_flags, ROOM_IMP_ONLY)
handler.c:    if (IS_SET(pRoomIndex->room_flags, ROOM_GODS_ONLY)
handler.c:    if (IS_SET(pRoomIndex->room_flags, ROOM_HEROES_ONLY)
handler.c:    if (IS_SET(pRoomIndex->room_flags,ROOM_NEWBIES_ONLY)
handler.c:    &&  ch->level > 10 && !IS_IMMORTAL(ch) && (!IS_NPC(ch) || ch->pIndexData->vnum != ACADEMY_PET))
handler.c:	if (IS_NPC(ch) && IS_SET(ch->act,ACT_DETECT_SPECIAL))
handler.c:	if(IS_CABAL_GUARD(ch) && !ch->desc)
handler.c:	if ( get_trust(ch) < victim->invis_level)
handler.c:    if (get_trust(ch) < victim->incog_level && ch->in_room != victim->in_room)
handler.c:	if (get_trust(ch) == LEVEL_HERO && victim->invis_level == LEVEL_HERO && !IS_HEROIMM(ch))
handler.c:    if ( (!IS_NPC(ch) && IS_SET(ch->act, PLR_HOLYLIGHT))
handler.c:    if(IS_NPC(ch) && victim->invis_level >= LEVEL_HERO)
handler.c:    && ch->pcdata->death_status == HAS_DIED)
handler.c:	if (is_affected_area(ch->in_room->area,gsn_whiteout) &&
handler.c:		for (paf = ch->in_room->area->affected;paf;paf = paf->next) {
handler.c:			if (paf->type == gsn_whiteout)  break;
handler.c:		if (paf->owner != ch)
handler.c:		&& (ch->in_room->sector_type == SECT_WATER
handler.c:		|| ch->in_room->sector_type == SECT_UNDERWATER
handler.c:		|| (ch->in_room->sector_type != SECT_INSIDE
handler.c:		&& victim->in_room->area->sky >= SKY_DRIZZLE))
handler.c:		&& ch->in_room == victim->in_room ))
handler.c:		&& ch->in_room->sector_type != SECT_UNDERWATER
handler.c:		&& victim->in_room->sector_type != SECT_UNDERWATER))
handler.c:		&& (victim->in_room->sector_type != SECT_UNDERWATER)
handler.c:		&& (victim->in_room->sector_type != SECT_AIR)
handler.c:		&& (ch->in_room->sector_type != SECT_UNDERWATER)
handler.c:		&& (ch->in_room->sector_type != SECT_AIR)
handler.c:    &&   victim->fighting == NULL
handler.c:	&&	!(is_affected(ch,gsn_darksight) && (af = affect_find(ch->affected,
handler.c:		gsn_darksight)) && af->aftype == AFT_SKILL
handler.c:		&& room_is_dark(victim->in_room))
handler.c:	&& (!(is_affected(ch,gsn_hydroperception) && (ch->in_room->sector_type == SECT_WATER || ch->in_room->sector_type == SECT_UNDERWATER || (ch->in_room->sector_type != SECT_INSIDE && victim->in_room->area->sky >= SKY_DRIZZLE)) && ch->in_room == victim->in_room ))
handler.c:		&& (victim->in_room->sector_type != SECT_UNDERWATER)
handler.c:			&& (victim->in_room->sector_type != SECT_AIR)
handler.c:		&& (ch->in_room->sector_type != SECT_UNDERWATER)
handler.c:			&& (ch->in_room->sector_type != SECT_AIR)
handler.c:    if ( room_is_dark( ch->in_room ) && !IS_AFFECTED(ch,AFF_DARK_VISION))
handler.c:	if(!ch->in_room)
handler.c:		for (oaf = obj->affected; oaf != NULL; oaf = oaf->next)	
handler.c:			if(oaf->type == gsn_stash)
handler.c:		if(oaf->owner != ch && !IS_IMMORTAL(ch))
handler.c:	if (!IS_NPC(ch) && IS_SET(ch->act, PLR_HOLYLIGHT) )
handler.c:    if (IS_SET(obj->extra_flags,ITEM_VIS_DEATH))
handler.c:    if ((IS_AFFECTED( ch, AFF_BLIND ) && obj->item_type != ITEM_POTION))
handler.c:	if (is_affected_area(ch->in_room->area,gsn_whiteout) &&
handler.c:		obj->item_type != ITEM_POTION) {
handler.c:		for (paf = ch->in_room->area->affected;paf;paf = paf->next) {
handler.c:			if (paf->type == gsn_whiteout)	
handler.c:		if (paf && paf->owner != ch)
handler.c:    if ( obj->item_type == ITEM_LIGHT && obj->value[2] != 0 )
handler.c:    if ( IS_SET(obj->extra_flags, ITEM_INVIS)
handler.c:    if ( room_is_dark( ch->in_room ) && !IS_AFFECTED(ch,AFF_DARK_VISION))
handler.c:    if ( !IS_SET(obj->extra_flags, ITEM_NODROP) )
handler.c:    if ( !IS_NPC(ch) && ch->level >= LEVEL_IMMORTAL )
handler.c:    if ( IS_SET(extra_flags, ITEM_ANTI_GOOD)    ) strcat( buf, " anti-good"    );
handler.c:    if ( IS_SET(extra_flags, ITEM_ANTI_EVIL )   ) strcat( buf, " anti-evil"    );
handler.c:    if ( IS_SET(extra_flags, ITEM_ANTI_NEUTRAL)) strcat( buf, " anti-neutral" );
handler.c:    if ( IS_SET(extra_flags, ITEM_ANTI_LAWFUL )) strcat( buf, " anti-lawful"  );
handler.c:    if ( IS_SET(extra_flags, ITEM_ANTI_NEUT  )  ) strcat( buf, " anti-neutrale"    );
handler.c:    if ( IS_SET(extra_flags, ITEM_ANTI_CHAOTIC) ) strcat( buf, " anti-chaotic" );
handler.c:    if (IS_SET_OLD(weapon_flags, WEAPON_TWO_HANDS)) strcat(buf, " two-handed");
handler.c:	paf->where	= TO_ROOM_AFFECTS;
handler.c:	paf->type	= 0;
handler.c:	paf->aftype	= AFT_SPELL;
handler.c:	paf->level	= 0;
handler.c:	paf->duration	= 0;
handler.c:	paf->location	= 0;
handler.c:	paf->modifier	= 0;
handler.c:	zero_vector(paf->bitvector);
handler.c:	paf->pulse_fun	= NULL;
handler.c:	paf->tick_fun	= NULL;
handler.c:	paf->end_fun	= NULL;
handler.c:	paf->owner	= NULL;
handler.c:	/* Morg - Valgrind fix */
handler.c:	paf->valid = FALSE;
handler.c:	mod = paf->modifier;
handler.c:		switch (paf->where)
handler.c:			BITWISE_OR(room->affected_by, paf->bitvector);	
handler.c:			BITWISE_OR(room->room_flags, paf->bitvector);	
handler.c:		switch (paf->where)
handler.c:			BITWISE_XAND(room->affected_by, paf->bitvector);	
handler.c:			BITWISE_XAND(room->room_flags, paf->bitvector);	
handler.c:		mod = 0 - mod;
handler.c:	switch (paf->location)
handler.c:		case APPLY_ROOM_HEAL:	room->heal_rate += mod;		break;
handler.c:		case APPLY_ROOM_MANA:	room->mana_rate += mod;		break;
handler.c:		case APPLY_ROOM_SECT:	room->sector_type += mod;	break;
handler.c:		default: bug("Affect_modify_room: unknown location %d.", paf->location); break;
handler.c:	paf->owner = NULL;
handler.c:	paf->end_fun = NULL;
handler.c:	paf->tick_fun = NULL;
handler.c:    if ( !room->affected ){
handler.c:			for ( pRoomIndex  = top_affected_room; pRoomIndex->aff_next != NULL;
handler.c:					pRoomIndex  = pRoomIndex->aff_next )
handler.c:			pRoomIndex->aff_next = room;
handler.c:     	room->aff_next = NULL;
handler.c:    paf_new->next	= room->affected;
handler.c:    room->affected	= paf_new;
handler.c:    for (paf = room->affected; paf != NULL; paf = paf->next)
handler.c:	if (paf->where == where && vector_equal(paf->bitvector,vector))
handler.c:				BITWISE_OR(room->affected_by,vector);
handler.c:	      	    BITWISE_OR(room->room_flags, vector);
handler.c:    if ( room->affected == NULL ) {
handler.c:    if(paf->end_fun != NULL)
handler.c:		(*paf->end_fun) (room, paf);
handler.c:    where = paf->where;
handler.c:	copy_vector(vector, paf->bitvector);
handler.c:    if ( paf == room->affected ) {
handler.c:		room->affected	= paf->next;
handler.c:		for ( prev = room->affected; prev != NULL; prev = prev->next ) {
handler.c:		    if ( prev->next == paf ) {
handler.c:			prev->next = paf->next;
handler.c:    if ( !room->affected ) {
handler.c:			top_affected_room = room->aff_next;
handler.c:			for(prev=top_affected_room;prev->aff_next;prev=prev->aff_next ) {
handler.c:				if ( prev->aff_next == room ) {
handler.c:				prev->aff_next = room->aff_next;
handler.c:		room->aff_next = NULL;
handler.c:    for ( paf = room->affected; paf != NULL; paf = paf_next )
handler.c:	paf_next = paf->next;
handler.c:	if ( paf->type == sn )
handler.c:    for ( paf = room->affected; paf != NULL; paf = paf->next )
handler.c:	if ( paf->type == sn )
handler.c:	for ( paf_old = room->affected; paf_old != NULL; paf_old = paf_old->next )
handler.c:	if ( paf_old->type == paf->type )
handler.c:	    paf->level = (paf->level + paf_old->level) / 2;
handler.c:	    paf->duration += paf_old->duration;
handler.c:	    paf->modifier += paf_old->modifier;
handler.c:	paf_new->next = obj->charaffs;
handler.c:	obj->charaffs = paf_new;
handler.c:	paf_new->next = obj->charaffs;
handler.c:	obj->charaffs = paf_new;
handler.c:	if ( obj->charaffs == NULL )
handler.c:	if ( paf == obj->charaffs)
handler.c:		obj->charaffs = paf->next;
handler.c:		for ( prev = obj->charaffs; prev != NULL; prev = prev->next )                                                  
handler.c:			if ( prev->next == paf )                                                                                  
handler.c:				prev->next = paf->next;                                                                                   
handler.c:	paf->where 		=	TO_OBJ_AFFECTS;
handler.c:	paf->type		=	0;
handler.c:	paf->aftype		=	AFT_SPELL;
handler.c:	paf->level		=	0;
handler.c:	paf->duration	=	0;
handler.c:	paf->location	=	0;
handler.c:	paf->modifier	=	0;
handler.c:	zero_vector(paf->bitvector);
handler.c:	paf->tick_fun 	=	NULL;
handler.c:	paf->pulse_fun	=	NULL;
handler.c:	paf->end_fun 	=	NULL;
handler.c:	paf->owner		=	NULL;
handler.c:	mod = paf->modifier;
handler.c:		switch (paf->where) {
handler.c:				BITWISE_OR(obj->affected_by, paf->bitvector);
handler.c:				ch = obj->carried_by;
handler.c:				wear = obj->wear_loc;
handler.c:				app->location	=	paf->location;
handler.c:				app->modifier	=	paf->modifier;
handler.c:				app->type		=	paf->type;
handler.c:				app->next		=	obj->apply;
handler.c:				obj->apply		=	app;
handler.c:		switch (paf->where) {
handler.c:				BITWISE_XAND(obj->affected_by, paf->bitvector);
handler.c:				ch = obj->carried_by;
handler.c:				wear = obj->wear_loc;
handler.c:				for (app = obj->apply; app; app = app->next)
handler.c:					if (app->type == paf->type
handler.c:						&& app->location == paf->location)
handler.c:				if (obj->apply != app) {
handler.c:					for (p_app = obj->apply; p_app; p_app = p_app->next)
handler.c:						if (p_app->next == app)
handler.c:					p_app->next = app->next;
handler.c:					obj->apply = app->next;
handler.c:		mod = 0 - mod;
handler.c:	 * them a -dex apply for the duration.  This should properly add and
handler.c:	if (paf->where == TO_OBJ_AFFECTS) {
handler.c:		switch (paf->location) {
handler.c:				obj->value[0] += mod;
handler.c:				obj->value[1] += mod;
handler.c:				obj->value[2] += mod;
handler.c:				obj->value[3] += mod;
handler.c:				obj->value[4] += mod;
handler.c:				obj->weight += mod;
handler.c:				bug("affect_modify_obj: unknown location %d.",paf->location);
handler.c:	paf_new->next	=	obj->affected;
handler.c:	obj->affected	=	paf_new;
handler.c:	for (paf = obj->affected; paf != NULL; paf = paf->next) {
handler.c:		if (paf->where == where && vector_equal(paf->bitvector,vector)) {
handler.c:					BITWISE_OR(obj->affected_by,vector);
handler.c:	if (!obj->affected)
handler.c:	if (paf->end_fun != NULL && show)
handler.c:		(*paf->end_fun) (obj,paf);
handler.c:	where = paf->where;
handler.c:	copy_vector(vector, paf->bitvector);
handler.c:	if (paf == obj->affected) {
handler.c:		obj->affected = paf->next;
handler.c:		for (prev = obj->affected; prev != NULL; prev = prev->next) {
handler.c:			if (prev->next == paf) {
handler.c:				prev->next = paf->next;
handler.c:			return bug("affect_remove_obj: cannot find paf on obj #%d!",obj->pIndexData->vnum);
handler.c:	for (paf = obj->affected; paf != NULL; paf = paf_next ) {
handler.c:		paf_next = paf->next;
handler.c:		if (paf->type == sn)
handler.c:	for (paf = obj->affected; paf != NULL; paf = paf->next)
handler.c:		if (paf->type == sn)
handler.c:	for (paf_old = obj->affected; paf_old != NULL; paf_old = paf_old->next) {
handler.c:		if (paf_old->type == paf->type) {
handler.c:			paf->level = (paf->level + paf_old->level) / 2;
handler.c:			paf->duration += paf_old->duration;
handler.c:			paf->modifier += paf_old->modifier;
handler.c:	paf->where 		=	TO_AREA_AFFECTS;
handler.c:	paf->type		=	0;
handler.c:	paf->aftype		=	AFT_SPELL;
handler.c:	paf->level		=	0;
handler.c:	paf->duration	=	0;
handler.c:	paf->location	=	0;
handler.c:	paf->modifier	=	0;
handler.c:	zero_vector(paf->bitvector);
handler.c:	paf->pulse_fun	=	NULL;
handler.c:	paf->tick_fun 	=	NULL;
handler.c:	paf->end_fun 	=	NULL;
handler.c:	paf->owner		=	NULL;
handler.c:	mod = paf->modifier;
handler.c:		switch (paf->where) {
handler.c:				BITWISE_OR(area->affected_by, paf->bitvector);
handler.c:		switch (paf->where) {
handler.c:				BITWISE_XAND(area->affected_by, paf->bitvector);
handler.c:		mod = 0 - mod;
handler.c:	switch (paf->location) {
handler.c:			area->temp+= paf->modifier;
handler.c:			if (area->temp >= MAX_TEMP)
handler.c:				area->temp = MAX_TEMP - 1;
handler.c:			area->wind += paf->modifier;
handler.c:			if (area->wind >= MAX_WIND)
handler.c:				area->wind = MAX_WIND - 1;
handler.c:			area->sky += paf->modifier;
handler.c:			if (area->sky >= MAX_SKY)
handler.c:				area->sky = MAX_SKY - 1;
handler.c:			bug("affect_modify_area: unknown location %d.",paf->location);
handler.c:	paf_new->next	=	area->affected;
handler.c:	area->affected	=	paf_new;
handler.c:	for (paf = area->affected; paf != NULL; paf = paf->next) {
handler.c:		if (paf->where == where && vector_equal(paf->bitvector, vector)) {
handler.c:					BITWISE_OR(area->affected_by,vector);
handler.c:	if (!area->affected)
handler.c:	if (paf->end_fun != NULL)
handler.c:		(*paf->end_fun) (area,paf);
handler.c:	where = paf->where;
handler.c:	copy_vector(vector, paf->bitvector);
handler.c:	if (paf == area->affected) {
handler.c:		area->affected = paf->next;
handler.c:		for (prev = area->affected; prev != NULL; prev = prev->next) {
handler.c:			if (prev->next == paf) {
handler.c:				prev->next = paf->next;
handler.c:	for (paf = area->affected; paf != NULL; paf = paf_next ) {
handler.c:		paf_next = paf->next;
handler.c:		if (paf->type == sn)
handler.c:	for (paf = area->affected; paf != NULL; paf = paf->next)
handler.c:		if (paf->type == sn)
handler.c:	for (paf_old = area->affected; paf_old != NULL; paf_old = paf_old->next) {
handler.c:		if (paf_old->type == paf->type) {
handler.c:			paf->level = (paf->level + paf_old->level) / 2;
handler.c:			paf->duration += paf_old->duration;
handler.c:			paf->modifier += paf_old->modifier;
handler.c:  if ( !IS_NPC(victim) && (victim->ghost))
handler.c:  if  ( victim->level < 5  && !IS_NPC(victim) )
handler.c:      ((level >= victim->level + 10) || (victim->level >= level + 10)))
handler.c:	mod = 0 - mod;
handler.c:    case APPLY_STR:           ch->mod_stat[STAT_STR]    += mod; break;
handler.c:    case APPLY_DEX:           ch->mod_stat[STAT_DEX]    += mod; break;
handler.c:    case APPLY_INT:           ch->mod_stat[STAT_INT]    += mod; break;
handler.c:    case APPLY_WIS:           ch->mod_stat[STAT_WIS]    += mod; break;
handler.c:    case APPLY_CON:           ch->mod_stat[STAT_CON]    += mod; break;
handler.c:    case APPLY_SEX:           ch->sex                   += mod; break;
handler.c:    case APPLY_MANA:          ch->max_mana              += mod; break;
handler.c:    case APPLY_HIT:           ch->max_hit               += mod; break;
handler.c:    case APPLY_MOVE:          ch->max_move              += mod; break;
handler.c:            	ch->armor[i] += mod;
handler.c:    case APPLY_HITROLL:       ch->hitroll               += mod; break;
handler.c:    case APPLY_DAMROLL:       ch->damroll               += mod; break;
handler.c:    case APPLY_SAVES:         ch->saving_throw          += mod; break;
handler.c:    case APPLY_SAVING_PARA:   ch->saving_throw			+= mod; break;
handler.c:    case APPLY_SAVING_ROD:    ch->saving_throw          += mod; break;
handler.c:    case APPLY_SAVING_PETRI:  ch->saving_throw          += mod; break;
handler.c:    case APPLY_SAVING_BREATH: ch->saving_throw          += mod; break;
handler.c:    case APPLY_SAVING_SPELL:  ch->saving_throw          += mod; break;
handler.c:	case APPLY_CARRY_WEIGHT:  ch->carry_weight			+= mod; break;
handler.c:    case APPLY_DEFENSE:       ch->defense_mod           += mod; break;
handler.c:    case APPLY_SIZE:          ch->size                  += mod; break;
handler.c:    case APPLY_REGENERATION:  ch->regen_rate            += mod; break;
handler.c:    case APPLY_ENERGYSTATE:   if(!IS_NPC(ch)) ch->pcdata->energy_state  += mod; break;
handler.c:    case APPLY_ARMS:          ch->arms                  += mod; break;
handler.c:    case APPLY_LEGS:          ch->legs                  += mod; break;
handler.c:	case APPLY_ALIGNMENT:	  ch->alignment				+= mod; break;
handler.c:	case APPLY_ETHOS:		  if(!IS_NPC(ch)) ch->pcdata->ethos += mod; break;
handler.c:		if(ch->pcdata->beauty + mod > MAX_BEAUTY)
handler.c:			ch->pcdata->beauty = MAX_BEAUTY;
handler.c:			ch->pcdata->beauty += mod;
handler.c:		ch->dam_mod               *= (float)(1 + (float) mod / (float)100);
handler.c:		mod			   = 0 - mod;
handler.c:		ch->dam_mod 		  *= (float) 1 / (float) (1 + (float) mod / (float)100);
handler.c:	return ch->alignment;
handler.c:		return ch->pcdata->ethos;
heal.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
heal.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
heal.c:    for ( mob = ch->in_room->people; mob; mob = mob->next_in_room )
heal.c:        if ( IS_NPC(mob) && IS_SET(mob->act, ACT_IS_HEALER) )
heal.c:    if(mob->position==POS_SLEEPING)
heal.c:    if (mob->cabal != 0)
heal.c:        if (mob->cabal != ch->cabal)
heal.c:        sn = -1;
heal.c:    if (cost > ch->gold) {
heal.c:    WAIT_STATE(ch, (ch->cabal == CABAL_HORDE) ? (PULSE_VIOLENCE*3) : PULSE_VIOLENCE);
heal.c:        ch->mana += dice(4,8) + mob->level / 3;
heal.c:        ch->mana = UMIN(ch->mana,ch->max_mana);
heal.c:    if (sn == -1)
heal.c:    level = mob->level;
heal.c:    if(ch->cabal == CABAL_HORDE)
healer.c:    victim->position = POS_SLEEPING;
healer.c:    for (laf = ch->affected; laf != NULL; laf = laf->next )
healer.c:        if (skill_table[laf->type].dispel & CAN_CLEANSE)
healer.c:            affect_strip(ch, laf->type);
healer.c:    ch->position = POS_STANDING;
healer.c:    ch->hit = ch->max_hit;
healer.c:    ch->mana = ch->max_mana;
healer.c:    ch->move = ch->max_move;
help.c:		if(ch->pcdata->security > 0)
help.c:	if(atoi(row[3])>ch->level)
help.c:	if(sn > 1 && get_skill(ch,sn) < 1 && skill_table[sn].skill_level[ch->Class()->GetIndex()] > 51)
help.c:        sprintf(query,"UPDATE helpfiles SET helpdata=\"%s\" WHERE id=%d", argument, ch->pcdata->helpid);
help.c:			ch->pcdata->helpid	 = id;
help.c:			ch->pcdata->entered_text = palloc_string(row[4]);
help.c:	   			sprintf(buf,"%-5s %s\n\r", row[0], row[1]);
help.c:		send_to_char("It should only be used for cabal power helpfiles and other semi-secret helpfiles and should be 'none' otherwise.\n\r",ch);
help.c:	if(!ch->pcdata->entered_text || ch->pcdata->entered_text[0] == '\0' || !str_cmp(ch->pcdata->entered_text, ""))
help.c:	escape2 = (char *)escape_string(ch->pcdata->entered_text);
help.c:			ttitle, skill, minlevel, ch->pcdata->entered_text);
interp.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
interp.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
interp.c: * Log-all switch.
interp.c:	ch->pcdata->read_next = 0;
interp.c:	ch->pcdata->write_next = 0;
interp.c:	ch->pcdata->pending = FALSE;
interp.c:	for(i=ch->pcdata->write_next;i<MAX_QUEUE;i++) {
interp.c:		ch->pcdata->queue[i][0] = '\0';
interp.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_FREEZE) && !IS_IMP(ch))
interp.c:	if (ch->wait > 0 && !IS_NPC(ch))
interp.c:		if(ch->pcdata->write_next > (MAX_QUEUE-1)) {
interp.c:		strcpy(ch->pcdata->queue[ch->pcdata->write_next], qcommand);
interp.c:		ch->pcdata->write_next++;
interp.c:		ch->pcdata->pending = TRUE;
interp.c:    if ( ( !IS_NPC(ch) && IS_SET(ch->act, PLR_LOG) )
interp.c:	sprintf( log_buf, "Log %s: %s", ch->desc->original ? ch->desc->original->true_name : ch->true_name, logline );
interp.c:    if ( ch->desc != NULL && ch->desc->snoop_by != NULL )
interp.c:	write_to_buffer( ch->desc->snoop_by, "% ",    2 );
interp.c:	write_to_buffer( ch->desc->snoop_by, logline, 0 );
interp.c:	write_to_buffer( ch->desc->snoop_by, "\n\r",  2 );
interp.c:	 	|| ch->pcdata->energy_state < -4)
interp.c:		paf = affect_find(ch->affected,gsn_creeping_tomb);
interp.c:		if (paf->duration <= 2
interp.c:		paf = affect_find(ch->affected,gsn_horde_communion);
interp.c:		if (paf->modifier > 0 && ch->in_room->vnum != 23633)
interp.c:		&& (vpobj->pIndexData->verb)
interp.c:		&& (!str_cmp(command,vpobj->pIndexData->verb)
interp.c:		&& (ch->position >= POS_RESTING))) {
interp.c:		if(IS_SET(vpobj->progtypes,IPROG_VERB))
interp.c:			(vpobj->pIndexData->iprogs->verb_prog)(vpobj,ch,arg_dup);
interp.c:    if ( ch->position < cmd_table[cmd].position )
interp.c:	switch( ch->position )
interp.c:    if(!IS_NPC(ch) && get_trust(ch) < 60 && ch->pcdata->style && str_cmp(cmd_table[cmd].skill_name,"none"))
interp.c:					if(str_cmp(group_table[gn].name,style_table[ch->pcdata->style].name))
interp.c:            if ( ( victim = ch->fighting ) == NULL )
interp.c:        if ( argument[0] != '\0' && !is_name( argument, ch->name ) )
interp.c:        if((where = direction_lookup(argument))<0 || !ch->in_room->exit[where])
interp.c:    	if((mana = skill_table[sn].min_mana) > UMAX(ch->mana,0))
interp.c:	for(iObj = ch->carrying; iObj; iObj = iObj->next_content)
interp.c:	ch->mana -= mana;
interp.c:		&&   !victim->fighting
interp.c:       		&&   victim->master != ch)
interp.c:    if ( !IS_NPC(ch) && IS_SET(ch->comm, COMM_NOEMOTE) )
interp.c:	send_to_char( "You are anti-social!\n\r", ch );
interp.c:    switch ( ch->position )
interp.c:	 * But two players asked for it already!  -- Furey
interp.c:    if ( *arg == '+' || *arg == '-' )
interp.c:	    sprintf( buf, "%-12s", cmd_table[cmd].name );
interp.c:		sprintf(buf, "(%i)%-10s  ", cmd_table[cmd].level,cmd_table[cmd].name);
iprog.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
iprog.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
iprog.c:        return bug("Load_improgs: 'I': Function not found for vnum %d",obj->vnum);
iprog.c:        obj->iprogs->wear_prog = (IPROG_FUN_WEAR *)iprog_table[i].function;
iprog.c:	if(obj->iprogs->wear_name)
iprog.c:        free_pstring(obj->iprogs->wear_name);
iprog.c:        obj->iprogs->wear_name = palloc_string(name);
iprog.c:        SET_BIT(obj->progtypes, IPROG_WEAR);
iprog.c:        obj->iprogs->remove_prog = (IPROG_FUN_REMOVE *)iprog_table[i].function;
iprog.c:	if(obj->iprogs->remove_name)
iprog.c:        free_pstring(obj->iprogs->remove_name);
iprog.c:        obj->iprogs->remove_name = palloc_string(name);
iprog.c:        SET_BIT(obj->progtypes, IPROG_REMOVE);
iprog.c:        obj->iprogs->get_prog = (IPROG_FUN_GET *)iprog_table[i].function;
iprog.c:	if(obj->iprogs->get_name)
iprog.c:        free_pstring(obj->iprogs->get_name);
iprog.c:        obj->iprogs->get_name = palloc_string(name);
iprog.c:        SET_BIT(obj->progtypes, IPROG_GET);
iprog.c:        obj->iprogs->loot_prog = (IPROG_FUN_LOOT *)iprog_table[i].function;
iprog.c:	if(obj->iprogs->loot_name)
iprog.c:        free_pstring(obj->iprogs->loot_name);
iprog.c:        obj->iprogs->loot_name = palloc_string(name);
iprog.c:        SET_BIT(obj->progtypes, IPROG_LOOT);
iprog.c:        obj->iprogs->drop_prog = (IPROG_FUN_DROP *)iprog_table[i].function;
iprog.c:	if(obj->iprogs->drop_name)
iprog.c:        free_pstring(obj->iprogs->drop_name);
iprog.c:        obj->iprogs->drop_name = palloc_string(name);
iprog.c:        SET_BIT(obj->progtypes, IPROG_DROP);
iprog.c:        obj->iprogs->sac_prog = (IPROG_FUN_SAC *)iprog_table[i].function;
iprog.c:        free_pstring(obj->iprogs->sac_name);
iprog.c:        obj->iprogs->sac_name = palloc_string(name);
iprog.c:        SET_BIT(obj->progtypes, IPROG_SAC);
iprog.c:        obj->iprogs->entry_prog = (IPROG_FUN_ENTRY *)iprog_table[i].function;
iprog.c:	if(obj->iprogs->entry_name)
iprog.c:        free_pstring(obj->iprogs->entry_name);
iprog.c:        obj->iprogs->entry_name = palloc_string(name);
iprog.c:        SET_BIT(obj->progtypes, IPROG_ENTRY);
iprog.c:        obj->iprogs->give_prog = (IPROG_FUN_GIVE *)iprog_table[i].function;
iprog.c:	if(obj->iprogs->give_name)
iprog.c:        free_pstring(obj->iprogs->give_name);
iprog.c:        obj->iprogs->give_name = palloc_string(name);
iprog.c:        SET_BIT(obj->progtypes, IPROG_GIVE);
iprog.c:        obj->iprogs->greet_prog = (IPROG_FUN_GREET *)iprog_table[i].function;
iprog.c:	if(obj->iprogs->greet_name)
iprog.c:        free_pstring(obj->iprogs->greet_name);
iprog.c:        obj->iprogs->greet_name = palloc_string(name);
iprog.c:        SET_BIT(obj->progtypes, IPROG_GREET);
iprog.c:        obj->iprogs->fight_prog = (IPROG_FUN_FIGHT *)iprog_table[i].function;
iprog.c:	if(obj->iprogs->fight_name)
iprog.c:        free_pstring(obj->iprogs->fight_name);
iprog.c:        obj->iprogs->fight_name = palloc_string(name);
iprog.c:        SET_BIT(obj->progtypes, IPROG_FIGHT);
iprog.c:        obj->iprogs->death_prog = (IPROG_FUN_DEATH *)iprog_table[i].function;
iprog.c:	if(obj->iprogs->death_name)
iprog.c:        free_pstring(obj->iprogs->death_name);
iprog.c:        obj->iprogs->death_name = palloc_string(name);
iprog.c:        SET_BIT(obj->progtypes, IPROG_DEATH);
iprog.c:        obj->iprogs->speech_prog = (IPROG_FUN_SPEECH *)iprog_table[i].function;
iprog.c:	if(obj->iprogs->speech_name)
iprog.c:        free_pstring(obj->iprogs->speech_name);
iprog.c:        obj->iprogs->speech_name = palloc_string(name);
iprog.c:        SET_BIT(obj->progtypes, IPROG_SPEECH);
iprog.c:        obj->iprogs->pulse_prog = (IPROG_FUN_PULSE *)iprog_table[i].function;
iprog.c:	if(obj->iprogs->pulse_name)
iprog.c:        free_pstring(obj->iprogs->pulse_name);
iprog.c:        obj->iprogs->pulse_name = palloc_string(name);
iprog.c:        SET_BIT(obj->progtypes, IPROG_PULSE);
iprog.c:        obj->iprogs->invoke_prog = (IPROG_FUN_INVOKE *)iprog_table[i].function;
iprog.c:	if(obj->iprogs->invoke_name)
iprog.c:        free_pstring(obj->iprogs->invoke_name);
iprog.c:        obj->iprogs->invoke_name = palloc_string(name);
iprog.c:        SET_BIT(obj->progtypes, IPROG_INVOKE);
iprog.c:        obj->iprogs->open_prog = (IPROG_FUN_OPEN *)iprog_table[i].function;
iprog.c:	if(obj->iprogs->open_name)
iprog.c:	        free_pstring(obj->iprogs->open_name);
iprog.c:        obj->iprogs->open_name = palloc_string(name);
iprog.c:        SET_BIT(obj->progtypes, IPROG_OPEN);
iprog.c:        obj->iprogs->look_prog = (IPROG_FUN_LOOK *)iprog_table[i].function;
iprog.c:	if(obj->iprogs->look_name)
iprog.c:	        free_pstring(obj->iprogs->look_name);
iprog.c:        obj->iprogs->look_name = palloc_string(name);
iprog.c:        SET_BIT(obj->progtypes, IPROG_OPEN);
iprog.c:        obj->iprogs->verb_prog = (IPROG_FUN_VERB *)iprog_table[i].function;
iprog.c:	if(obj->iprogs->verb_name)
iprog.c:	        free_pstring(obj->iprogs->verb_name);
iprog.c:        obj->iprogs->verb_name = palloc_string(name);
iprog.c:        SET_BIT(obj->progtypes, IPROG_VERB);
iprog.c:		obj->iprogs->hit_prog = (IPROG_FUN_HIT *)iprog_table[i].function;
iprog.c:		free_pstring(obj->iprogs->hit_name);
iprog.c:		obj->iprogs->hit_name = palloc_string(name);
iprog.c:		SET_BIT(obj->progtypes, IPROG_HIT);
iprog.c:    bug( "Load_improgs: 'I': invalid program type for vnum %d",obj->vnum);
iprog.c:		obj->iprogs->wear_prog = NULL;
iprog.c:		free_pstring(obj->iprogs->wear_name);
iprog.c:		REMOVE_BIT(obj->progtypes, IPROG_WEAR);
iprog.c:		obj->iprogs->remove_prog = NULL;
iprog.c:		free_pstring(obj->iprogs->remove_name);
iprog.c:		REMOVE_BIT(obj->progtypes, IPROG_REMOVE);
iprog.c:		obj->iprogs->get_prog = NULL;
iprog.c:		free_pstring(obj->iprogs->get_name);
iprog.c:		REMOVE_BIT(obj->progtypes, IPROG_GET);
iprog.c:		obj->iprogs->loot_prog = NULL;
iprog.c:		free_pstring(obj->iprogs->loot_name);
iprog.c:		REMOVE_BIT(obj->progtypes, IPROG_LOOT);
iprog.c:		obj->iprogs->drop_prog = NULL;
iprog.c:		free_pstring(obj->iprogs->drop_name);
iprog.c:		REMOVE_BIT(obj->progtypes, IPROG_DROP);
iprog.c:		obj->iprogs->sac_prog = NULL;
iprog.c:		free_pstring(obj->iprogs->sac_name);
iprog.c:		REMOVE_BIT(obj->progtypes, IPROG_SAC);
iprog.c:		obj->iprogs->entry_prog = NULL;
iprog.c:		free_pstring(obj->iprogs->entry_name);
iprog.c:		REMOVE_BIT(obj->progtypes, IPROG_ENTRY);
iprog.c:		obj->iprogs->give_prog = NULL;
iprog.c:		free_pstring(obj->iprogs->give_name);
iprog.c:		REMOVE_BIT(obj->progtypes, IPROG_GIVE);
iprog.c:		obj->iprogs->greet_prog = NULL;
iprog.c:		free_pstring(obj->iprogs->greet_name);
iprog.c:		REMOVE_BIT(obj->progtypes, IPROG_GREET);
iprog.c:		obj->iprogs->fight_prog = NULL;
iprog.c:		free_pstring(obj->iprogs->fight_name);
iprog.c:		REMOVE_BIT(obj->progtypes, IPROG_FIGHT);
iprog.c:		obj->iprogs->death_prog = NULL;
iprog.c:		free_pstring(obj->iprogs->death_name);
iprog.c:		REMOVE_BIT(obj->progtypes, IPROG_DEATH);
iprog.c:		obj->iprogs->speech_prog = NULL;
iprog.c:		free_pstring(obj->iprogs->speech_name);
iprog.c:		REMOVE_BIT(obj->progtypes, IPROG_SPEECH);
iprog.c:		obj->iprogs->pulse_prog = NULL;
iprog.c:		free_pstring(obj->iprogs->pulse_name);
iprog.c:		REMOVE_BIT(obj->progtypes, IPROG_PULSE);
iprog.c:		obj->iprogs->invoke_prog = NULL;
iprog.c:		free_pstring(obj->iprogs->invoke_name);
iprog.c:		REMOVE_BIT(obj->progtypes, IPROG_INVOKE);
iprog.c:		obj->iprogs->open_prog = NULL;
iprog.c:		free_pstring(obj->iprogs->open_name);
iprog.c:		REMOVE_BIT(obj->progtypes, IPROG_OPEN);
iprog.c:		obj->iprogs->look_prog = NULL;
iprog.c:		free_pstring(obj->iprogs->look_name);
iprog.c:		REMOVE_BIT(obj->progtypes, IPROG_OPEN);
iprog.c:		obj->iprogs->verb_prog = NULL;
iprog.c:		free_pstring(obj->iprogs->verb_name);
iprog.c:		REMOVE_BIT(obj->progtypes, IPROG_VERB);
iprog.c:		obj->iprogs->hit_prog = NULL;
iprog.c:		free_pstring(obj->iprogs->hit_name);
iprog.c:		REMOVE_BIT(obj->progtypes, IPROG_HIT);
iprog.c:		act("The Devil's Eye suddenly pivots and stares directly into $n's face!", ch, 0, ch->fighting, TO_NOTVICT);
iprog.c:		act("The Devil's Eye suddenly pivots and stares directly into your face!", ch, 0, ch->fighting, TO_VICT);
iprog.c:		damage_new(ch,ch->fighting,dice(12,12),TYPE_UNDEFINED,DAM_SLASH,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"heartquake");
iprog.c:		if(ch->fighting->Class()->ctype == CLASS_COMMUNER && !is_affected(ch->fighting, gsn_severed))
iprog.c:			act("An enchanted obsidian skean blazes through the air, leaving a trail of fire!", ch, 0, ch->fighting, TO_ROOM);
iprog.c:			act("Your vital ties to the gods' empowerment have been severed!", ch, 0, ch->fighting, TO_VICT);
iprog.c:			af.level = ch->level;
iprog.c:			new_affect_to_char( ch->fighting, &af );
iprog.c:		if(!IS_SET(ch->affected_by, AFF_BLIND))
iprog.c:			act("An enchanted obsidian skean darts toward your eyes, gouging you painfully!", ch, 0, ch->fighting, TO_VICT);
iprog.c:			act("An enchanted obsidian skean darts toward $N's eyes, gouging $M painfully!", ch, 0, ch->fighting, TO_NOTVICT);
iprog.c:			af.level = ch->level;
iprog.c:			new_affect_to_char( ch->fighting, &af );
iprog.c:		if(IS_GOOD(ch->fighting))
iprog.c:			act("You swoon for a moment, and the world goes slightly hazy...", ch->fighting, 0, 0, TO_CHAR);
iprog.c:			WAIT_STATE(ch->fighting, PULSE_VIOLENCE * 2);
iprog.c:		dam = dice((ch->level), 3);
iprog.c:		damage_new(ch,ch->fighting,dam,TYPE_UNDEFINED,DAM_SLASH,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"burrowing axe");
iprog.c:	if(str_cmp(race_table[ch->race].name,"duergar"))
iprog.c:		if(number_percent() < 6 && (crown->pIndexData->vnum == 21825))
iprog.c:			obj_cast_spell(skill_lookup("acid blast"), ch->level, ch, ch->fighting, obj);
iprog.c:        obj_cast_spell(skill_lookup("cure critical"), obj->level, ch, ch, obj);
iprog.c:	CHAR_DATA *vch, *ch = obj->carried_by;
iprog.c:	if(!ch || !is_worn(obj) || ch->position!=POS_STANDING)
iprog.c:	for(vch=ch->in_room->people; vch!=NULL; vch = vch->next_in_room)
iprog.c:    		for ( stolen = vch->carrying; stolen != NULL; stolen = stolen->next_content )
iprog.c:			if ( stolen->wear_loc == WEAR_NONE
iprog.c:			&& (invnum==i || !stolen->next_content))
iprog.c:	if(number_percent()>95 && vch->position!=POS_SLEEPING)
iprog.c:	ch->hit += (ch->level*2) * 8;
iprog.c:      ch->hit = UMIN(ch->hit,ch->max_hit);
iprog.c:	if (check_dispel(ch->level+3,ch,skill_lookup("blindness")))
iprog.c:	if (check_dispel(ch->level+3,ch,skill_lookup("curse")))
iprog.c:	if (check_dispel(ch->level+3,ch,skill_lookup("faerie fire")))
iprog.c:	if (check_dispel(ch->level+3,ch,skill_lookup("slow")))
iprog.c:	if (check_dispel(ch->level+3,ch,skill_lookup("weaken")))
iprog.c:	if (check_dispel(ch->level+3,ch,skill_lookup("poison")))
iprog.c:	if (check_dispel(ch->level+3,ch,skill_lookup("plague")))
iprog.c:	if (check_dispel(ch->level+3,ch,skill_lookup("windwall")))
iprog.c:      af.level        = ch->level;
iprog.c:      af.modifier     = ch->level/2;
iprog.c:	ch->hit /= 2;
iprog.c:        	af.level        = ch->level;
iprog.c:        	af.modifier     = (ch->level / (short)2.5);
iprog.c:        	af.duration     = ch->level + 10;
iprog.c:        	for(vch = ch->in_room->people; vch; vch = vch->next_in_room)
iprog.c:			vch->hit = vch->max_hit;
iprog.c:        	af.duration = ch->level + 10;
iprog.c:		ch->hit = ch->hit + af.modifier;
iprog.c:		ch->hit = ch->hit + 500;
iprog.c:		af.level = ch->level;
iprog.c:		af.modifier = -50;
iprog.c:		af.modifier = -500;
iprog.c:	if(ch->position != POS_FIGHTING)
iprog.c:	if(obj->value[0] < 1)
iprog.c:	obj->value[0] -= 1;
iprog.c:	if(!saves_spell(ch->level + dice(1,5),ch->fighting,DAM_NEGATIVE))
iprog.c:		act("A flash of darkness arcs between $n and $N, leaving $N looking hopeless!",ch,0,ch->fighting,TO_NOTVICT);
iprog.c:		act("A flash of darkness arcs between you and $N as you sever $N's link with $S god.",ch,0,ch->fighting,TO_CHAR);
iprog.c:		act("Negative energy crackles in the air around you, temporarily severing your link with your god!",ch,0,ch->fighting,TO_VICT);
iprog.c:		damage_new(ch,ch->fighting,ch->level + 15,TYPE_UNDEFINED,DAM_NEGATIVE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT, "energy wave");
iprog.c:		damage_new(ch,ch,ch->level - 15,TYPE_UNDEFINED,DAM_INTERNAL,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT, "exertion");
iprog.c:		af.duration = ch->level/12;
iprog.c:		af.modifier = -(ch->level/5);
iprog.c:		new_affect_to_char(ch->fighting,&af);
iprog.c:ch->mana = ch->mana - 50;
iprog.c:	if (obj->timer == 0)
iprog.c:	if (obj->carried_by != NULL)
iprog.c:		act("You hear soft ticking from somewhere.",obj->carried_by, NULL, NULL,TO_ROOM);
iprog.c:/* explosive packs -- Dioxide */
iprog.c:	if (obj->timer > 0)
iprog.c:			obj->timer = fuse;
iprog.c:	obj->timer = fuse;
iprog.c:	char_to_room(dragon, ch->in_room);
iprog.c:	if(ch->level<40)
iprog.c:	dragon->leader = ch;
iprog.c:	SET_BIT(dragon->affected_by, AFF_CHARM);
iprog.c:	CHAR_DATA *victim = ch->fighting;
iprog.c:	switch(obj->value[2])
iprog.c:				damage_new(ch,victim,ch->level,TYPE_UNDEFINED,DAM_TRUESTRIKE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"lashing tendrils");
iprog.c:				victim->pcdata->condition[COND_HUNGER]=5;
iprog.c:				victim->pcdata->condition[COND_THIRST]=5;
iprog.c:					ch->hit += ch->level;
iprog.c:					ch->mana += ch->level;
iprog.c:        if(!is_worn(obj) || number_percent()<92 || ch->mana>=ch->max_mana || IS_NPC(ch))
iprog.c:        ch->mana = UMIN(ch->mana + number_range(intel,intel * 2), ch->max_mana);
iprog.c:	if(from->cabal!=to->cabal)
iprog.c:	cabal_shudder(obj->pIndexData->cabal, TRUE);
iprog.c:        sprintf(buf,"%s has given me %s.",PERS(from,to),obj->short_descr);
iprog.c:	EXIT_DATA *pexit = ch->in_room->exit[DIR_UP];
iprog.c:	obj_to_room(obj,ch->in_room);
iprog.c:	if(!pexit->u1.to_room)
iprog.c:	af.modifier	= -100;
iprog.c:		pexit->u1.to_room = NULL;
iprog.c:        	af.duration     = -1;
iprog.c:		for(vch = ch->in_room->people; vch; vch = vch->next_in_room)
iprog.c:	for(owner=char_list;owner != NULL;owner=owner->next)
iprog.c:		if(!IS_NPC(owner) && (!str_cmp(owner->true_name,obj->owner)))
iprog.c:	damage_new(owner,ch,dice(obj->level,2),TYPE_UNDEFINED,DAM_ENERGY,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,
iprog.c:	if(!is_affected(ch, gsn_rage) || !ch->fighting || number_percent()> (.2 * get_skill(ch,gsn_rage)))
iprog.c:	if(ch->hit >= ch->max_hit)
iprog.c:	ch->hit=UMIN(ch->max_hit,ch->hit+number_range(ch->level*(short)1.2, ch->level * (short)2.2));
iprog.c:        if(!is_affected(ch, gsn_rage) || !ch->fighting || number_percent()> (.15 * get_skill(ch,gsn_rage)))
iprog.c:	act("The rage of the Bear roars through you as you charge into $N, sending $m sprawling!",ch,0,ch->fighting,TO_CHAR);
iprog.c:	act("$n gets a wild look in $s eyes, charging into you and sending you sprawling!",ch,0,ch->fighting,TO_VICT);
iprog.c:	act("$n gets a wild look in $s eyes, charging into $N and sending $m sprawling!",ch,0,ch->fighting,TO_NOTVICT);
iprog.c:	WAIT_STATE(ch->fighting, (int)(PULSE_VIOLENCE * 1.9));
iprog.c:	damage_new(ch,ch->fighting,dice(8,8),TYPE_UNDEFINED,DAM_BASH,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"charge");
iprog.c:	if(!is_affected(ch, gsn_rage) || !ch->fighting || number_percent()> (.18 * get_skill(ch,gsn_rage)))
iprog.c:	act("The spirit of the Lion surges through you as you claw at $N's flesh!",ch,0,ch->fighting,TO_CHAR);
iprog.c:	act("$n gets a wild look in $s eyes, clawing viciously at $N!",ch,0,ch->fighting,TO_NOTVICT);
iprog.c:	act("$n gets a wild look in $s eyes, clawing viciously at you!",ch,0,ch->fighting,TO_VICT);
iprog.c:	damage_new(ch,ch->fighting,dice(ch->level - 2,4),TYPE_UNDEFINED,DAM_BASH,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,
iprog.c:	if(!ch->fighting || is_affected(ch->fighting,gsn_bleeding))
iprog.c:	af.level	= ch->level - 5;
iprog.c:	af.duration	= ch->level / 7;
iprog.c:	new_affect_to_char(ch->fighting, &af);
iprog.c:	send_to_char("Blood begins to gush from your vicious wounds.\n\r",ch->fighting);
iprog.c:	act("Bright red blood begins to gush from $n's wounds.",ch->fighting,0,0,TO_ROOM);
iprog.c:	if(!is_affected(ch, gsn_rage) || !ch->fighting || number_percent()> (.18 * get_skill(ch,gsn_rage)))
iprog.c:	act("The spirit of the Wolf enrages you as you leap at $N and sink your fangs into $S throat!",ch,0,ch->fighting,TO_CHAR);
iprog.c:	act("$n gets a wild look in $s eyes and leaps at $N, sinking $s teeth into $S throat!",ch,0,ch->fighting,TO_NOTVICT);
iprog.c:	act("$n gets a wild look in $s eyes and leaps at you, sinking $s teeth into your throat!",ch,0,ch->fighting,TO_VICT);
iprog.c:	damage_new(ch,ch->fighting,dice(ch->level,2),TYPE_UNDEFINED,DAM_BASH,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"bite");
iprog.c:	if (!ch->fighting)
iprog.c:	if(!is_affected(ch->fighting,gsn_bleeding))
iprog.c:        	af.level        = ch->level - 5;
iprog.c:        	af.duration     = ch->level / 10;
iprog.c:        	new_affect_to_char(ch->fighting, &af);
iprog.c:	if(!is_affected(ch->fighting,gsn_mangled) && number_percent() < (get_skill(ch,gsn_rage) * .28))
iprog.c:                af.level        = ch->level - 5;
iprog.c:		af.duration	= ch->level / 18;
iprog.c:		new_affect_to_char(ch->fighting, &af);
iprog.c:		act("You hear the satisfying crunch of bone as you tear deeply into $N's throat.",ch,0,ch->fighting,TO_CHAR);
iprog.c:		act("You hear the crunch of bone as $n tears deeply into your throat.",ch,0,ch->fighting,TO_VICT);
iprog.c:		act("You hear the crunch of bone as $n tears deeply into $N's throat.",ch,0,ch->fighting,TO_NOTVICT);
iprog.c:	if(!is_affected(ch, gsn_rage) || !ch->fighting || number_percent()> (.2 * get_skill(ch,gsn_rage)))
iprog.c:	act("The spirit of the Hawk flows through you as you sense a weakness in $N's defenses and strike!",ch,0,ch->fighting,TO_CHAR);
iprog.c:	act("$n pauses for a moment before unleashing a well aimed blow at you.",ch,0,ch->fighting,TO_VICT);
iprog.c:	act("$n pauses for a moment before unleashing a well aimed blow at $N.",ch,0,ch->fighting,TO_NOTVICT);
iprog.c:	one_hit_new(ch,ch->fighting,TYPE_TRUESTRIKE,HIT_NOSPECIALS,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,NULL);
iprog.c:	CHAR_DATA *victim, *ch = obj->carried_by;
iprog.c:	victim = ch->fighting;
iprog.c:	if(!ch->fighting || !is_affected(ch, gsn_rage))
iprog.c:	af.level	= ch->level;
iprog.c:	af.modifier	= (short)((100-(((float) victim->hit / (float) victim->max_hit) * 100)) / 2) * (ch->level / 51);
iprog.c:	if(!belt->value[4])
iprog.c:	free_trophy(ch->pcdata->trophy);
iprog.c:	newbelt->value[4] = 0;
iprog.c:	if (!ch->fighting || number_percent() > 12)
iprog.c:	act("Rivulets of water suddenly flow over $p as the blade lashes out at $N!",ch,obj,ch->fighting,TO_CHAR);
iprog.c:	act("Rivulets of water suddenly flow over $p as the blade lashes out at you!",ch,obj,ch->fighting,TO_VICT);
iprog.c:	act("Rivulets of water suddenly flow over $p as the blade lashes out at $N!",ch,obj,ch->fighting,TO_NOTVICT);
iprog.c:	obj_cast_spell(skill_lookup("drown"), ch->level / 2, ch, ch->fighting, obj);
iprog.c:	if(ch->cabal != CABAL_BOUNTY && !IS_IMMORTAL(ch))
iprog.c:	if(mob->pIndexData->vnum != 23604)
iprog.c:	if(ch->gold < 50)
iprog.c:	ch->gold -= 50;
iprog.c:	for ( d = descriptor_list; d != NULL; d = d->next )
iprog.c:		if ( d->connected == CON_PLAYING && d->character && d->character->in_room != NULL)
iprog.c:			if(d->character->pcdata && d->character->pcdata->bounty)
iprog.c:				if(d->character == ch)
iprog.c:							d->character->name, 
iprog.c:							d->character->pcdata->bounty, 
iprog.c:							his_her[URANGE(0, d->character->sex, 2)]);
iprog.c:	int difference = obj->value[2];
iprog.c:	if(obj->value[1] == 2)
iprog.c:		if(obj->value[2] == 0)
iprog.c:		if(obj->value[2] == 1)
iprog.c:			obj->value[2]--;
iprog.c:		if(obj->value[2] == 2)
iprog.c:			obj->value[2]--;
iprog.c:		if(obj->value[2] == 2)
iprog.c:		if(obj->value[2] == 1)
iprog.c:			obj->value[2]++;
iprog.c:		if(obj->value[2] == 0)
iprog.c:			obj->value[2]++;
iprog.c:	if(difference != obj->value[2])
iprog.c:		oaf.level = ch->level;
iprog.c:	if (ch->fighting)
iprog.c:	if (ch->fighting)
iprog.c:	if (ch->position <= POS_SITTING)
iprog.c:	if(ch->in_room->vnum != 462)
iprog.c:	if(ch->fighting)
iprog.c:	if(ch->position <= POS_SITTING)
iprog.c:	if(ch->in_room->vnum != 462)
iprog.c:   	if (ch->in_room->vnum == 4100)
iprog.c:	} else if (ch->in_room->vnum == 4101)
iprog.c:	if (ch->fighting)
iprog.c:	if (ch->position <= POS_SITTING)
iprog.c:	if (ch->in_room->vnum == 4101)
iprog.c:	if(violet->pIndexData->vnum != 2407 ||
iprog.c:	   fat->pIndexData->vnum != 2529 ||
iprog.c:	   minotaur->pIndexData->vnum != 2525)
iprog.c:	obj_cast_spell(skill_lookup("refresh"),obj->level,ch,ch,NULL);
iprog.c:		spell_acid_stream(gsn_acid_stream, ch->level + 1, ch, ch, TARGET_CHAR);
iprog.c:		if(ch->ghost)
iprog.c:		spell_plague(gsn_plague, ch->level + 5, ch, ch, TARGET_CHAR);
iprog.c:		pexit = ch->in_room->exit[DIR_DOWN];
iprog.c:		REMOVE_BIT(pexit->exit_info, EX_LOCKED);
iprog.c:		REMOVE_BIT(pexit->exit_info, EX_CLOSED);
iprog.c:	if(ch->position != POS_FIGHTING)
iprog.c:	if(IS_NPC(ch->fighting))
iprog.c:	act("You attempt to siphon some energy from $N to power your tattoo.",ch,0,ch->fighting,TO_CHAR);
iprog.c:	act("You feel a cold sensation run through your body.",ch,0,ch->fighting,TO_VICT);
iprog.c:	if(!saves_spell(ch->level,ch->fighting,DAM_NEGATIVE))
iprog.c:		damage_new(ch,ch->fighting,dice(1,10),TYPE_UNDEFINED,DAM_NEGATIVE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT, "energy sapping");
iprog.c:		ch->fighting->mana -= (int)(2.8*ch->level);
iprog.c:		obj->value[0]++;
iprog.c:	/* Morg - Leave the code compilable.  Please.
iprog.c:	oaf = affect_find_obj(obj->affected,gsn_imbue_stone);
iprog.c:	if(ch->Class()->name != "druid")
iprog.c:	if(obj->value[1] < 1)
iprog.c:	if(obj->value[0] == 0)
iprog.c:	if(obj->value[0] == 1)
iprog.c:	oaf = affect_find_obj(obj->affected,gsn_fashion_crystal);
iprog.c:	if (oaf->owner == ch)
iprog.c:	else if (ch->Class()->name == "sorcerer"
iprog.c:		|| ch->Class()->name == "shapeshifter"
iprog.c:		|| ch->Class()->name == "necromancer"
iprog.c:		|| ch->Class()->name == "chronomancer")
iprog.c:	mana = oaf->modifier;
iprog.c:	ch->mana += mana;
iprog.c:	if (ch->mana > (1.25 * ch->max_mana))
iprog.c:		ch->mana = (short)(ch->max_mana * 1.25);
iprog.c:		if(!ch->fighting)
iprog.c:			victim = ch->fighting;
iprog.c:	af.level    = ch->level;
iprog.c:	af.modifier	= -1 * (ch->level / 10);
iprog.c:	if(!ch->fighting)
iprog.c:		sprintf(buf,"Help!  %s just threw a net on me!", ch->name);
iprog.c:		if (!ch->fighting)
iprog.c:			victim = ch->fighting;
iprog.c:	if (obj->wear_loc != WEAR_HOLD)
iprog.c:	ROOM_INDEX_DATA *old_room = ch->in_room;
iprog.c:	act("The razor-sharp blade drops rapidly, slicing $n's head clean from $s body!",ch,0,0,TO_ROOM);
iprog.c:	if (!(IS_NPC(victim) && IS_SET(victim->act,ACT_UNDEAD))
iprog.c:		&& !IS_SET(victim->form,FORM_UNDEAD)) {
iprog.c:			if (victim->hit < victim->max_hit && number_percent() <= 50) {
iprog.c:			victim->hit = UMIN(victim->max_hit,victim->hit + dice(8,8));
iprog.c:				damage_new(ch,victim,dice(3,ch->level),TYPE_UNDEFINED,DAM_HOLY,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"torrent of light");
iprog.c:			damage_new(ch,victim,dice(ch->level,5),TYPE_UNDEFINED,DAM_TRUESTRIKE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"blinding fury");
iprog.c:	ch->hit += leech;
iprog.c:		af.modifier		=	-(ch->level/7);
iprog.c:		af.duration		=	ch->level / 4;
iprog.c:		af.modifier		=	ch->level / 7;
iprog.c:	if ((victim = ch->fighting) == NULL)
iprog.c:	ch->alignment = UMAX(-1000, ch->alignment - 10);
iprog.c:			obj_cast_spell(skill_lookup("plague"), ch->level, ch, victim,obj);
iprog.c:			obj_cast_spell(skill_lookup("blindness"),ch->level, ch, victim,obj);
iprog.c:			obj_cast_spell(skill_lookup("energy drain"), ch->level, ch, victim,obj);
iprog.c:	if (ch->fighting)
iprog.c:	(*skill_table[sn].spell_fun) ( sn, ch->level, ch, vo, target);
iprog.c:	if (((to_room = get_room_index(vnum)) == NULL) || (str_cmp(to_room->area->builders,ch->name) && vnum != 1200))
iprog.c:		&& !str_cmp(ch->in_room->area->builders,ch->name)) {
iprog.c:		sprintf(buf,"Your talisman whispers to you: you are currently in room #%d.\n\r",ch->in_room->vnum);
iprog.c:	if ((room = obj->in_room) == NULL)
iprog.c:	if (!room->people)
iprog.c:	for (mob = room->people; mob; mob = mob->next_in_room)
iprog.c:		if (IS_NPC(mob) && (IS_SET(mob->act, ACT_UNDEAD) || IS_SET(mob->form, FORM_UNDEAD))) {
iprog.c:	act(buf,room->people,0,0,TO_ALL);
iprog.c:	for (mob = room->people; mob; mob = mob_next) {
iprog.c:		mob_next = mob->next_in_room;
iprog.c:		if (IS_NPC(mob) && (IS_SET(mob->act, ACT_UNDEAD) || IS_SET(mob->form,FORM_UNDEAD))) {
iprog.c:	if ((room = shelf->in_room) == NULL)
iprog.c:	switch (shelf->pIndexData->vnum) {
iprog.c:			if (room->vnum != 2375)
iprog.c:			if (room->vnum != 2377)
iprog.c:			if (room->vnum != 2379)
iprog.c:	for (mob = room->people; mob; mob = mob->next_in_room) {
iprog.c:		if (mob->pIndexData->vnum == mobvnum) {
iprog.c:	REMOVE_BIT_OLD(obj->value[1], CONT_CLOSED);
iprog.c:	char_to_room(skeleton,ch->in_room);
iprog.c:	do_murder(skeleton, ch->name);
iprog.c:	pexit = ch->in_room->exit[2];
iprog.c:	if ( !IS_SET(pexit->exit_info, EX_CLOSED) || !IS_SET(pexit->exit_info, EX_LOCKED) )
iprog.c:	REMOVE_BIT(pexit->exit_info, EX_CLOSED);
iprog.c:	REMOVE_BIT(pexit->exit_info, EX_LOCKED);
iprog.c:	act( "$n tugs on a small metal hook inside a notch in the marble.", ch, NULL, pexit->keyword, TO_ROOM );
iprog.c:	if ((to_room = pexit->u1.to_room) != NULL
iprog.c:		 && (pexit_rev=to_room->exit[0]) != NULL
iprog.c:		 &&   pexit_rev->u1.to_room == ch->in_room ) {
iprog.c:		 REMOVE_BIT( pexit_rev->exit_info, EX_LOCKED );
iprog.c:		 REMOVE_BIT( pexit_rev->exit_info, EX_LOCKED );
iprog.c:	ROOM_INDEX_DATA *room = obj->in_room;
iprog.c:	switch (room->vnum) {
iprog.c:	pexit = room->exit[dir];
iprog.c:	if (IS_SET(pexit->exit_info,EX_CLOSED)) {
iprog.c:		REMOVE_BIT(pexit->exit_info,EX_CLOSED);
iprog.c:		REMOVE_BIT(pexit->exit_info,EX_LOCKED);
iprog.c:		REMOVE_BIT(pexit->u1.to_room->exit[reverse_d(dir)]->exit_info,EX_CLOSED);
iprog.c:		REMOVE_BIT(pexit->u1.to_room->exit[reverse_d(dir)]->exit_info,EX_LOCKED);
iprog.c:		if (pexit->u1.to_room->people) {
iprog.c:		SET_BIT(pexit->exit_info,EX_CLOSED);
iprog.c:		SET_BIT(pexit->exit_info,EX_LOCKED);
iprog.c:		SET_BIT(pexit->u1.to_room->exit[reverse_d(dir)]->exit_info,EX_CLOSED);
iprog.c:		SET_BIT(pexit->u1.to_room->exit[reverse_d(dir)]->exit_info,EX_LOCKED);
iprog.c:		if (pexit->u1.to_room->people) {
iprog.c:	af = affect_find(ch->affected,gsn_horde_communion);
iprog.c:	af->modifier = 1;
iprog.c:	REMOVE_BIT(ch->comm,COMM_PROMPT);
iprog.c:	ch->position = POS_SLEEPING;
iprog.c:	SET_BIT(ch->affected_by,AFF_SLEEP);
iprog.c:	ch->pcdata->condition[COND_HUNGER] = 1;
iprog.c:	ch->pcdata->condition[COND_THIRST] = 1;
iprog.c:	af = affect_find(ch->affected,gsn_horde_communion);
iprog.c:		ch->position = POS_STANDING;
iprog.c:		REMOVE_BIT(ch->affected_by,AFF_SLEEP);
iprog.c:	switch (af->modifier) {
iprog.c:			af->modifier++;
iprog.c:			af->modifier++;
iprog.c:			af->modifier++;
iprog.c:			af->modifier++;
iprog.c:			af->modifier++;
iprog.c:			af->modifier++;
iprog.c:			af->modifier++;
iprog.c:			af->modifier++;
iprog.c:			af->modifier++;
iprog.c:			sprintf(buf,"%sA small band of barbarians appear to have been trapped by a well-armored force of vastly superior numbers, a sheer cliffside at their backs.%s\n\r",get_char_color(ch,"lightgrey"),END_COLOR(ch));
iprog.c:			af->modifier++;
iprog.c:			af->modifier++;
iprog.c:			af->modifier++;
iprog.c:			af->modifier++;
iprog.c:			af->modifier++;
iprog.c:			af->modifier++;
iprog.c:			sprintf(buf,"%sThe once-superior force, now decimated, turns to flee, a cacophony of shouts from the barbarians at their backs.%s\n\r",get_char_color(ch,"lightgrey"),END_COLOR(ch));
iprog.c:			af->modifier++;
iprog.c:			af->modifier++;
iprog.c:			SET_BIT(ch->comm,COMM_PROMPT);
iprog.c:			ch->pcdata->tribe = tribe;
iprog.c:			af->modifier++;
iprog.c:			af->modifier++;
iprog.c:			ch->position = POS_STANDING;
iprog.c:			if (IS_SET(ch->comm,COMM_BRIEF)) {
iprog.c:				REMOVE_BIT(ch->comm,COMM_BRIEF);
iprog.c:				SET_BIT(ch->comm,COMM_BRIEF);
iprog.c:			af->modifier++;
iprog.c:			af->modifier++;
iprog.c:			switch (ch->pcdata->tribe) {
iprog.c:					sprintf(long_desc,"A ferocious long-tusked boar charges madly toward you!");
iprog.c:					sprintf(name,"hawk steely-eyed horde");
iprog.c:					sprintf(short_desc,"a steely-eyed hawk");
iprog.c:					sprintf(long_desc,"An unusually large steely-eyed hawk screeches and dives towards you!");
iprog.c:			free_pstring(animal->name);
iprog.c:			animal->name = palloc_string(name);
iprog.c:			free_pstring(animal->short_descr);
iprog.c:			animal->short_descr = palloc_string(short_desc);
iprog.c:			free_pstring(animal->long_descr);
iprog.c:			animal->long_descr = palloc_string(long_desc);
iprog.c:			animal->level = ch->level + 10;
iprog.c:			animal->damage[DICE_NUMBER] = ch->level;
iprog.c:			animal->damage[DICE_TYPE] = 3;
iprog.c:			animal->damage[DICE_BONUS] = ch->level;
iprog.c:			animal->max_hit = ch->level * 200;
iprog.c:			animal->hit = animal->max_hit;
iprog.c:			REMOVE_BIT(ch->comm,COMM_PROMPT);
iprog.c:			ch->position = POS_SLEEPING;
iprog.c:			for (animal = (get_room_index(23633))->people; animal; animal = animal->next_in_room) {
iprog.c:				if (IS_NPC(animal) && animal->pIndexData->vnum == 23630) {
iprog.c:			af->modifier++;
iprog.c:			REMOVE_BIT(ch->affected_by,AFF_SLEEP);
iprog.c:			ch->position = POS_STANDING;
iprog.c:			af->modifier++;
iprog.c:			af->modifier++;
iprog.c:			ch->cabal = CABAL_HORDE;
iprog.c:			ch->pcdata->cabal_level = cabal_table[ch->cabal].start_level;
iprog.c:			if (IS_IMMORTAL(af->owner) && IS_IMMORTAL(ch))
iprog.c:						af->owner->true_name,                                                                                    
iprog.c:					    ch->true_name,                                                                                
iprog.c:					    af->owner->pcdata->host,                                                                                 
iprog.c:					    ch->pcdata->host);                                                                            
iprog.c:			switch (ch->pcdata->tribe) {
iprog.c:			ch->hit = ch->max_hit;
iprog.c:			ch->mana = ch->max_mana;
iprog.c:			af->modifier++;
iprog.c:			SET_BIT(ch->comm,COMM_PROMPT);
iprog.c:	CHAR_DATA *ch = obj->carried_by;
iprog.c:	for(milk = ch->carrying; milk != NULL; milk=milk->next_content) {
iprog.c:		if(milk->pIndexData->vnum == 2454) {
iprog.c:	if(!found || milk->value[1] < 5)
iprog.c:	milk->value[1] = 0;
iprog.c:	CHAR_DATA *ch = obj->carried_by;
iprog.c:	CHAR_DATA *ch = obj->carried_by;
iprog.c:	EXIT_DATA *pexit = ch->in_room->exit[DIR_DOWN];
iprog.c:	if(!IS_SET(pexit->exit_info,EX_CLOSED)) {
iprog.c:	REMOVE_BIT(pexit->exit_info,EX_LOCKED);
iprog.c:	REMOVE_BIT(pexit->exit_info,EX_CLOSED);
iprog.c:	REMOVE_BIT(pexit->exit_info,EX_NONOBVIOUS);
iprog.c:	new_affect_to_room(ch->in_room,&raf);
iprog.c:	EXIT_DATA *pexit = room->exit[DIR_DOWN];
iprog.c:	SET_BIT(pexit->exit_info,EX_CLOSED);
iprog.c:	SET_BIT(pexit->exit_info,EX_LOCKED);
iprog.c:	SET_BIT(pexit->exit_info,EX_NONOBVIOUS);
iprog.c:		ch_next = ch->next;
iprog.c:		if(ch->in_room == room)
iprog.c:	for(mob = char_list; mob != NULL; mob = mob->next)
iprog.c:			if(mob->pIndexData->vnum == 24549) 
iprog.c:    if(found && ch->pcdata->quests[PETE_QUEST] == 1)
iprog.c:		ch->pcdata->quests[PETE_QUEST] = 2;
iprog.c:	for(obj2 = ch->carrying; obj2 != NULL; obj2 = obj2->next_content) {
iprog.c:		if(obj2->pIndexData->vnum == 2412) {
iprog.c:	if(obj->value[1] < 1)
iprog.c:	if(obj2->value[1] > 0)
iprog.c:	obj->value[1] -= 1;
iprog.c:	obj2->value[1] += 1;
iprog.c:	SET_BIT(obj2->extra_flags,ITEM_GLOW);
iprog.c:	af.duration = -1;
iprog.c:	CHAR_DATA *ch = obj->carried_by;
iprog.c:	if(obj->value[1] == 0) {
iprog.c:		REMOVE_BIT(obj->extra_flags,ITEM_GLOW);
iprog.c:	for(pole = ch->carrying; pole != NULL; pole = pole->next_content) {
iprog.c:		if(pole->pIndexData->vnum == 2431) {
iprog.c:	switch(obj->pIndexData->vnum) {
iprog.c:	if(ch->cabal)
iprog.c:	ch->cabal = CABAL_GUILD;
iprog.c:	ch->pcdata->cabal_level = 1;
iprog.c:	for(check = char_list; check != NULL; check=check->next) {
iprog.c:		check->in_room == ch->in_room && 
iprog.c:		(check->pIndexData->vnum == 24538 || 
iprog.c:		check->pIndexData->vnum == 24539 || 
iprog.c:		check->pIndexData->vnum == 24540)) {
iprog.c:	switch(obj->pIndexData->vnum) {
iprog.c:	char_to_room(mob,ch->in_room);
iprog.c:	if(ch->in_room->vnum != 24548)
iprog.c:	for(obj2 = ch->in_room->contents; obj2 != NULL; obj2 = obj2->next_content) {
iprog.c:		if(obj2->pIndexData->vnum == 24548)
iprog.c:	EXIT_DATA *exit = obj->in_room->exit[DIR_DOWN];
iprog.c:	REMOVE_BIT(exit->exit_info,EX_NONOBVIOUS);
iprog.c:	REMOVE_BIT(exit->exit_info,EX_LOCKED);
iprog.c:	REMOVE_BIT(exit->exit_info,EX_NOPASS);
iprog.c:	REMOVE_BIT(exit->exit_info,EX_CLOSED);
iprog.c:	EXIT_DATA *exit = obj->in_room->exit[DIR_DOWN];
iprog.c:	ROOM_INDEX_DATA *room = obj->in_room;
iprog.c:	SET_BIT(exit->exit_info,EX_NONOBVIOUS);
iprog.c:	SET_BIT(exit->exit_info,EX_LOCKED);
iprog.c:	SET_BIT(exit->exit_info,EX_NOPASS);
iprog.c:	SET_BIT(exit->exit_info,EX_LOCKED);
iprog.c:	if(!room->people)
iprog.c:	act("As the rope breaks, the metal plate slams back into the floor.",room->people,0,0,TO_ALL);
iprog.c:	EXIT_DATA *exit = ch->in_room->exit[DIR_SOUTH];
iprog.c:	if(!IS_SET(exit->exit_info, EX_CLOSED)) {
iprog.c:	REMOVE_BIT(exit->exit_info, EX_LOCKED);
iprog.c:	REMOVE_BIT(exit->exit_info, EX_CLOSED);
iprog.c:	REMOVE_BIT(exit->exit_info, EX_NONOBVIOUS);
iprog.c:	EXIT_DATA *exit = ch->in_room->exit[DIR_EAST];
iprog.c:	if(ch->fighting != NULL)
iprog.c:	if(!IS_SET(exit->exit_info,EX_NONOBVIOUS))
iprog.c:	REMOVE_BIT(exit->exit_info,EX_NONOBVIOUS);
iprog.c:	REMOVE_BIT(exit->exit_info,EX_CLOSED);
iprog.c:	REMOVE_BIT(exit->exit_info,EX_LOCKED);
iprog.c:		if(pRoom->exit[i] && pRoom->exit[i]->u1.to_room)
iprog.c:			act(mmsg,pRoom->exit[i]->u1.to_room->people,0,0,TO_ALL);
iprog.c:			act(mmsg,pRoom->people,0,0,TO_ALL);
iprog.c:			toRoom = pRoom->exit[i]->u1.to_room;
iprog.c:			if(toRoom->exit[reverse_d(i)]->u1.to_room)
iprog.c:				toRoom->exit[reverse_d(i)]->u1.to_room = NULL;
iprog.c:			pRoom->exit[i]->u1.to_room = NULL;
iprog.c:	act(omsg,eleRoom->people,0,0,TO_ALL);
iprog.c:	act(omsg,toRoom->people,0,0,TO_ALL);
iprog.c:	eleRoom->mana_rate = 100;
iprog.c:		if(toRoom->exit[i] && !toRoom->exit[i]->u1.to_room)
iprog.c:			toRoom->exit[i]->u1.to_room = eleRoom;
iprog.c:			if(!eleRoom->exit[reverse_d(i)])
iprog.c:			eleRoom->exit[reverse_d(i)]->u1.to_room = toRoom;
iprog.c:	if(!pRoom->people)
iprog.c:	act((char*)vo1,pRoom->people,0,0,TO_ALL);
iprog.c:	ROOM_INDEX_DATA *lRoom = ch->in_room, *eleRoom, *tRoom = NULL;
iprog.c:	int eDir = obj->value[0], i;
iprog.c:	eleRoom = get_room_index(obj->value[2]);
iprog.c:		if(eleRoom->exit[i] && eleRoom->exit[i]->u1.to_room)
iprog.c:			tRoom = eleRoom->exit[i]->u1.to_room;
iprog.c:	if(elInTransit || eleRoom->mana_rate == 101)
iprog.c:	eleRoom->mana_rate = 101;	//ele in use
iprog.c:	if(!lRoom->exit[eDir]->u1.to_room)
iprog.c:	else if(lRoom->exit[eDir]->u1.to_room)
iprog.c:		tRoom = get_room_index(obj->value[1]);
iprog.c:	CHAR_DATA *victim = ch->fighting;
iprog.c:	if(!victim || !IS_NPC(victim) || victim->pIndexData->vnum < 3000 || victim->pIndexData->vnum > 3010 || !is_worn(obj))
iprog.c:	CHAR_DATA *victim = ch->fighting;
iprog.c:		if(!saves_spell(ch->level,victim,DAM_LIGHT))
iprog.c:			af.duration = ch->level/12;
iprog.c:			af.modifier = -4;
iprog.c:	for(obj2=ch->in_room->contents; obj2 != NULL; obj2=obj2->next_content) {
iprog.c:		if(obj->pIndexData->vnum == obj2->pIndexData->vnum) {
iprog.c:	ROOM_INDEX_DATA *room,*room2=ch->in_room;
iprog.c:	room = victim->in_room;
iprog.c:	switch(room->sector_type) {
iprog.c:			sect = talloc_string("in mid-air");
iprog.c:		free_pstring(obj->description);
iprog.c:		sprintf(buf,"A curious mirror lies here, humming softly.  Peering into the glass, you see %s standing in %s.",victim->name,room->name);
iprog.c:		obj->description = palloc_string(buf);
iprog.c:		free_pstring(obj->description);
iprog.c:		sprintf(buf,"A curious mirror lies here, humming softly.  Peering into the glass, you see %s %s.",victim->name,sect);
iprog.c:		obj->description = palloc_string(buf);
ispec.c:// Calenduil was heeere! - note to self, possible memleak under returning without va_end
ispec.c:		if(is_name("gag", obj->name))
ispec.c:					if(*(c + argument) == ' ' && *(c + argument - 1) != ' ' && 6 * words < MAX_INPUT_LENGTH - 25)
ispec.c:				buf[strlen(buf) - 1] = '\0';
ispec.c:			if(!is_name("gag",obj->name)) { send_to_char("That's not a gag!\n\r",ch); return 0; }
ispec.c:		if(number_percent()>91 && ch->fighting)
ispec.c:			act("A scream escapes your flail as a shadow tears at $N's eyes!",ch,0,ch->fighting,TO_CHAR);
ispec.c:			act("A scream escapes $n's flail as a shadow tears at $N's eyes!",ch,0,ch->fighting,TO_NOTVICT);
ispec.c:			act("A scream escapes $n's flail as a shadow tears at your eyes!",ch,0,ch->fighting,TO_VICT);
ispec.c:			act("$n appears to be blinded.",ch->fighting,0,0,TO_ROOM);
ispec.c:			af.level = ch->level;
ispec.c:			affect_to_char(ch->fighting, &af);
ispec.c:		if(number_percent()>96 && ch->fighting)
ispec.c:			act("Sadistic urges compel you to lash out viciously at $N!",ch,0,ch->fighting,TO_CHAR);
ispec.c:			//ch->hit = UMIN(ch->max_hit, ch->hit + ((*dam) / 4));
ispec.c:		if(number_percent()>97 && IS_SET(ch->fighting->parts,PART_LEGS))
ispec.c:			CHAR_DATA *victim = ch->fighting;
ispec.c://////// ALL SPEC CODE IS ABOVE HERE - BELOW IS MAINTENANCE //////////
lookup.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
lookup.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
lookup.c:		if (race == temp->number) {
lookup.c:		temp = temp->next;
lookup.c:		if((favor = ch->pcdata->lesserdata[i]) != FAVOR_NONE)
lookup.c:		if((favor = ch->pcdata->lesserdata[i]) != FAVOR_NONE)
lookup.c:	return -1;
lookup.c:    return -1;
lookup.c:    return -1;
lookup.c:    return -1;
lookup.c:   return -1;
lookup.c:   return -1;
lookup.c:   return -1;
lookup.c:		num=-1;
magic.c:    return -1;
magic.c:    int sn, found = -1;
magic.c:	    if ( found == -1)
magic.c:	    if (ch->level >= skill_table[sn].skill_level[ch->Class()->GetIndex()]
magic.c:	    &&  ch->pcdata->learned[sn] > 0)
magic.c:    for ( rch = ch->in_room->people; rch; rch = rch->next_in_room )
magic.c:            act((!IS_NPC(rch) && ch->Class()->GetIndex()==rch->Class()->GetIndex()) ? buf : buf2,
magic.c:	   /* act( ch->Class()->GetIndex()==rch->Class()->GetIndex() ? buf : buf2, ch, NULL, rch, TO_VICT );*/
magic.c:	if(victim->fighting && get_trust(victim->fighting)==MAX_LEVEL) {
magic.c:	if (victim->saving_throw < 0) {
magic.c:	    save = 45 + ( victim->level - level) * 4 +
magic.c:		(sqrt(abs(victim->saving_throw))) * 4;
magic.c:		save = 45 + (victim->level-level) * 4 - (sqrt(victim->saving_throw)) * 4;
magic.c:		save += victim->level/3;	/* simulate npc saving throw */
magic.c:			if (!IS_NPC(victim) && !str_cmp(pc_race_table[victim->race].name,"imp"))
magic.c://    if (!IS_NPC(victim) && victim->Class()->fMana)
magic.c:		af = affect_find(victim->affected,gsn_traitors_luck);
magic.c:		if (victim->fighting && (victim->fighting == af->owner))
magic.c:			save -= 50;
magic.c:	if(is_affected_room(victim->in_room,gsn_infidels_fate) && IS_GOOD(victim))
magic.c:		save -= 20;
magic.c:/*	if(victim->fighting && !IS_NPC(victim->fighting) && !IS_NPC(victim)) {
magic.c:	sprintf(buf,"Saves_spell: Caster is probably %s, victim is %s, dt is %d.  Victim level %d, spell level %d (%d - %.2f%%mod).  
magic.c:Victim has %dsvs (%.2f%%mod).  Chance of saving is %d, roll is %d: %s", victim->fighting->name, victim->true_name, dam_type, 
magic.c:		victim->level, level, victim->level - level, (float)((victim->level - level) * 4), victim->saving_throw, 
magic.c:		(float)sqrt(abs(victim->saving_throw)) * 4, save, roll, roll < save ? "SAVED" : "FAILED");
magic.c:	sprintf(buf,"Saves_spell: victim is %s.  Victim level %d, spell level %d (%d - %.2f%%mod).",
magic.c:                victim->name, victim->level, level, victim->level - level, (float)((victim->level - level) * 4));
magic.c:    save = 50 + (spell_level - dis_level) * 5;
magic.c:	if(duration==-1)	return TRUE;
magic.c:        for ( af = victim->affected; af != NULL; af = af->next )
magic.c:            if ( af->type == sn )
magic.c:		if(!saves_dispel(dis_level,af->level,af->duration) && !IS_SET(af->bitvector,AFF_PERMANENT))
magic.c:/* co-routine for dispel magic and cancellation */
magic.c:        for ( af = victim->affected; af != NULL; af = af->next )
magic.c:            if ( af->type == sn )
magic.c:		if (af->aftype == AFT_SPELL) {
magic.c:		if(!saves_dispel(dis_level,af->level,af->duration) && !IS_SET(af->bitvector,AFF_PERMANENT))
magic.c:			damage_new(victim,victim,victim->max_hit/2,gsn_diamondskin,DAM_TRUESTRIKE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,NULL);
magic.c:		} else if (af->aftype == AFT_COMMUNE && commune && cancel) {
magic.c:		if(!saves_dispel(dis_level,af->level,af->duration) && !IS_SET(af->bitvector,AFF_PERMANENT))
magic.c:/* for finding mana costs -- temporary version */
magic.c:    if (ch->level + 2 == level)
magic.c:    return UMAX(min_mana,(100/(2 + ch->level - level)));
magic.c:	|| (ch->level < skill_table[gsn_barkskin].skill_level[ch->Class()->GetIndex()] ) )
magic.c:    if (ch->mana < 40)
magic.c:    af.level = ch->level;
magic.c:    af.modifier = ch->level / 4;
magic.c:    af.duration = ch->level;
magic.c:    ch->mana -= 40;
magic.c:	|| (ch->level < skill_table[gsn_laying_hands].skill_level[ch->Class()->GetIndex()] ) ) 
magic.c:    if (ch->mana < 35)
magic.c:    ch->mana -= skill_table[gsn_laying_hands].min_mana;
magic.c:    af.level = ch->level;
magic.c:    heal = dice(ch->level, 12);
magic.c:    victim->hit = UMIN(victim->hit + heal, victim->max_hit);
magic.c:    	if (check_dispel(ch->level-(dice(1,10)),victim,gsn_poison))                                               
magic.c:    	if(check_dispel(ch->level-(dice(3,4)),victim,gsn_plague))
magic.c:	if(check_dispel(ch->level-(dice(3,5)),victim,gsn_blindness))
magic.c:    if(ch->Class()->ctype!=CLASS_CASTER && !IS_IMMORTAL(ch))
magic.c:    if (IS_SET(ch->act,PLR_BETRAYER))
magic.c:	if(!IS_NPC(ch) && ch->pcdata->oalign==3 && ch->alignment==-1000)
magic.c:	if (IS_SET(ch->in_room->room_flags, ROOM_SILENCE)) {
magic.c:    if (!IS_NPC(ch) && ch->pcdata->energy_state>2)
magic.c:    || (!IS_NPC(ch) && ch->pcdata->learned[sn] == 0))
magic.c:    if ( ch->position < skill_table[sn].minimum_position )
magic.c:    if (ch->level + 2 == skill_table[sn].skill_level[ch->Class()->GetIndex()]) {
magic.c:			100 / ( 2 + ch->level - skill_table[sn].skill_level[ch->Class()->GetIndex()] ) );
magic.c:         	100 / ( 2 + ch->level - skill_table[sn].skill_level[ch->Class()->GetIndex()] ) );
magic.c:				    if ( ( victim = ch->fighting ) == NULL )
magic.c:				if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
magic.c:				if ( arg2[0] != '\0' && !is_name( target_name, ch->name ) )
magic.c:				    if ((victim = ch->fighting) == NULL)
magic.c:   					if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
magic.c:					!(pexit=ch->in_room->exit[where]))
magic.c:    if ( !IS_NPC(ch) && ch->mana < mana )
magic.c:		&& (!IS_NPC(ch) || !IS_SET(ch->form,FORM_NOSPEECH)))
magic.c:		ch->mana -= mana / 2;
magic.c:		ch->mana -= mana;
magic.c:	if (IS_SET(ch->in_room->room_flags,ROOM_NO_MAGIC) && !(ch->level > LEVEL_HERO)) {
magic.c:	if(((ch->Class()->GetIndex() == CLASS_SORCERER) ||
magic.c:		(ch->Class()->GetIndex() == CLASS_NECROMANCER) ||
magic.c:		(ch->Class()->GetIndex() == CLASS_SHAPESHIFTER)) &&
magic.c:		if (number_percent () < ((encumb - 90) * .2)) {
magic.c:			&& (ch->fighting == NULL 
magic.c:			|| victim->fighting == NULL)) 
magic.c:			if (can_see(ch,victim) && victim->position > POS_SLEEPING)
magic.c:		paf = affect_find(victim->affected,gsn_rotating_ward);
magic.c:		paf->modifier--;
magic.c:		if (paf->modifier <= 0) {
magic.c:		&& !(IS_NPC(victim) && victim->cabal != CABAL_SCION)
magic.c:		&& (!victim->fighting || (saves_spell(ch->level,victim,DAM_OTHER)
magic.c:		if(number_percent() < (get_skill(victim, gsn_nullify) - 10))
magic.c:		(*skill_table[sn].spell_fun) (sn, ch->level + check_spellcraft(ch, sn), ch, vo, target);
magic.c:		(*skill_table[sn].spell_fun) (sn, ch->level / 2, ch, vo, target);
magic.c:    &&   victim->master != ch
magic.c:	for ( vch = ch->in_room->people; vch; vch = vch_next )
magic.c:	    vch_next = vch->next_in_room;
magic.c:	    if ( victim == vch && victim->fighting == NULL )
magic.c:	if (IS_SET(ch->in_room->room_flags,ROOM_NO_MAGIC))
magic.c:	    victim = ch->fighting;
magic.c:	    if (ch->fighting != NULL)
magic.c:		victim = ch->fighting;
magic.c:    &&   victim->master != ch )
magic.c:	for ( vch = ch->in_room->people; vch; vch = vch_next )
magic.c:	    vch_next = vch->next_in_room;
magic.c:	    if ( victim == vch && victim->fighting == NULL ) {
magic.c:    if ( victim->position == POS_FIGHTING || is_affected( victim, sn ) )
magic.c:       af.modifier = -1;
magic.c:       af.modifier  = 0 - level / 8;
magic.c:    if (saves_spell(level-3,victim,DAM_OTHER)		|| IS_SET(victim->form,ACT_UNDEAD) || IS_SET(victim->form,FORM_UNDEAD) )
magic.c:    af.modifier  = -4;
magic.c:    level	= UMIN(level, (int)sizeof(dam_each)/(int)sizeof(dam_each[0]) - 1);
magic.c:			ch->wait = 0;
magic.c:	if (ch->Class()->ctype==CLASS_COMMUNER) commune = TRUE;
magic.c:			 !(IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim) ) ||
magic.c:		for (af = victim->affected; af != NULL; af = af->next) {
magic.c:			if (skill_table[af->type].dispel & CAN_CANCEL) {
magic.c:				check_dispel_cancellation(level, victim,ch,af->type,commune,TRUE);
magic.c:		for (af = victim->affected; af != NULL; af = af->next) {
magic.c:			if (af->type == spell)
magic.c:		if (!af || !af->type || !(skill_table[af->type].dispel & CAN_CANCEL))
magic.c:		check_dispel_cancellation(level+3, victim, ch, af->type, commune,TRUE);
magic.c:    damage_old( ch, (CHAR_DATA *) vo, dice(3, 8) + level - 6, sn,DAM_INTERNAL,TRUE);
magic.c:    level -= 4;   /* decrement damage */
magic.c:	for (tmp_vict = ch->in_room->people;
magic.c:	  next_vict = tmp_vict->next_in_room;
magic.c:	     if (number_percent()>=ch->level)
magic.c:	    level -= 4;  /* decrement damage */
magic.c:	  level -= 4;  /* decrement damage */
magic.c:	af.modifier  = number_range( 0, 2 ) - victim->sex;
magic.c:    ||   level < victim->level
magic.c:    ||   IS_SET(victim->imm_flags,IMM_CHARM)
magic.c:    ||   (IS_NPC(victim) && IS_SET(victim->act,ACT_AGGRESSIVE))
magic.c:    ||   saves_spell( level-3, victim,DAM_CHARM) )
magic.c:    for (check = char_list; check != NULL; check = check->next)
magic.c:	if (check->leader == ch && IS_AFFECTED(check,AFF_CHARM))
magic.c:	if ((ch->level < 40 && count > 0)
magic.c:	|| (ch->level < 52 && count > 1) || count > 2)
magic.c:    if ( victim->master )
magic.c:	victim->leader = ch;
magic.c:    level	= UMIN(level, (int)sizeof(dam_each)/(int)sizeof(dam_each[0]) - 1);
magic.c:	af.modifier  = -1;
magic.c:    level	= UMIN(level, (int)sizeof(dam_each)/(int)sizeof(dam_each[0]) - 1);
magic.c:	dam += dice(level-5,2);
magic.c:	dam += dice(level-5,3);
magic.c:	dam += dice(level-5,4);
magic.c:	dam += dice(level-5,5);
magic.c:	SET_BIT(light->extra_flags,ITEM_GLOW);
magic.c:    obj_to_room( light, ch->in_room );
magic.c:    mushroom->value[0] = level / 2;
magic.c:    mushroom->value[1] = level;
magic.c:    obj_to_room( mushroom, ch->in_room );
magic.c:	if (ch->in_room->sector_type == SECT_WATER ||
magic.c:		ch->in_room->sector_type == SECT_UNDERWATER ||
magic.c:		ch->in_room->sector_type == SECT_AIR ||
magic.c:		ch->in_room->sector_type == SECT_BURNING ||
magic.c:		ch->in_room->sector_type == SECT_VERTICAL) {
magic.c:    spring->timer = level;
magic.c:    obj_to_room( spring, ch->in_room );
magic.c:    if ( obj->item_type != ITEM_DRINK_CON )
magic.c:    if ( obj->value[2] != LIQ_WATER && obj->value[1] != 0 )
magic.c:		level * (ch->in_room->area->sky >= SKY_DRIZZLE ? 4 : 2),
magic.c:		obj->value[0] - obj->value[1]
magic.c:	obj->value[2] = LIQ_WATER;
magic.c:	obj->value[1] += water;
magic.c:	if ( !is_name( "water", obj->name ) )
magic.c:	    sprintf( buf, "%s water", obj->name );
magic.c:	    free_pstring( obj->name );
magic.c:	    obj->name = palloc_string( buf );
magic.c:		if (IS_NPC(ch) && IS_SET(ch->act,ACT_IS_HEALER)) {
magic.c:    heal = dice(3, 8) + level - 6;
magic.c:    victim->hit = UMIN( victim->hit + heal, victim->max_hit );
magic.c:    if (ch->Class()->name == "assassin"
magic.c:    victim->hit = UMIN( victim->hit + heal, victim->max_hit );
magic.c:    if (ch->Class()->name == "assassin"
magic.c:    victim->hit = UMIN( victim->hit + heal, victim->max_hit );
magic.c:            paf = affect_find_obj(obj->affected,skill_lookup("bless"));
magic.c:            if (!saves_dispel(level,paf != NULL ? paf->level : obj->level,0))
magic.c:                REMOVE_BIT(obj->extra_flags,ITEM_BLESS);
magic.c:	if (obj->wear_loc != WEAR_NONE)
magic.c:	    ch->saving_throw += 1;
magic.c:    af.modifier  = -1 * (level / 8);
magic.c:	oldhp =victim->hit;
magic.c:	if (victim->ghost)
magic.c:     ch->level < skill_table[gsn_detect_hidden].skill_level[ch->Class()->GetIndex()] )
magic.c:    af.level     = ch->level;
magic.c:    af.duration  = ch->level / 2;
magic.c:	ch->level < skill_table[gsn_detect_movement].skill_level[ch->Class()->GetIndex()])
magic.c:		af.level = ch->level;
magic.c:		af.duration = ch->level;
magic.c:		af.location = ch->level / 2;
magic.c:    if ( obj->item_type == ITEM_DRINK_CON || obj->item_type == ITEM_FOOD )
magic.c:	if ( obj->value[3] != 0 )
magic.c:  	if (!ch->fighting && !str_cmp(target_name,"")) {
magic.c:		ch->wait = 0;
magic.c:	if (ch->fighting && !str_cmp(target_name,""))
magic.c:		victim = ch->fighting;
magic.c:			ch->wait = 0;
magic.c:	if (ch->Class()->ctype==CLASS_COMMUNER)	commune = TRUE;
magic.c:	if(!IS_NPC(victim) && (ch != victim) && (!ch->fighting ||
magic.c:		!victim->fighting)) {
magic.c:	if (!victim->fighting && (ch != victim))
magic.c:		for (af = victim->affected; af != NULL; af = af->next) {
magic.c:			if (skill_table[af->type].dispel & CAN_DISPEL) {
magic.c:				check_dispel_cancellation(level, victim,ch,af->type,commune,FALSE);
magic.c:		for (af = victim->affected; af != NULL; af = af->next) {
magic.c:			if (af->type == spell)
magic.c:		if (!af || !af->type || !(skill_table[af->type].dispel & CAN_DISPEL))
magic.c:		check_dispel_cancellation(level+3,victim,ch,af->type,commune,FALSE);
magic.c:	vch_next	= vch->next;
magic.c:	if ( vch->in_room == NULL )
magic.c:	if ( vch->in_room == ch->in_room )
magic.c:	&& (ch->fighting == NULL || vch->fighting == NULL))
magic.c:	if ( vch->in_room->area == ch->in_room->area )
magic.c:    level	= UMIN(level, (int)sizeof(dam_each)/(int)sizeof(dam_each[0]) - 1);
magic.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
magic.c:	vch_next = vch->next_in_room;
magic.c:	&& (ch->fighting == NULL || vch->fighting == NULL))
magic.c:    af.modifier  = -1 * (short)(average_ac(victim) * (float)((float)level/(float)400));
magic.c:    for ( ich = ch->in_room->people; ich != NULL; ich = ich->next_in_room )
magic.c:	if (ich->invis_level > 0)
magic.c:	if (ich->trust > 51 )
magic.c:	REMOVE_BIT   ( ich->affected_by, AFF_HIDE	);
magic.c:	REMOVE_BIT   ( ich->affected_by, AFF_INVISIBLE	);
magic.c:	REMOVE_BIT   ( ich->affected_by, AFF_SNEAK	);
magic.c:/* RT ROM-style gate */
magic.c:    if (ch->fighting != NULL)
magic.c:    if ((IS_NPC(victim)) && ( IS_SET(victim->res_flags,RES_SUMMON) ))
magic.c:	level -= 5;
magic.c:    if ((IS_NPC(victim)) && ( IS_SET(victim->vuln_flags,VULN_SUMMON) ))
magic.c:    ||   victim->in_room == NULL
magic.c:    ||   !can_see_room(ch,victim->in_room)
magic.c:    ||   IS_SET(victim->in_room->room_flags, ROOM_NO_GATE)
magic.c:    ||   IS_SET(victim->in_room->room_flags, ROOM_SAFE)
magic.c:    ||   IS_SET(victim->in_room->room_flags, ROOM_PRIVATE)
magic.c:    ||   ch->in_room->guild != 0
magic.c:    ||	 victim->in_room->guild != 0
magic.c:    ||   (victim->in_room->cabal != 0 && victim->in_room->cabal != ch->cabal)
magic.c:    ||   IS_SET(victim->in_room->room_flags, ROOM_SOLITARY)
magic.c:    ||   IS_SET(victim->in_room->room_flags, ROOM_NO_RECALL)
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
magic.c:    ||   victim->level >= level + 4
magic.c:    ||   (!IS_NPC(victim) && !can_pk(ch,victim) && IS_SET(victim->act,PLR_NOSUMMON))
magic.c:    ||   (!IS_NPC(victim) && victim->level > LEVEL_HERO)  /* NOT trust */
magic.c:    ||   (IS_NPC(victim) && IS_SET(victim->imm_flags,IMM_SUMMON))
magic.c:	|| (is_affected_room(ch->in_room,gsn_plasma_cube) && number_percent() < 50)
magic.c:	|| (is_affected_room(victim->in_room,gsn_plasma_cube) && number_percent() < 50))
magic.c:    if (victim->in_room->cabal != 0
magic.c:        && victim->in_room->cabal != victim->cabal)
magic.c:    if (ch->pet != NULL && ch->in_room == ch->pet->in_room)
magic.c:    char_to_room(ch,victim->in_room);
magic.c:    check_plasma_thread(ch,-1);
magic.c:	act("$n steps through a gate and vanishes.",ch->pet,NULL,NULL,TO_ROOM);
magic.c:	send_to_char("You step through a gate and vanish.\n\r",ch->pet);
magic.c:	char_from_room(ch->pet);
magic.c:	char_to_room(ch->pet,victim->in_room);
magic.c:	act("$n has arrived through a gate.",ch->pet,NULL,NULL,TO_ROOM);
magic.c:	do_look(ch->pet,"auto");
magic.c:    if (ch->Class()->name == "assassin"
magic.c:    ||   IS_SET(victim->off_flags,OFF_FAST))
magic.c:    victim->hit = UMIN( victim->hit + 100, victim->max_hit );
magic.c:/* RT really nasty high-level attack spell */
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch_next )
magic.c:        vch_next = vch->next_in_room;
magic.c:	if(vch->invis_level>LEVEL_HERO)
magic.c:    ch->hit -= 100;
magic.c:	obj->name,
magic.c:        item_name(obj->item_type),
magic.c:	extra_bit_name( obj->extra_flags ),
magic.c:	obj->weight,
magic.c:	obj->cost,
magic.c:	obj->level
magic.c:    if(str_cmp(obj->material,"oldstyle")) {
magic.c:	strcat(buf,obj->material);
magic.c:    switch ( obj->item_type )
magic.c:	sprintf( buf, "Level %d spells of:", obj->value[0] );
magic.c:	if ( obj->value[1] >= 0 && obj->value[1] < MAX_SKILL && str_cmp(skill_table[obj->value[1]].name,"reserved"))
magic.c:	    send_to_char( skill_table[obj->value[1]].name, ch );
magic.c:	if ( obj->value[2] >= 0 && obj->value[2] < MAX_SKILL && str_cmp(skill_table[obj->value[2]].name,"reserved"))
magic.c:	    send_to_char( skill_table[obj->value[2]].name, ch );
magic.c:	if ( obj->value[3] >= 0 && obj->value[3] < MAX_SKILL && str_cmp(skill_table[obj->value[3]].name,"reserved"))
magic.c:	    send_to_char( skill_table[obj->value[3]].name, ch );
magic.c:	if (obj->value[4] >= 0 && obj->value[4] < MAX_SKILL && str_cmp(skill_table[obj->value[4]].name,"reserved"))
magic.c:	    send_to_char(skill_table[obj->value[4]].name,ch);
magic.c:	    obj->value[2], obj->value[0] );
magic.c:	if ( obj->value[3] >= 0 && obj->value[3] < MAX_SKILL && str_cmp(skill_table[obj->value[3]].name,"reserved"))
magic.c:	    send_to_char( skill_table[obj->value[3]].name, ch );
magic.c:        sprintf(buf,"It holds %s-colored %s.\n\r",
magic.c:            liq_table[obj->value[2]].liq_color,
magic.c:            liq_table[obj->value[2]].liq_name);
magic.c:	    obj->value[0], obj->value[3], cont_bit_name(obj->value[1]));
magic.c:	switch (obj->value[0])
magic.c:		obj->value[1],(obj->value[1] * obj->value[2]),
magic.c:		(1 + obj->value[2]) * obj->value[1] / 2);
magic.c:        if (obj->value[4])  /* weapon flags */
magic.c:            sprintf(buf,"Weapons flags: %s\n\r",weapon_bit_name(obj->value[4]));
magic.c:	    obj->value[0], obj->value[1], obj->value[2], obj->value[3] );
magic.c:	for (app = obj->apply; app; app = app->next) {
magic.c:			affect_loc_name( app->location ), app->modifier );
magic.c:    level	= UMIN(level, (int)sizeof(dam_each)/(int)sizeof(dam_each[0]) - 1);
magic.c:	if (ch->Class()->name == "sorcerer") {
magic.c:	for ( obj = object_list; obj != NULL; obj = obj->next ) {
magic.c:			|| !is_name( target_name, obj->name )
magic.c:			|| ch->level < obj->level
magic.c:			|| (obj->carried_by && IS_IMMORTAL(obj->carried_by)))
magic.c:		for ( in_obj = obj; in_obj->in_obj != NULL; in_obj = in_obj->in_obj );
magic.c:		if ( in_obj->carried_by != NULL) {
magic.c:			if (!is_affected(in_obj->carried_by, gsn_shadow_cloak)) {
magic.c:				sprintf( buf, "%s is carried by %s.\n\r", obj->short_descr, PERS(in_obj->carried_by, ch) );
magic.c:				number--;
magic.c:		} else if (in_obj->in_room != NULL) {
magic.c:			if( is_affected(in_obj->carried_by, gsn_stash))
magic.c:				sprintf( buf, "%s's location is blurry, you have a hard time trying to locate it.\n\r", obj->short_descr);
magic.c:				sprintf( buf, "%s is in %s.\n\r",obj->short_descr, in_obj->in_room->name);
magic.c:			number--;
magic.c:    level	= UMIN(level, (int)sizeof(dam_each)/(int)sizeof(dam_each[0]) - 1);
magic.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
magic.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
magic.c:	if (IS_SET(victim->imm_flags, IMM_DISEASE))
magic.c:		|| (IS_NPC(victim) && IS_SET(victim->act,ACT_UNDEAD))
magic.c:    af.modifier  	= -5;
magic.c:	if (!ch->in_room)
magic.c:	if (af->level == 1)
magic.c:	plague.owner		=	af->owner;
magic.c:	plague.level		=	af->level - 1;
magic.c:	plague.duration		=	af->level / 5;
magic.c:	plague.modifier		=	-5;
magic.c:	for (vch = ch->in_room->people; vch; vch = vch->next_in_room) {
magic.c:		if (!saves_spell(plague.level - 2, vch, DAM_DISEASE)
magic.c:	dam = UMIN(ch->level, af->level);
magic.c:	damage_new(af->owner, ch, dam, gsn_plague, DAM_DISEASE, TRUE, HIT_UNBLOCKABLE, HIT_NOADD, HIT_NOMULT, "sickness");
magic.c:	ch->mana -= number_range(af->level/2,(int)(af->level*1.5));
magic.c:	ch->move -= number_range(af->level/2,(int)(af->level*1.5));
magic.c:	if (obj->item_type == ITEM_FOOD || obj->item_type == ITEM_DRINK_CON)
magic.c:	    obj->value[3] = 1;
magic.c:    af.modifier  = -6;
magic.c:	if (!af->owner)
magic.c:		af->owner = ch;
magic.c:	damage_new(af->owner,ch,af->level,gsn_poison,DAM_POISON,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"poison");
magic.c:    if (obj->item_type != ITEM_WAND && obj->item_type != ITEM_STAFF)
magic.c:    if (obj->value[3] >= 3 * level / 2)
magic.c:    if (obj->value[1] == 0)
magic.c:    chance -= obj->value[3]; /* harder to do high-level spells */
magic.c:    chance -= (obj->value[1] - obj->value[2]) *
magic.c:	      (obj->value[1] - obj->value[2]);
magic.c:	obj->value[2] = UMAX(obj->value[1],obj->value[2]);
magic.c:	obj->value[1] = 0;
magic.c:	chargemax = obj->value[1] - obj->value[2];
magic.c:	obj->value[2] += chargeback;
magic.c:	obj->value[1] = 0;
magic.c:	if (obj->value[1] > 1)
magic.c:	    obj->value[1]--;
magic.c:    victim->move = UMIN( victim->move + level, victim->max_move );
magic.c:    if (victim->max_move == victim->move)
magic.c:	    	&&  !saves_dispel(level + 2,obj->level,0))
magic.c:				REMOVE_BIT(obj->extra_flags,ITEM_NODROP);
magic.c:				REMOVE_BIT(obj->extra_flags,ITEM_NOREMOVE);
magic.c:   for (obj = victim->carrying; (obj != NULL && !found); obj = obj->next_content)
magic.c:            if (!saves_dispel(level,obj->level,0))
magic.c:                REMOVE_BIT(obj->extra_flags,ITEM_NODROP);
magic.c:                REMOVE_BIT(obj->extra_flags,ITEM_NOREMOVE);
magic.c:	if(ch->Class()->GetIndex()==CLASS_ZEALOT && victim!=ch)
magic.c:    level	= UMIN(level, (int)sizeof(dam_each)/(int)sizeof(dam_each[0]) - 1);
magic.c:    ||   (IS_NPC(victim) && IS_SET(victim->act,ACT_UNDEAD))
magic.c:    ||   (level + 2) < victim->level
magic.c:    ||   saves_spell(level-1, victim,DAM_CHARM)
magic.c:    ||   IS_SET(victim->imm_flags,IMM_SLEEP))
magic.c:	victim->position = POS_SLEEPING;
magic.c:    if (ch->Class()->name == "assassin"
magic.c:		REMOVE_BIT(victim->affected_by,AFF_HASTE);
magic.c:    af.modifier  = -1 - (level >= 18) - (level >= 25) - (level >= 32);
magic.c:    ||   victim->in_room == NULL
magic.c:    ||   (!IS_NPC(victim) && victim->in_room->area != ch->in_room->area)
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_SAFE)
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_SUMMON_TO)
magic.c:    ||   ch->in_room->guild != 0
magic.c:    ||	 victim->in_room->guild != 0
magic.c:    ||   (IS_NPC(victim) && IS_AFFECTED(victim,AFF_CHARM) && victim->in_room->area != ch->in_room->area)
magic.c:    ||   IS_SET(victim->in_room->room_flags, ROOM_SAFE)
magic.c:    ||   IS_SET(victim->in_room->room_flags, ROOM_PRIVATE)
magic.c:    ||   IS_SET(victim->in_room->room_flags, ROOM_SOLITARY)
magic.c:    ||   IS_SET(victim->in_room->room_flags, ROOM_NO_SUMMON_FROM)
magic.c:    ||   (IS_NPC(victim) && IS_SET(victim->act,ACT_AGGRESSIVE))
magic.c:    ||   (IS_NPC(victim) && victim->level >= (level + 10))
magic.c:    ||   (!IS_NPC(victim) && victim->level >= LEVEL_IMMORTAL && !IS_IMMORTAL(ch))
magic.c:    ||   victim->fighting != NULL
magic.c:    ||   (IS_NPC(victim) && IS_SET(victim->imm_flags,IMM_SUMMON))
magic.c:    ||	 (IS_NPC(victim) && victim->pIndexData->pShop != NULL)
magic.c:    ||   (IS_NPC(victim) && IS_SET(victim->act,ACT_AGGRESSIVE))
magic.c:    ||   (!IS_NPC(victim) && !can_pk(ch, victim) && IS_SET(victim->act,PLR_NOSUMMON))
magic.c:    ||   (IS_EXPLORE(ch->in_room))
magic.c:    ||   (IS_EXPLORE(victim->in_room))
magic.c:	if(saves_spell(level-1,victim,DAM_OTHER))
magic.c:		ch->in_room->area == victim->in_room->area ||
magic.c:		(is_adjacent_area(ch->in_room->area, victim->in_room->area) && number_percent() > 70) || //30% chance + 6%
magic.c:    	char_to_room( victim, ch->in_room );
magic.c:    	check_plasma_thread(victim,-1);
magic.c:	    	victim->law_pass = TRUE; //summoned mobs give less xp
magic.c:/* Modified teleport -- only within radius of one area now. */
magic.c:    if ( victim->in_room == NULL
magic.c:    || (!IS_NPC(ch) && IS_SET(victim->in_room->room_flags, ROOM_NO_RECALL))
magic.c:    || ( victim != ch && IS_SET(victim->imm_flags,IMM_SUMMON))
magic.c:	|| ( victim->in_room->area->area_type == ARE_UNOPENED)
magic.c:	|| (is_affected_room(ch->in_room,gsn_plasma_cube) && number_percent() < 50))
magic.c:    	if (!IS_SET(pRoomIndex->room_flags, ROOM_NO_RECALL)
magic.c:			&& !IS_SET(pRoomIndex->room_flags, ROOM_NO_GATE)
magic.c:			&& !pRoomIndex->cabal
magic.c:			&& pRoomIndex->area->area_type != ARE_UNOPENED
magic.c:			&& pRoomIndex->area->area_type != ARE_SHRINE
magic.c:			&& (is_adjacent_area(ch->in_room->area,pRoomIndex->area)
magic.c:			|| (ch->in_room->area == pRoomIndex->area)))
magic.c:	 * an infinite loop -- El
magic.c:		pRoomIndex = victim->in_room;
magic.c:    check_plasma_thread(victim,-1);
magic.c:	level -= 3;
magic.c:    if (!IS_NPC(ch) && ch->pcdata->special == SPEC_PALADIN_HUNTER)
magic.c:    for (victim = ch->in_room->people; victim != NULL; victim = v_next)
magic.c:	v_next = victim->next_in_room;
magic.c:	if (is_same_group(victim,ch) || !IS_SET(victim->act,ACT_UNDEAD) )
magic.c:	value = UMAX(1, level - victim->level + 10);
magic.c:	value = UMAX(13, value - 4);
magic.c:	if ( ( (ch->level > (victim->level + 15) ) && IS_NPC(victim) && IS_GOOD(ch) )
magic.c:	|| ( (ch->level > (victim->level + 20) ) && IS_NPC(victim) ) ||
magic.c:    for (follower = char_list; follower != NULL; follower = follower->next)
magic.c:	if ( (follower->master == ch) && IS_SET(follower->act,ACT_UNDEAD)
magic.c:		count += follower->level;
magic.c:    for (victim = ch->in_room->people; victim != NULL; victim = v_next)
magic.c:	v_next = victim->next_in_room;
magic.c:	if (is_same_group(victim,ch) || !IS_SET(victim->act,ACT_UNDEAD) )
magic.c:	if ( (ch->level*3 < count*2 )
magic.c:	|| (ch->level < 20 && num > 0)
magic.c:	|| (ch->level < 40 && num > 1)
magic.c:	|| (ch->level < 51 && num > 2)
magic.c:	|| (ch->level < (victim->level + 10))
magic.c:	|| saves_spell(ch->level,victim,DAM_OTHER)
magic.c:	victim->master = ch;
magic.c:	victim->leader = ch;
magic.c:	SET_BIT(victim->affected_by,AFF_CHARM);
magic.c:	REMOVE_BIT(victim->act,ACT_AGGRESSIVE);
magic.c:	count += victim->level;
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room )
magic.c:	if (!is_exact_name( speaker, vch->name) && IS_AWAKE(vch))
magic.c:    af.modifier  = -1 * (level / 5);
magic.c:    location = get_room_index(hometown_table[victim->hometown].recall);
magic.c:	if ((IS_SET(victim->in_room->room_flags,ROOM_NO_RECALL)
magic.c:	&& !(is_affected_room(ch->in_room,gsn_consecrate)) )
magic.c:	|| (is_affected_room(ch->in_room,gsn_plasma_cube) && number_percent() < 50)
magic.c:	victim->disrupted = FALSE;
magic.c:	if (ch->fighting || ch->disrupted)
magic.c:    ch->move /= 2;
magic.c:    check_plasma_thread(ch,-1);
magic.c:    hpch = ch->hit/9;
magic.c:    if (dam > ch->hit)
magic.c:	dam = ch->hit;
magic.c:    hpch = UMAX(12,ch->hit);
magic.c:    hpch = ch->hit/9;
magic.c:    if (dam > ch->hit)
magic.c:	dam = ch->hit;
magic.c:    fire_effect(victim->in_room,level,dam/2,TARGET_ROOM);
magic.c:    for (vch = victim->in_room->people; vch != NULL; vch = vch_next)
magic.c:	vch_next = vch->next_in_room;
magic.c:	&&   (ch->fighting != vch || vch->fighting != ch)))
magic.c:	if (is_safe(ch,vch) && vch->fighting!=NULL && vch->fighting!=ch)
magic.c:	    if (saves_spell(level - 2,vch,DAM_FIRE))
magic.c:    hpch = ch->hit/9;
magic.c:    if (dam > ch->hit)
magic.c:	dam = ch->hit;
magic.c:    hpch = UMAX(12,ch->hit);
magic.c:    cold_effect(victim->in_room,level,dam/2,TARGET_ROOM);
magic.c:    for (vch = victim->in_room->people; vch != NULL; vch = vch_next)
magic.c:	vch_next = vch->next_in_room;
magic.c:	&&   (ch->fighting != vch || vch->fighting != ch)))
magic.c:        if ((is_safe(ch,vch) && vch->fighting!=NULL && vch->fighting!=ch) || vch==ch)
magic.c:	    if (saves_spell(level - 2,vch,DAM_COLD))
magic.c:	poison_effect(ch->in_room,level,dam,TARGET_ROOM);
magic.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
magic.c:		vch_next = vch->next_in_room;
magic.c:		if (is_safe(ch,vch) && vch->fighting!=NULL && vch->fighting!=ch)
magic.c:	dam = UMAX(100,ch->hit/10);
magic.c:    hpch = ch->hit/9;
magic.c:    if (dam > ch->hit)
magic.c:	dam = ch->hit;
magic.c:    hpch = UMAX(10,ch->hit);
magic.c:        for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
magic.c:        	vch_next = vch->next_in_room;
magic.c:			if (ch->cabal>0 && ch->cabal==vch->cabal)
magic.c:			if (!IS_NPC(ch) && !IS_NPC(vch) && (ch->fighting == NULL || vch->fighting == NULL))
magic.c:	AFFECT_DATA *paf = affect_find(ch->affected, gsn_sanguine_ward);
magic.c:	return paf->modifier;
magic.c:    	af.level     	= ch->level;
magic.c:	if (ch->in_room->vnum == 1212 || IS_SET(ch->in_room->room_flags,ROOM_NO_CONSECRATE) || IS_SET(ch->in_room->room_flags,ROOM_FORCE_DUEL))
magic.c:	if (is_affected_room(ch->in_room,gsn_consecrate))
magic.c:        if (!IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL) )
magic.c:        chance = ch->level + (ch->pcdata->learned[sn]/2);
magic.c:        in_room = ch->in_room;
magic.c:        if ( (pexit = in_room->exit[door]) == NULL
magic.c:        || (room_check = pexit->u1.to_room ) == NULL)
magic.c:        if (IS_SET(room_check->room_flags, ROOM_NO_RECALL) )
magic.c:        chance -= count*10;
magic.c:	new_affect_to_room( ch->in_room,&raf);
magic.c:    pRoomIndex = get_room_index(hometown_table[ch->hometown].recall);
magic.c:    for (gch = ch->in_room->people; gch != NULL; gch = gch_next)
magic.c:	gch_next = gch->next_in_room;
magic.c:    if (IS_SET(gch->in_room->room_flags,ROOM_NO_RECALL) ||
magic.c:        || (ch->in_room->cabal != 0
magic.c:        && ch->cabal != ch->in_room->cabal))
magic.c:    for (gch = ch->in_room->people; gch != NULL; gch = gch_next)
magic.c:	gch_next = gch->next_in_room;
magic.c:    if (IS_SET(gch->in_room->room_flags,ROOM_NO_RECALL) ||
magic.c:	if (gch->fighting != NULL)
magic.c:    ch->move /=2;		
magic.c:	af.level = ch->level;
magic.c:	if (ch->ghost > 0)
magic.c:	if (victim->ghost > 0  ||  (victim->in_room != ch->in_room))
magic.c:	if (victim->ghost > 0)
magic.c:    if ( (corpse->item_type != ITEM_CORPSE_PC) && (corpse->item_type != ITEM_CORPSE_NPC))
magic.c:    if (IS_SET(corpse->extra_flags,CORPSE_NO_ANIMATE))
magic.c:    sprintf(buf,"The spirit tells you 'I was slain by %s, now allow me my peace.'\n\r",corpse->talked);
magic.c:/* New energy drain spell due to anti-paladin's always complaining how
magic.c:-Ceran
magic.c:	if(saves_spell(level-3,victim,DAM_NEGATIVE))
magic.c:	ch->hit+=UMIN(amount,20);
magic.c:	victim->mana/=2;
magic.c:	victim->move/=2;
magic.c:	bonus = (get_skill(ch,gsn_spellcraft) - 50) / 5;
magic.c:	bonus -= number_range(0,5);
magic.c:		ch->level < skill_table[gsn_spellcraft].skill_level[ch->Class()->GetIndex()])
magic.c:	 * bash-casting below.
magic.c:		bonus /= 0.5 * (27 - get_curr_stat(ch, STAT_INT));
magic.c:        klevel = level - 7;
magic.c:        for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
magic.c:        vch_next=  vch->next_in_room;
magic.c:	&& (ch->fighting == NULL || vch->fighting == NULL))
magic.c:        if (vch->level > klevel
magic.c:        || IS_SET(vch->act,ACT_UNDEAD)
magic.c:        || IS_SET(vch->imm_flags,IMM_NEGATIVE))
magic.c:        if (saves_spell(klevel - bonus, vch, DAM_NEGATIVE)
magic.c:                if (saves_spell(level - bonus, vch, DAM_NEGATIVE))
magic.c:        if (IS_SET(ch->in_room->room_flags,ROOM_INDOORS)
magic.c:        || ch->in_room->sector_type == SECT_INSIDE)
magic.c:        for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
magic.c:        vch_next = vch->next_in_room;
magic.c:	&& (ch->fighting == NULL || vch->fighting == NULL))
magic.c:spell_poison(sn_poison,level - 5,ch,vch,target);
magic.c:spell_weaken(sn_weaken,level - 5,ch,vch,target);
magic.c:spell_curse(sn_curse,level - 8, ch,vch,target);
magic.c:        af.modifier = ch->level/7;
magic.c:	if (ch->level > 40)
magic.c:	af.modifier = -ch->level/10;
magic.c:        victim = ch->fighting;
magic.c:        if (is_affected(ch,sn) || victim == NULL || ch->level < 30)
magic.c:        if (saves_spell(ch->level,victim,DAM_HOLY))
magic.c:        if (number_percent() > ch->level * 2)
magic.c:        af.level = ch->level;
magic.c:    af.modifier = -level/10;
magic.c:    if (saves_spell(level - 5,victim,DAM_OTHER))
magic.c:    if (IS_SET(obj->extra_flags,ITEM_NODROP))
magic.c:    if (victim->carry_number >= can_carry_n(victim)
magic.c:    || victim->carry_weight >= can_carry_w(victim)
magic.c:    if (IS_SET(victim->act,PLR_NO_TRANSFER))
magic.c:    vnum = obj->pIndexData->vnum;
magic.c:    if (obj->timer > 10)
magic.c:    obj->timer += number_range(level/2,level);
magic.c:    if (!saves_spell(level - 2,victim,DAM_OTHER))
magic.c:        if (!saves_spell(level - 5,victim,DAM_OTHER))
magic.c:    af.modifier = -number_range(2,range + 1);
magic.c:    af.modifier = -number_range(2,range + 1);
magic.c:    af.modifier = -number_range(1,range);
magic.c:    af.modifier = -number_range(2,range);
magic.c:    af.modifier = -number_range(2,range);
magic.c:    if (victim->position == POS_FIGHTING)
magic.c:    if (victim->position == POS_FIGHTING)
magic.c:    if (victim->position == POS_FIGHTING)
magic.c:	if (!IS_NPC(ch) && ch->Class()->GetIndex() == CLASS_HEALER)
magic.c:	if (saves_spell(level,victim,DAM_OTHER) || !str_cmp(race_table[victim->race].name,"troll"))
magic.c:	|| !str_cmp(race_table[victim->race].name,"troll"))
magic.c:    af.modifier = number_range(-3,-level/12);
magic.c:    victim->hit = UMIN(victim->hit + 100, victim->max_hit);
magic.c:    chance = 55+(victim->saving_throw*.5);
magic.c:    if(victim->position==POS_FIGHTING)
magic.c:	chance-=13;
magic.c:	chance-=25;
magic.c:    chance-=10;
magic.c:	for (rch = ch->in_room->people; rch; rch = rch->next_in_room)
magic.c:	for (rch = ch->in_room->people; rch; rch = rch->next_in_room)
magic.c:	do_murder(victim, rch->name);
magic.c:	do_murder(victim, ch->name);
magic.c:            dam-=60;
magic.c:        if (saves_spell(level-2,victim, DAM_CHARM))
magic.c:	if(ch->talismanic > 2) {
magic.c:	for (paf = ch->affected;paf != NULL;paf = paf->next) {
magic.c:		if (paf->type == gsn_talismanic) break;
magic.c:	if(ch->Class()->name == "necromancer")
magic.c:	else if (ch->Class()->name == "sorcerer")
magic.c:	af.modifier = -(short)(ch->level * reduction);
magic.c:		ch->talismanic++;
magic.c:		ch->talismanic++;
magic.c:	if (af->aftype == AFT_INVIS) {	
magic.c:	if (obj->in_room && obj->in_room->people)
magic.c:		act("The last traces of the puddle fade, as it seeps into the ground and evaporates.",obj->in_room->people,0,0,TO_ALL);
magic.c:	ch->mana = 0;
magic.c:	REMOVE_BIT(ch->comm, COMM_LOTS_O_COLOR);
magic.c:        af.level = ch->level;
magic.c:	SET_BIT(victim->comm, COMM_LOTS_O_COLOR);
material.c:    { "slime mold juice",	"green",		{   0, 	2, -8, 	1,  2 }	},
material.c:    { "blood",				"red",			{   0, 	2, -1, 	2,  6 }	},
material.c:    { "salt water",			"clear",		{   0, 	1, -2, 	0,  1 }	},
material.c:    { "mead",				"honey-colored",{  34, 	2, 	8, 	2, 12 } },
mem.c: *  and has been used here for OLC - OLC would not be what it is without   *
mem.c:        reset_free      =   reset_free->next;
mem.c:	pReset->next        =   NULL;
mem.c:	pReset->command     =   'X';
mem.c:    pReset->arg1        =   0;
mem.c:    pReset->arg2        =   0;
mem.c:    pReset->arg3        =   0;
mem.c:    pReset->next            = reset_free;
mem.c:        area_free   =   area_free->next;
mem.c:    pArea->next             =   NULL;
mem.c:    pArea->name             =   palloc_string( "New area" );
mem.c:    SET_BIT(pArea->area_flags, AREA_ADDED);
mem.c:    pArea->security         =   1;
mem.c:    pArea->builders         =   palloc_string( "None" );
mem.c:	pArea->credits			=	palloc_string( "None" );
mem.c:	pArea->min_vnum            =   0;
mem.c:    pArea->max_vnum            =   0;
mem.c:    pArea->age              =   0;
mem.c:    pArea->nplayer          =   0;
mem.c:    pArea->empty            =   TRUE;              /* ROM patch */
mem.c:    sprintf( buf, "area%d.are", pArea->vnum );
mem.c:    pArea->file_name        =   palloc_string( buf );
mem.c:    pArea->vnum             =   top_area-1;
mem.c:	pArea->area_type		=	ARE_UNOPENED;
mem.c:	pArea->climate			=	0;
mem.c:	pArea->low_range		=	0;
mem.c:	pArea->high_range		=	0;
mem.c:	zero_vector(pArea->progtypes);
mem.c:    free_pstring( pArea->name );
mem.c:    free_pstring( pArea->file_name );
mem.c:    free_pstring( pArea->builders );
mem.c:    pArea->next         =   area_free->next;
mem.c:        exit_free       =   exit_free->next;
mem.c:    pExit->u1.to_room   =   NULL;                  /* ROM OLC */
mem.c:    pExit->next         =   NULL;
mem.c:/*  pExit->vnum         =   0;                        ROM OLC */
mem.c:    zero_vector(pExit->exit_info);
mem.c:    pExit->key          =   0;
mem.c:    pExit->keyword      =  	NULL;
mem.c:    pExit->description  =   NULL;
mem.c:    free_pstring( pExit->keyword );
mem.c:    free_pstring( pExit->description );
mem.c:    pExit->next         =   exit_free;
mem.c:        extra_descr_free    =   extra_descr_free->next;
mem.c:    pExtra->keyword         =   NULL;
mem.c:    pExtra->description     =   NULL;
mem.c:    pExtra->next            =   NULL;
mem.c:    free_pstring( pExtra->keyword );
mem.c:    free_pstring( pExtra->description );
mem.c:    pExtra->next        =   extra_descr_free;
mem.c:        room_index_free =   room_index_free->next;
mem.c:    pRoom->next             =   NULL;
mem.c:	pRoom->next_room		=	NULL;
mem.c:	pRoom->aff_next			=	NULL;
mem.c:	pRoom->people           =   NULL;
mem.c:    pRoom->contents         =   NULL;
mem.c:    pRoom->extra_descr      =   NULL;
mem.c:    pRoom->area             =   NULL;
mem.c:        pRoom->exit[door]   =   NULL;
mem.c:		pRoom->tracks[i] = new_track_data();
mem.c:	pRoom->path				=	NULL;
mem.c:    pRoom->name             =   palloc_string("Dummy Room");
mem.c:    pRoom->description      =   NULL;
mem.c:	pRoom->owner			=	palloc_string("none");
mem.c:	pRoom->vnum             =   0;
mem.c:    zero_vector(pRoom->room_flags);
mem.c:    pRoom->sector_type      =   0;
mem.c:    pRoom->heal_rate	    =   100;
mem.c:    pRoom->mana_rate	    =   100;
mem.c:	pRoom->cabal			=	0;
mem.c:	pRoom->guild			=	0;
mem.c:	pRoom->affected			=	NULL;
mem.c:	zero_vector(pRoom->affected_by);
mem.c:	pRoom->move_progs		=	FALSE;
mem.c:	pRoom->rune				=	NULL;
mem.c:	pRoom->has_rune			=	FALSE;
mem.c:	pRoom->light			=	0;
mem.c:	pRoom->reset_first		=	NULL;
mem.c:	pRoom->reset_last		=	NULL;
mem.c:	zero_vector(pRoom->progtypes);
mem.c:	pRoom->trap				=	NULL;
mem.c:    free_pstring( pRoom->name );
mem.c:    free_pstring( pRoom->description );
mem.c:        if ( pRoom->exit[door] )
mem.c:            free_exit( pRoom->exit[door] );
mem.c:    for ( pExtra = pRoom->extra_descr; pExtra; pExtra = pExtra->next )
mem.c:    for ( pReset = pRoom->reset_first; pReset; pReset = pReset->next )
mem.c:    pRoom->next     =   room_index_free;
mem.c:        affect_free     =   affect_free->next;
mem.c:    pAf->next       =   NULL;
mem.c:    pAf->location   =   0;
mem.c:    pAf->modifier   =   0;
mem.c:    pAf->type       =   0;
mem.c:    pAf->duration   =   0;
mem.c:    pAf->bitvector  =   0;
mem.c:    pAf->next           = affect_free;
mem.c:	pShop->open_hour    =   0;
mem.c:    pShop->close_hour   =   23;
mem.c:	pShop->direction	=	0;
mem.c:    pShop->next = shop_free;
mem.c:        obj_index_free  =   obj_index_free->next;
mem.c:    pObj->next          =   NULL;
mem.c:    pObj->extra_descr   =   NULL;
mem.c:    pObj->affected      =   NULL;
mem.c:    pObj->area          =   NULL;
mem.c:    pObj->name          =   palloc_string( "no name" );
mem.c:    pObj->level		=   1;
mem.c:    pObj->short_descr   =   palloc_string( "dummy object" );
mem.c:    pObj->description   =   palloc_string( "dummy desc" );
mem.c:    pObj->vnum          =   0;
mem.c:    pObj->item_type     =   ITEM_TRASH;
mem.c:    zero_vector(pObj->extra_flags);
mem.c:    zero_vector(pObj->wear_flags);
mem.c:    zero_vector(pObj->restrict_flags);
mem.c:    pObj->start_timer	=   0;
mem.c:    pObj->count         =   0;
mem.c:    pObj->weight        =   0;
mem.c:    pObj->cost          =   0;
mem.c:    pObj->limtotal	=   0;
mem.c:    pObj->material      =   palloc_string( "unknown" );      /* ROM */
mem.c:    pObj->condition     =   100;                        /* ROM */
mem.c:    pObj->verb			=   NULL;
mem.c:	pObj->wear_echo[0]	=	NULL;
mem.c:	pObj->wear_echo[1]	=	NULL;
mem.c:	pObj->wear_echo[2]	=	NULL;
mem.c:	pObj->remove_echo[0]=	NULL;
mem.c:	pObj->remove_echo[1]=	NULL;
mem.c:	pObj->remove_echo[2]=	NULL;
mem.c:	pObj->cabal			=	0;
mem.c:	pObj->notes			=	NULL;
mem.c:	pObj->wear_loc_name =	NULL;
mem.c:	pObj->charaffs		=	NULL;
mem.c:	pObj->extra_descr	=	NULL;
mem.c:	pObj->apply			=	NULL;
mem.c:	for ( value = 0; value < 5; value++ )               /* 5 - ROM */
mem.c:        pObj->value[value]  =   0;
mem.c:    pObj->spec_prog.trapvector = 0;
mem.c:    pObj->new_format    = TRUE; /* ROM */
mem.c:	zero_vector(pObj->progtypes);
mem.c:	zero_vector(pObj->imm_flags);
mem.c:	zero_vector(pObj->res_flags);
mem.c:	zero_vector(pObj->vuln_flags);
mem.c:    pObj->limcount		= 0;
mem.c:    free_pstring( pObj->name );
mem.c:    free_pstring( pObj->short_descr );
mem.c:    free_pstring( pObj->description );
mem.c:    for ( pAf = pObj->affected; pAf; pAf = pAf->next )
mem.c:    for ( pExtra = pObj->extra_descr; pExtra; pExtra = pExtra->next )
mem.c:    pObj->next              = obj_index_free;
mem.c:        mob_index_free  =   mob_index_free->next;
mem.c:    pMob->next          =   NULL;
mem.c:    pMob->pShop         =   NULL;
mem.c:    pMob->area          =   NULL;
mem.c:    pMob->player_name   =   palloc_string( "no name" );
mem.c:    pMob->short_descr   =   palloc_string( "dummy mob" );
mem.c:    pMob->long_descr    =   palloc_string( "A dummy mob is standing here.\n\r" );
mem.c:    pMob->description   =   NULL;
mem.c:    pMob->vnum          =   0;
mem.c:    pMob->count         =   0;
mem.c:    pMob->killed        =   0;
mem.c:    pMob->sex           =   0;
mem.c:    pMob->level         =   0;
mem.c:	pMob->dam_type		=	0;
mem.c:	zero_vector(pMob->act);
mem.c:	SET_BIT(pMob->act, ACT_IS_NPC);
mem.c:    zero_vector(pMob->affected_by);
mem.c:    pMob->alignment     =   0;
mem.c:    pMob->hitroll	=   0;
mem.c:	pMob->dam_mod		=	100;
mem.c:    pMob->race          =   race_lookup( "human" ); /* - Hugin */
mem.c:    zero_vector(pMob->form);           /* ROM patch -- Hugin */
mem.c:    zero_vector(pMob->parts);          /* ROM patch -- Hugin */
mem.c:    zero_vector(pMob->imm_flags);           /* ROM patch -- Hugin */
mem.c:    zero_vector(pMob->res_flags);           /* ROM patch -- Hugin */
mem.c:	zero_vector(pMob->vuln_flags);           /* ROM patch -- Hugin */
mem.c:    zero_vector(pMob->off_flags);           /* ROM patch -- Hugin */
mem.c:    pMob->size          =   SIZE_MEDIUM; /* ROM patch -- Hugin */
mem.c:    pMob->ac[AC_PIERCE]	=   0;           /* ROM patch -- Hugin */
mem.c:    pMob->ac[AC_BASH]	=   0;           /* ROM patch -- Hugin */
mem.c:    pMob->ac[AC_SLASH]	=   0;           /* ROM patch -- Hugin */
mem.c:    pMob->ac[AC_EXOTIC]	=   0;           /* ROM patch -- Hugin */
mem.c:    pMob->hit[DICE_NUMBER]	=   0;   /* ROM patch -- Hugin */
mem.c:    pMob->hit[DICE_TYPE]	=   0;   /* ROM patch -- Hugin */
mem.c:    pMob->hit[DICE_BONUS]	=   0;   /* ROM patch -- Hugin */
mem.c:    pMob->mana[DICE_NUMBER]	=   0;   /* ROM patch -- Hugin */
mem.c:    pMob->mana[DICE_TYPE]	=   0;   /* ROM patch -- Hugin */
mem.c:    pMob->mana[DICE_BONUS]	=   0;   /* ROM patch -- Hugin */
mem.c:    pMob->damage[DICE_NUMBER]	=   0;   /* ROM patch -- Hugin */
mem.c:    pMob->damage[DICE_TYPE]	=   0;   /* ROM patch -- Hugin */
mem.c:    pMob->damage[DICE_NUMBER]	=   0;   /* ROM patch -- Hugin */
mem.c:    pMob->start_pos             =   POS_STANDING; /*  -- Hugin */
mem.c:    pMob->wealth                =   0;
mem.c:	pMob->restrict_low			=	-1;
mem.c:	pMob->restrict_high			=	65535;
mem.c:	pMob->SetClass(CLASS_NONE);
mem.c:	pMob->new_format            = TRUE;  /* ROM */
mem.c:	pMob->barred_entry			= NULL;
mem.c:	pMob->mprogs				= NULL;
mem.c:    pMob->game_fun		= NULL;
mem.c:	zero_vector(pMob->progtypes);
mem.c:		pMob->affect_sn[i]=-1;
mem.c:		pMob->cast_spell[i]=NULL;
mem.c:	pMob->speech		= NULL; //DIE MORGLUM DIE
mem.c:    pMob->cabal			= 0;
mem.c:    pMob->attack_yell	= NULL;
mem.c:	pMob->notes			= NULL;
mem.c:	zero_vector(pMob->styles);
mem.c:	pMob->ele_major		= 0;
mem.c:	pMob->ele_para		= 0;
mem.c:    free_pstring( pMob->player_name );
mem.c:    free_pstring( pMob->short_descr );
mem.c:    free_pstring( pMob->long_descr );
mem.c:    free_pstring( pMob->description );
mem.c:    free_shop( pMob->pShop );
mem.c:    pMob->next              = mob_index_free;
misc.c:				strcat(buf,ch->name);
misc.c:				i += (strlen(ch->name) - 1);
misc.c:				if(ch->sex == SEX_MALE)
misc.c:				else if(ch->sex == SEX_FEMALE)
misc.c:				if(ch->sex == SEX_MALE)                                                               
misc.c:				else if(ch->sex == SEX_FEMALE)                                                        
misc.c:				if(ch->sex == SEX_MALE)                                                               
misc.c:				else if(ch->sex == SEX_FEMALE)                                                        
misc.c:				point--;                                                                              
misc.c://	sprintf(buf,"number_percent -- Total: %ld | Number of rolls: %d | Average: %f | Deviation: %f\n\r", total, count, (float)total/(float)count, ((float)total/(float)count) - (float)50);
misc.c:	sprintf(buf,"number_range -- Total %ld | Number of rolls: %d | Average %f | Deviation %f | Occurances of Max %d (id20)\n\r",total,count,(float)total/(float)count,((float)total/(float)count) - (float)2.5,maxes);
misc.c:	for(lptr=speech->first_line; lptr; lptr = lptr->next)
misc.c:		if(lptr->number > max)
misc.c:			max = lptr->number;
misc.c:		for(lptr = speech->first_line; lptr; lptr = lptr->next)
misc.c:			if (!lptr->next)
misc.c:			if (lptr == speech->first_line)
misc.c:			if (lptr->number > lptr->next->number)
misc.c:				if (lptr->next->next)
misc.c:					lptr->next->next->prev = lptr;
misc.c:				lptr->next->prev = lptr->prev;
misc.c:					lptr->prev->next = lptr->next;                                                              
misc.c:				lptr->prev = lptr->next;                                                                        
misc.c:				hold = lptr->next->next;                                                                  
misc.c:				lptr->next->next = lptr;                                                                        
misc.c:				lptr->next = hold;                                                                        
misc.c:					speech->first_line = lptr->prev; 
misc.c:	nephilim->level = level +3;
misc.c:	nephilim->max_hit = ch->max_hit + dice(level,20);
misc.c:	nephilim->hit = nephilim->max_hit;
misc.c:	char_to_room(nephilim,ch->in_room);
misc.c:	nephilim->leader = ch;
misc.c:	SET_BIT(nephilim->affected_by,AFF_CHARM);
misc.c:	int i, dev=-1, totalfavor = 0;
misc.c:		totalfavor += victim->pcdata->devildata[i];
misc.c:	if (victim->pcdata->devildata[dev] != totalfavor)
misc.c:	if (victim->pcdata->devildata[dev] == 5)
misc.c:	victim->pcdata->devildata[dev]++;
misc.c:	if (ch->fighting) {
misc.c:		send_to_char("   chess move <coords-from> <coords-to>\n\r",ch);
misc.c:		send_to_char("   chess place <color> <piece-type> <coords>\n\r",ch);
misc.c:	for (board = ch->in_room->contents; board; board = board->next_content) {
misc.c:		if (board->pIndexData->vnum == OBJ_VNUM_CHESSBOARD) {
misc.c:				col_from = -1;
misc.c:				row_from = -1;
misc.c:				col_to = -1;
misc.c:				row_to = -1;
misc.c:			color = -1;
misc.c:			piece = -1;
misc.c:		if (piece != -1 && color == BLACK_PIECE)
misc.c:				col_to = -1;
misc.c:				row_to = -1;
misc.c:		if (piece != -1 && color != -1) {
misc.c:	send_to_char("   chess move <coords-from> <coords-to>\n\r",ch);
misc.c:	send_to_char("   chess place <color> <piece-type> <coords>\n\r",ch);
misc.c:	send_to_char("   +--------+--------+--------+--------+--------+--------+--------+--------+\n\r",ch);
misc.c:			piece = chessboard[j][7-i];
misc.c:		sprintf(buf," %d |",8-i);
misc.c:			piece = chessboard[j][7-i];
misc.c:		sprintf(buf," %d\n\r",8-i);
misc.c:			piece = chessboard[j][7-i];
misc.c:		send_to_char("   +--------+--------+--------+--------+--------+--------+--------+--------+\n\r",ch);
misc.c:	send_to_char("Michael Curran  - the player title collection and additional locations.\n\r",ch);
misc.c:	send_to_char("Ragnar Loenn    - the bulletin board.\n\r",ch);
misc.c:	send_to_char("Bill Wisner     - for being the first to successfully port the game,\n\r",ch);
misc.c:	send_to_char("Developed at: DIKU -- The Department of Computer Science\n\r",ch);
misc.c:		send_to_char("Anti-idle disabled.\n\r",ch);
misc.c:	af.duration = -1;
misc.c:	send_to_char("Anti-idle enabled.\n\r",ch);
moremagic.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
moremagic.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
moremagic.c:	if(is_affected(victim,gsn_enlarge) || victim->size>=SIZE_IMMENSE)
moremagic.c:	if(!IS_NPC(victim) && !trusts(ch,victim) && (!ch->fighting || !victim->fighting))
moremagic.c:	if(ch->in_room->sector_type==SECT_INSIDE)
moremagic.c:	if(ch->in_room->area->sky==SKY_CLEAR)
moremagic.c:	if(ch->in_room->area->sky==SKY_PCLOUDY)	
moremagic.c:	if(ch->in_room->area->sky==SKY_DRIZZLE)
moremagic.c:	if(ch->in_room->area->sky==SKY_TSTORM)
moremagic.c:		af.modifier	= -6;
moremagic.c:	chance-=(snlevel-ch->level)*2;
moremagic.c:        for ( paf = ch->affected; paf != NULL; paf = paf->next )
moremagic.c:		if(paf->type==sn)
moremagic.c:			return paf->level;
moremagic.c:return -1;
moremagic.c:	for(laf=victim->affected; laf != NULL; laf=laf->next)
moremagic.c:		if(IS_SET(laf->bitvector, AFF_SLEEP))
moremagic.c:	if (check_dispel(level,victim,laf->type))
moremagic.c:	af.duration = 4 + ch->level/5;
moremagic.c:	af.duration = 4 + ch->level/5;
moremagic.c:	af.duration = 4 + ch->level/5;
moremagic.c:	af.duration = 4 + ch->level/5;
moremagic.c:	af.duration = 4 + ch->level/5;
moremagic.c:	af.duration = 4 + ch->level/5;
moremagic.c:	old_room = ch->in_room;
moremagic.c:	if (ch->in_room != old_room) {
moremagic.c:		for (group = old_room->people; group != NULL; group = g_next)
moremagic.c:			g_next = group->next_in_room;
moremagic.c:			if (!is_same_group(group,ch) || (group->fighting != NULL) || group == ch)
moremagic.c:			char_to_room(group, ch->in_room);
moremagic.c:	ch->mana-=30;
moremagic.c:	victim->hit = UMIN( victim->hit + 200, victim->max_hit );
moremagic.c:	   victim->move -= dam / 2;
moremagic.c:   af.duration = ch->level*2;
moremagic.c:	if (!IS_SET(obj->extra_flags,ITEM_EVIL))
moremagic.c:	chance += level - obj->level;
moremagic.c:	if (obj->level >= MAX_LEVEL)
moremagic.c:		chance -= MAX_LEVEL;
moremagic.c:		REMOVE_BIT(obj->extra_flags, ITEM_EVIL);
moremagic.c:	if(saves_spell(level-5,victim,DAM_NEGATIVE))
moremagic.c:	check_waterbreath(ch, ch->in_room);
mprog.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   				   *
mprog.c:    RS.Queue.AddToQueue(inc, 6, sprintf,buf, (char*)"%s tells you '%s%s%s'",  mob->short_descr,  get_char_color(ch, "tells"),  arg,  END_COLOR(ch));
mprog.c:	RS.Queue.AddToQueue(inc, 6, sprintf,buf, (char*)"%s says '%s%s%s'",  mob->short_descr,  get_char_color(ch, "speech"),  arg,  END_COLOR(ch));
mprog.c:	RS.Queue.AddToQueue(inc, 4, sprintf, buf, (char*)"%s %s", mob->short_descr,  arg);
mprog.c:    RS.Queue.AddToQueue(inc, 6, sprintf,buf, (char*)"%s says '%s%s%s'",  mob->short_descr,  get_char_color(ch, "speech"),  arg,  END_COLOR(ch));
mprog.c:	RS.Queue.AddToQueue(inc, 2, obj_to_room, obj, mob->in_room);
mprog.c:		RS.Queue.AddToQueue(inc, 6, sprintf,buf, (char*)"%s says '%s%s%s'",  mob->short_descr,  get_char_color(ch, "speech"),  arg,  END_COLOR(ch));
mprog.c:		mobindex->mprogs->bribe_prog = NULL;
mprog.c:		free_pstring(mobindex->mprogs->bribe_name);
mprog.c:	    REMOVE_BIT(mobindex->progtypes, MPROG_BRIBE);
mprog.c:		mobindex->mprogs->entry_prog = NULL;
mprog.c:		free_pstring(mobindex->mprogs->entry_name);
mprog.c:	    REMOVE_BIT(mobindex->progtypes, MPROG_ENTRY);
mprog.c:		mobindex->mprogs->greet_prog = NULL;
mprog.c:		free_pstring(mobindex->mprogs->greet_name);
mprog.c:		mobindex->mprogs->greet_name = palloc_string(name);
mprog.c:       	REMOVE_BIT(mobindex->progtypes, MPROG_GREET);
mprog.c:		mobindex->mprogs->fight_prog = NULL;
mprog.c:		free_pstring(mobindex->mprogs->fight_name);
mprog.c:		REMOVE_BIT(mobindex->progtypes, MPROG_FIGHT);
mprog.c:		mobindex->mprogs->death_prog = NULL;
mprog.c:		free_pstring(mobindex->mprogs->death_name);
mprog.c:       	REMOVE_BIT(mobindex->progtypes, MPROG_DEATH);
mprog.c:		mobindex->mprogs->beat_prog = NULL;
mprog.c:		free_pstring(mobindex->mprogs->beat_name);
mprog.c:		REMOVE_BIT(mobindex->progtypes, MPROG_BEAT);
mprog.c:		mobindex->mprogs->pulse_prog = NULL;
mprog.c:		free_pstring(mobindex->mprogs->pulse_name);
mprog.c:       	REMOVE_BIT(mobindex->progtypes, MPROG_PULSE);
mprog.c:		mobindex->mprogs->speech_prog = NULL;
mprog.c:		free_pstring(mobindex->mprogs->speech_name);
mprog.c:		REMOVE_BIT(mobindex->progtypes, MPROG_SPEECH);
mprog.c:		mobindex->mprogs->give_prog = NULL;
mprog.c:       		free_pstring(mobindex->mprogs->give_name);
mprog.c:	       	REMOVE_BIT(mobindex->progtypes, MPROG_GIVE);
mprog.c:		mobindex->mprogs->attack_prog = NULL;
mprog.c:		free_pstring(mobindex->mprogs->attack_name);
mprog.c:		REMOVE_BIT(mobindex->progtypes, MPROG_ATTACK);
mprog.c:		mobindex->mprogs->aggress_prog = NULL;
mprog.c:		free_pstring(mobindex->mprogs->aggress_name);
mprog.c:		REMOVE_BIT(mobindex->progtypes, MPROG_AGGRESS);
mprog.c:		mobindex->mprogs->move_prog = NULL;
mprog.c:		free_pstring(mobindex->mprogs->move_name);
mprog.c:		REMOVE_BIT(mobindex->progtypes, MPROG_MOVE);
mprog.c:		return bug("Load_improgs: 'M': Function not found for vnum %d",mobindex->vnum);
mprog.c:		mobindex->mprogs->bribe_prog = (MPROG_FUN_BRIBE *)mprog_table[i].function;
mprog.c:		free_pstring(mobindex->mprogs->bribe_name);
mprog.c:		mobindex->mprogs->bribe_name = palloc_string(name);
mprog.c:	       	SET_BIT(mobindex->progtypes, MPROG_BRIBE);
mprog.c:		mobindex->mprogs->entry_prog = (MPROG_FUN_ENTRY *)mprog_table[i].function;
mprog.c:		free_pstring(mobindex->mprogs->entry_name);
mprog.c:		mobindex->mprogs->entry_name = palloc_string(name);
mprog.c:	       	SET_BIT(mobindex->progtypes, MPROG_ENTRY);
mprog.c:		mobindex->mprogs->greet_prog = (MPROG_FUN_GREET *)mprog_table[i].function;
mprog.c:		free_pstring(mobindex->mprogs->greet_name);
mprog.c:		mobindex->mprogs->greet_name = palloc_string(name);
mprog.c:       		SET_BIT(mobindex->progtypes, MPROG_GREET);
mprog.c:		mobindex->mprogs->fight_prog = (MPROG_FUN_FIGHT *)mprog_table[i].function;
mprog.c:		free_pstring(mobindex->mprogs->fight_name);
mprog.c:		mobindex->mprogs->fight_name = palloc_string(name);
mprog.c:		SET_BIT(mobindex->progtypes, MPROG_FIGHT);
mprog.c:		mobindex->mprogs->death_prog = (MPROG_FUN_DEATH *)mprog_table[i].function;
mprog.c:		free_pstring(mobindex->mprogs->death_name);
mprog.c:		mobindex->mprogs->death_name = palloc_string(name);
mprog.c:       		SET_BIT(mobindex->progtypes, MPROG_DEATH);
mprog.c:		mobindex->mprogs->beat_prog = (MPROG_FUN_BEAT *)mprog_table[i].function;
mprog.c:		free_pstring(mobindex->mprogs->beat_name);
mprog.c:		mobindex->mprogs->beat_name = palloc_string(name);
mprog.c:		SET_BIT(mobindex->progtypes, MPROG_BEAT);
mprog.c:		mobindex->mprogs->pulse_prog = (MPROG_FUN_PULSE *)mprog_table[i].function;
mprog.c:		free_pstring(mobindex->mprogs->pulse_name);
mprog.c:		mobindex->mprogs->pulse_name = palloc_string(name);
mprog.c:       		SET_BIT(mobindex->progtypes, MPROG_PULSE);
mprog.c:		mobindex->mprogs->speech_prog = (MPROG_FUN_SPEECH *)mprog_table[i].function;
mprog.c:		free_pstring(mobindex->mprogs->speech_name);
mprog.c:		mobindex->mprogs->speech_name = palloc_string(name);
mprog.c:		SET_BIT(mobindex->progtypes, MPROG_SPEECH);
mprog.c:		mobindex->mprogs->give_prog = (MPROG_FUN_GIVE *)mprog_table[i].function;
mprog.c:       		free_pstring(mobindex->mprogs->give_name);
mprog.c:		mobindex->mprogs->give_name = palloc_string(name);	
mprog.c:	       	SET_BIT(mobindex->progtypes, MPROG_GIVE);
mprog.c:		mobindex->mprogs->attack_prog = (MPROG_FUN_ATTACK *)mprog_table[i].function;
mprog.c:		free_pstring(mobindex->mprogs->attack_name);
mprog.c:		mobindex->mprogs->attack_name = palloc_string(name);
mprog.c:		SET_BIT(mobindex->progtypes, MPROG_ATTACK);
mprog.c:		mobindex->mprogs->aggress_prog = (MPROG_FUN_AGGRESS *)mprog_table[i].function;
mprog.c:		free_pstring(mobindex->mprogs->aggress_name);
mprog.c:		mobindex->mprogs->aggress_name = palloc_string(name);
mprog.c:		SET_BIT(mobindex->progtypes, MPROG_AGGRESS);
mprog.c:		mobindex->mprogs->move_prog = (MPROG_FUN_MOVE *)mprog_table[i].function;
mprog.c:		free_pstring(mobindex->mprogs->move_name);
mprog.c:		mobindex->mprogs->move_name = palloc_string(name);
mprog.c:		SET_BIT(mobindex->progtypes, MPROG_MOVE);
mprog.c:   bug( "Load_improgs: 'M': invalid program type for vnum %d",mobindex->vnum);
mprog.c:      do_murder(mob, ch->name);
mprog.c:		&& (obj->pIndexData->vnum == 12219
mprog.c:		|| obj->pIndexData->vnum == 21800))
mprog.c:	if(!found && str_cmp(race_table[ch->race].name, "duergar")) {
mprog.c:		do_murder(mob, ch->name);
mprog.c:	int dir_next = -1;
mprog.c:	if (mob->fighting)
mprog.c:	if (!mob->in_room)
mprog.c:	switch(mob->in_room->vnum) {
mprog.c:	for (vch = mob->in_room->people; vch; vch = vch->next_in_room) {
mprog.c:			&& robes->pIndexData->vnum == 21800)
mprog.c:		do_murder(mob,vch->name);
mprog.c:	if (mob->in_room->exit[dir_next]->u1.to_room->people)
mprog.c:		act("You hear the heavy footsteps of an approaching patrol echo through the caves.",mob->in_room->exit[dir_next]->u1.to_room->people,0,0,TO_ALL);
mprog.c:	if (mob->fighting || IS_IMMORTAL(ch))
mprog.c:		sprintf(buf,"How dare you enter this place of holiness, %s?  You shall suffer the consequences!",ch->name);
mprog.c:		do_murder(mob,ch->name);
mprog.c:			ch->name);
mprog.c:		execute_speech (ch, mob, mob->pIndexData->speech);
mprog.c:	  ch->gold = UMAX(0, (ch->gold + (2*amount)));
mprog.c:      if (ch->gold < amount)
mprog.c:	      ch->gold -= amount;
mprog.c:	      ch->gold += amount;
mprog.c:  if (ch->ghost > 0)
mprog.c:      do_slay(mob, ch->name);
mprog.c:  do_murder(mob, ch->name);
mprog.c:		act("$n brings $s mace around in a powerful bone-shattering blow, but misses $N.",mob,0,ch,TO_NOTVICT);
mprog.c:		act("$n brings $s mace around in a powerful bone-shattering blow, but misses you.",mob,0,ch,TO_VICT);
mprog.c:	act("$n brings $s mace around in a powerful bone-shattering blow, striking $N.",mob,0,ch,TO_NOTVICT);
mprog.c:	act("$n brings $s mace around in a powerful bone-shattering blow, striking you.",mob,0,ch,TO_VICT);
mprog.c:	af.modifier 	= -6;
mprog.c:	af.level	= mob->level;
mprog.c:	if (!mob->in_room)
mprog.c:	if (mob->fighting)
mprog.c:	obj_to_room(egg,mob->in_room);
mprog.c:	egg_vnum = obj->pIndexData->vnum;
mprog.c:	if(IS_NPC(ch) || ch->invis_level>LEVEL_HERO-1)
mprog.c:	if(mob->cabal==ch->cabal)
mprog.c:		do_say(mob,cabal_messages[ch->cabal].entrygreeting);
mprog.c:    CHAR_DATA *victim=elemental->hunting;
mprog.c:    if(!victim || !elemental->in_room || !victim->in_room || victim->ghost>0)
mprog.c:	if(mob->master && victim->ghost>0) {
mprog.c:		sprintf(buf,"%s I have taken the soul of %s. Your debt will one day be collected.",mob->master->name,victim->name);
mprog.c:    if(elemental->fighting)
mprog.c:    if(mob->position!=POS_STANDING)
mprog.c:        mob->position=POS_STANDING;
mprog.c:    if(victim->in_room->vnum!=elemental->in_room->vnum)
mprog.c:        char_to_room(elemental,victim->in_room);
mprog.c:		if(attacker->fighting == mob)
mprog.c:	do_murder(demon, attacker->name);
mprog.c:		victim->position = POS_RESTING;
mprog.c:	if ((room = mob->in_room) == NULL)
mprog.c:	if (mob->fighting)
mprog.c:	if (mob->position <= POS_RESTING)
mprog.c:	if (room->vnum < 9141 || room->vnum > 9146)
mprog.c:	if (!room->exit[DIR_UP] || ((surface = room->exit[DIR_UP]->u1.to_room) == NULL))
mprog.c:		if (mob->in_room != mob->home_room)
mprog.c:			walk_to_room(mob,mob->home_room);
mprog.c:		for (adjmob = other->people; adjmob; adjmob = adjmob_next) {
mprog.c:			adjmob_next = adjmob->next_in_room;
mprog.c:			if (adjmob->pIndexData->vnum != 9011)
mprog.c:			if (adjmob->fighting)
mprog.c:			if (adjmob->in_room == room)
mprog.c:	if (!mob->in_room || mob->pIndexData->vnum != 9010)
mprog.c:	if (mob->fighting || mob->position < POS_RESTING)
mprog.c:	if (sun == SUN_SET && mob->in_room->vnum == 9121) {
mprog.c:	} else if (sun == SUN_RISE && mob->in_room->vnum == 2) {
mprog.c:	if(mob->fighting || mob->position > POS_RESTING)
mprog.c:	if(mob->in_room->vnum != 105)
mprog.c:	if(attacker->ghost)
mprog.c:		attacker->ghost=0;
mprog.c:	sprintf(buf,"Intruder! Intruder! %s is raiding the cabal!",attacker->true_name);
mprog.c:	if(ch->cabal == mob->cabal)
mprog.c:	sprintf(buf,"Intruder! Intruder! %s is raiding the cabal!",ch->true_name);
mprog.c:	if(ch->ghost>0)
mprog.c:	if ((cabalguardian = get_cabal_guardian(mob->cabal)) != NULL)
mprog.c:		for (obj = cabalguardian->carrying; obj != NULL; obj = obj_next)
mprog.c:			obj_next = obj->next_content;
mprog.c:			if (obj->pIndexData->cabal != cabalguardian->cabal)
mprog.c:				for (vch = killer->in_room->people; vch != NULL; vch = vch->next_in_room)
mprog.c:						if (obj->pIndexData->cabal == vch->cabal) {
mprog.c:				if (present && (othercabalguardian = get_cabal_guardian(obj->pIndexData->cabal)) != NULL)
mprog.c:					mob->short_descr,obj->short_descr,othercabalguardian->short_descr);
mprog.c:					cabal_shudder(obj->pIndexData->cabal, FALSE);
mprog.c:   	for (obj = mob->carrying; obj != NULL; obj = obj_next)
mprog.c:		obj_next = obj->next_content;
mprog.c:        if(obj->pIndexData->cabal!=mob->cabal)
mprog.c:        	cabalguardian = get_cabal_guardian(obj->pIndexData->cabal);
mprog.c:				mob->short_descr,obj->short_descr,cabalguardian->short_descr);
mprog.c:                cabal_shudder(obj->pIndexData->cabal, FALSE);
mprog.c:		if(obj->pIndexData->cabal==mob->cabal || !found)
mprog.c:			obj->timer=21;
mprog.c:	if(!mob->in_room->area->nplayer || number_percent()<=90)
mprog.c:    	for ( d = descriptor_list; d != NULL; d = d->next )
mprog.c:		if ( d->connected == CON_PLAYING
mprog.c:		&&   d->character->in_room != NULL
mprog.c:		&&   d->character->in_room->area == mob->in_room->area
mprog.c:		&&   IS_EVIL(d->character))
mprog.c:			ch = d->character;
mprog.c:			char_to_room(mist, ch->in_room);
mprog.c:	ch = mob->leader;
mprog.c:	for(vch=mob->in_room->people;vch!=NULL;vch=vch_next)	
mprog.c:		vch_next = vch->next_in_room;	
mprog.c:		damage_new(ch,vch,dice(mob->level,6),TYPE_UNDEFINED,DAM_PIERCE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the shattered glass*");
mprog.c:			damage_new(ch,vch,dice(mob->level,2),TYPE_UNDEFINED,DAM_PIERCE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the shattered glass*");
mprog.c:			damage_new(ch,vch,dice(mob->level,2),TYPE_UNDEFINED,DAM_PIERCE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the shattered glass*");
mprog.c:			damage_new(ch,vch,dice(mob->level,2),TYPE_UNDEFINED,DAM_PIERCE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the shattered glass*");
mprog.c:			damage_new(ch,vch,dice(mob->level,2),TYPE_UNDEFINED,DAM_PIERCE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the shattered glass*");
mprog.c:	for(vch = mob->in_room->people; vch; vch = vch->next_in_room)
mprog.c:	SHOP_DATA *pShop = mob->pIndexData->pShop;
mprog.c:	ROOM_INDEX_DATA *room = mob->in_room;
mprog.c:	if(pShop->close_hour == pShop->open_hour || !(exit = mob->in_room->exit[pShop->direction]) || !exit->u1.to_room)
mprog.c:	if(time_info.hour == pShop->open_hour && mob->exp!=20)
mprog.c:		REMOVE_BIT(exit->exit_info, EX_LOCKED);
mprog.c:		REMOVE_BIT(exit->exit_info, EX_CLOSED);
mprog.c:		char_to_room(mob,exit->u1.to_room);
mprog.c:			mob,0,direction_table[reverse_d(pShop->direction)].name,TO_ROOM);
mprog.c:		if((exit = exit->u1.to_room->exit[reverse_d(pShop->direction)]))
mprog.c:			REMOVE_BIT(exit->exit_info, EX_LOCKED);
mprog.c:			REMOVE_BIT(exit->exit_info, EX_CLOSED);
mprog.c:		mob->exp = 20;
mprog.c:	if(time_info.hour < pShop->close_hour && time_info.hour >= pShop->open_hour)
mprog.c:	if(time_info.hour == pShop->close_hour && mob->exp != 10)
mprog.c:		char_to_room(mob,exit->u1.to_room);
mprog.c:			mob,0,direction_table[reverse_d(pShop->direction)].name,TO_ROOM);
mprog.c:		if (IS_SET(exit->exit_info,EX_ISDOOR)) {
mprog.c:			SET_BIT(exit->exit_info,EX_LOCKED);
mprog.c:			SET_BIT(exit->exit_info,EX_CLOSED);
mprog.c:		if((extwo = exit->u1.to_room->exit[reverse_d(pShop->direction)])) {
mprog.c:			if (IS_SET(extwo->exit_info, EX_ISDOOR)) {
mprog.c:				SET_BIT(extwo->exit_info, EX_LOCKED);
mprog.c:				SET_BIT(extwo->exit_info, EX_CLOSED);
mprog.c:	for(vch = mob->in_room->people; vch; vch = vch_next)
mprog.c:		vch_next = vch->next_in_room;
mprog.c:		if(IS_NPC(vch) && IS_SET(vch->act,ACT_SENTINEL))
mprog.c:		char_to_room(vch,exit->u1.to_room);
mprog.c:		act("$t tosses $n out of $s shop.",vch,mob->short_descr,0,TO_ROOM);
mprog.c:		if(mob->fighting)
mprog.c:			stop_fighting(mob,mob->fighting);
mprog.c:	mob->exp = 10;
mprog.c:	if(ch->pause)
mprog.c:	CHAR_DATA *master = mob->leader;
mprog.c:	sprintf(buf,"A skull-sentinel whispers to you '%sMaster, %s has arrived at my location.%s'",get_char_color(ch,"lightred"),palloc_string(ch->name),END_COLOR(ch));
mprog.c:        if(mob->leader == NULL) {
mprog.c:	AFFECT_DATA *af = affect_find(mob->affected,gsn_lesser_demon);
mprog.c:	if (mob->pIndexData->vnum == MOB_VNUM_BARBAS && attacker != af->owner && af->owner) {
mprog.c:			af->owner->name);
mprog.c:		af->owner->pcdata->lesserdata[LESSER_BARBAS] = FAVOR_NONE;
mprog.c:	if (mob->pIndexData->vnum == MOB_VNUM_BARBAS)
mprog.c:	if (attacker == af->owner) {
mprog.c:		switch (mob->pIndexData->vnum) {
mprog.c:				af->owner->pcdata->lesserdata[LESSER_BARBAS] = FAVOR_FAILED;
mprog.c:				af->owner->pcdata->lesserdata[LESSER_FURCAS] = FAVOR_FAILED;
mprog.c:				af->owner->pcdata->lesserdata[LESSER_MALAPHAR] = FAVOR_FAILED;
mprog.c:				af->owner->pcdata->lesserdata[LESSER_AAMON] = FAVOR_FAILED;
mprog.c:				af->owner->pcdata->lesserdata[LESSER_IPOS] = FAVOR_FAILED;
mprog.c:	if (attacker != af->owner) {
mprog.c:		switch (mob->pIndexData->vnum) {
mprog.c:				af->owner->pcdata->lesserdata[LESSER_BARBAS] = FAVOR_NONE;
mprog.c:				af->owner->pcdata->lesserdata[LESSER_FURCAS] = FAVOR_NONE;
mprog.c:				af->owner->pcdata->lesserdata[LESSER_MALAPHAR] = FAVOR_NONE;
mprog.c:				af->owner->pcdata->lesserdata[LESSER_AAMON] = FAVOR_NONE;
mprog.c:				af->owner->pcdata->lesserdata[LESSER_IPOS] = FAVOR_NONE;
mprog.c:		sprintf(buf,"%s, you fool, you'll pay for this!",attacker->name);
mprog.c:			af->owner->name);
mprog.c:	CHAR_DATA *ch = mob->last_fought;
mprog.c:	ROOM_INDEX_DATA *old_room = mob->in_room;
mprog.c:	if (mob->fighting)
mprog.c:	if (ch->ghost > 0) {
mprog.c:		sprintf(buf,"%s I'll be takin' me leave now, weakling.",ch->name);
mprog.c:	if (ch->in_room->area == mob->in_room->area && ch->in_room != mob->in_room) {
mprog.c:	if (ch->in_room != mob->in_room) {
mprog.c:		if (mob->in_room == old_room && number_range(1,30) == 1) {
mprog.c:			char_to_room(mob, ch->in_room);
mprog.c:	af = affect_find(mob->affected,gsn_lesser_demon);
mprog.c:	if (killer != af->owner)
mprog.c:	killer->pcdata->lesserdata[LESSER_BARBAS] = FAVOR_GRANTED;
mprog.c:	killer->pcdata->learned[skill_lookup("consume")] = 1;
mprog.c:	AFFECT_DATA *af = affect_find(mob->affected,gsn_lesser_demon);
mprog.c:	if (ch != af->owner)
mprog.c:		ch->pcdata->lesserdata[LESSER_AAMON] = FAVOR_GRANTED;
mprog.c:		ch->pcdata->learned[skill_lookup("dark insight")] = 1;
mprog.c:	af->modifier++;
mprog.c:	switch(af->modifier) {
mprog.c:			ch->pcdata->lesserdata[LESSER_AAMON] = FAVOR_FAILED;
mprog.c:	AFFECT_DATA *af = affect_find(mob->affected,gsn_lesser_demon);
mprog.c:	if (obj->cost < 5000 && obj->pIndexData->limtotal > 8) {
mprog.c:		ch->pcdata->lesserdata[LESSER_MALAPHAR] = FAVOR_FAILED;
mprog.c:	ch->pcdata->lesserdata[LESSER_MALAPHAR] = FAVOR_GRANTED;
mprog.c:	ch->pcdata->learned[skill_lookup("steal")] = 1;
mprog.c:	AFFECT_DATA	*af = affect_find(mob->affected,gsn_lesser_demon);
mprog.c:		ch->pcdata->lesserdata[LESSER_MALAPHAR] = FAVOR_FAILED;
mprog.c:	ch->pcdata->lesserdata[LESSER_MALAPHAR] = FAVOR_GRANTED;
mprog.c:	ch->pcdata->learned[skill_lookup("steal")] = 1;
mprog.c:	AFFECT_DATA *af = affect_find(mob->affected,gsn_lesser_demon);
mprog.c:	if (ch != af->owner)
mprog.c:	ch->pcdata->lesserdata[LESSER_FURCAS] = FAVOR_GRANTED;
mprog.c:	ch->pcdata->learned[skill_lookup("darksight")] = 1;
mprog.c:	AFFECT_DATA *af = affect_find(mob->affected,gsn_lesser_demon);
mprog.c:	if (!af->owner)
mprog.c:	if(ch != af->owner)
mprog.c:	if(af->modifier > 4)
mprog.c:	mob->speechbuf[af->modifier] = palloc_string(speech);
mprog.c:	af->modifier++;
mprog.c:	if (af->modifier == 4) {
mprog.c:		act("Ipos recites: $t",mob,mob->speechbuf[0],0,TO_ROOM);
mprog.c:		act("              $t",mob,mob->speechbuf[1],0,TO_ROOM);
mprog.c:		act("              $t",mob,mob->speechbuf[2],0,TO_ROOM);
mprog.c:		act("              $t",mob,mob->speechbuf[3],0,TO_ROOM);
mprog.c:		do_note(mob,"to anti-paladin");
mprog.c:		do_note(mob,"+ Greetings, terrifying and horrible anti-paladins of the realm!");
mprog.c:		sprintf(buf,"+ %s has something he'd like to share with you all, and who am I to", ch->name);
mprog.c:			sprintf(buf,"+ %s",mob->speechbuf[i]);
mprog.c:		ch->pcdata->lesserdata[LESSER_IPOS] = FAVOR_GRANTED;
mprog.c:		ch->pcdata->learned[skill_lookup("taunt")] = 1;
mprog.c:			free_pstring(mob->speechbuf[i]);
mprog.c:	AFFECT_DATA *af = affect_find(mob->affected,gsn_greater_demon);
mprog.c:	if (!af || !af->owner)
mprog.c:	if (ch != af->owner)
mprog.c:		sprintf(buf,"'siphon' %s",ch->name);
mprog.c:		ch->pcdata->greaterdata[GREATER_OZE] = FAVOR_GRANTED;
mprog.c:		ch->pcdata->learned[skill_lookup("leech")] = 1;
mprog.c:		ch->pcdata->perm_hit -= 70;
mprog.c:		ch->max_hit -= 70;
mprog.c:		ch->hit = ch->max_hit;
mprog.c:		sprintf(buf,"The abyss will not forget this treachery, %s.",ch->name);
mprog.c:		ch->pcdata->greaterdata[GREATER_OZE] = FAVOR_FAILED;
mprog.c:	AFFECT_DATA *paf = affect_find(mob->affected,gsn_greater_demon), af;
mprog.c:	if (!paf || !paf->owner)
mprog.c:	if (ch != paf->owner)
mprog.c:		RS.Queue.AddToQueue(1, 3, sprintf, buf, (char*)"%s You may yet live to regret your rash decision.  Doubtless the seeds of realization sprout within you now.", ch->name);
mprog.c:		ch->pcdata->greaterdata[GREATER_GAMYGYN] = FAVOR_FAILED;
mprog.c:	AFFECT_DATA *paf = affect_find(mob->affected,gsn_greater_demon), af;
mprog.c:	if (!paf || !paf->owner)
mprog.c:	if (ch != paf->owner)
mprog.c:		RS.Queue.AddToQueue(1, 3, sprintf,buf, (char*)"Very well.  I shall watch over you.  I require the corpse of another anti-paladin to warm my feet,  %s... I trust you shall not disappoint.", ch->name);
mprog.c:		ch->pcdata->greaterdata[GREATER_OROBAS] = FAVOR_FAILED;
mprog.c:	AFFECT_DATA *paf = affect_find(mob->affected,gsn_greater_demon);
mprog.c:	if (!paf || !paf->owner)
mprog.c:	if (ch != paf->owner)
mprog.c:		sprintf(buf,"A wise choice, %s.",ch->name);
mprog.c:		ch->pcdata->greaterdata[GREATER_GERYON] = GERYON_EYE;
mprog.c:		sprintf(buf,"A wise choice, %s.",ch->name);
mprog.c:		ch->pcdata->greaterdata[GREATER_GERYON] = GERYON_FINGER;
mprog.c:	AFFECT_DATA *paf = affect_find(mob->affected,gsn_greater_demon);
mprog.c:	if (!paf || !paf->owner)
mprog.c:	if (ch != paf->owner)
mprog.c:		ch->pcdata->greaterdata[GREATER_CIMERIES] = CIMERIES_EAR;
mprog.c:		ch->pcdata->beauty = UMAX(1,ch->pcdata->beauty - 4);
mprog.c:		ch->pcdata->greaterdata[GREATER_CIMERIES] = CIMERIES_NOSE;
mprog.c:		ch->pcdata->beauty = UMAX(1,ch->pcdata->beauty - 4);
mprog.c:	if(number_percent() != 1 || mob->position != POS_STANDING)
mprog.c:		spell_faerie_fog( skill_lookup("faerie fog"), mob->level, mob, NULL, TAR_IGNORE);
mprog.c:	spell_faerie_fog(skill_lookup("faerie fog"),mob->level,mob,NULL,TAR_IGNORE);
mprog.c:	if(number_percent() > 40 || mob->position != POS_STANDING)
mprog.c:	for(victim = mob->in_room->people; victim; victim = victim->next_in_room) {
mprog.c:		|| ((mob->master) && ((victim == mob->master)
mprog.c:		|| is_safe_new(mob->master,victim,FALSE)))
mprog.c:		for(steal = victim->carrying; steal; steal = steal->next_content) {
mprog.c:			if(steal->wear_loc == WEAR_NONE && can_see_obj(mob,steal))  {
mprog.c:	CHAR_DATA *ch=mob->master;
mprog.c:	if(mob->fighting == NULL)
mprog.c:			spell_energy_drain(skill_lookup("energy drain"),mob->level,mob,victim,TAR_CHAR_OFFENSIVE);
mprog.c:			spell_vampiric_touch(skill_lookup("vampiric touch"),mob->level,mob,victim,TAR_CHAR_OFFENSIVE);
mprog.c:			        for (vch = mob->in_room->people; vch != NULL; vch = vch_next)
mprog.c:       				 vch_next = vch->next_in_room;
mprog.c:       				 if (ch->cabal>0 && ch->cabal==vch->cabal)
mprog.c:        			if (is_safe(ch,vch) && vch->fighting!=NULL && vch->fighting!=ch)
mprog.c:				spell_iceball(skill_lookup("iceball"),mob->level,mob,vch,TAR_IGNORE);
mprog.c:	if(ch != mob->master) {
mprog.c:	if(obj->item_type != ITEM_WEAPON) {
mprog.c:		obj_to_room(obj,mob->in_room);
mprog.c:	switch(obj->value[0]) {
mprog.c:	if((mob->hit*100/mob->max_hit) < 75 && !is_affected(mob, gsn_gking))
mprog.c:		char_to_room(gar1, mob->in_room);
mprog.c:		char_to_room(gar2, mob->in_room);
mprog.c:		do_murder(gar1, victim->name);
mprog.c:		do_murder(gar2, victim->name);
mprog.c:	if ((sun == SUN_RISE || sun == SUN_LIGHT) && number_percent() < 30 && mob->fighting == NULL)
mprog.c:	if (sun == SUN_DARK && number_percent() < 30 && mob->fighting == NULL)
mprog.c:	for(extract = mob->in_room->people; extract != NULL; extract = extract->next_in_room) {
mprog.c:		if(IS_NPC(extract) && extract->pIndexData->vnum == 2499)
mprog.c:	af.duration = -1;
mprog.c:	ROOM_INDEX_DATA *room2 = mob->in_room;
mprog.c:	if(!room->people && is_affected(mob,gsn_bash)) {
mprog.c:	for (vch = room->people; vch; vch = vch_next) {
mprog.c:		vch_next = vch->next_in_room;
mprog.c:			for(paf = mob->affected; paf; paf = paf->next) {
mprog.c:				if (paf->type == gsn_bash && paf->owner == vch) {
mprog.c:			paf->modifier--;
mprog.c:			if(paf->modifier == 0) {
mprog.c:			af.duration = -1;
mprog.c:	af.duration = -1;
mprog.c:	AFFECT_DATA *af=affect_find(ch->affected,gsn_bash);
mprog.c:	if(af->modifier == 0 && agrees(ch,speech) == REPLY_YES) {
mprog.c:		af->modifier = 1;
mprog.c:	if(af->modifier == 1) {
mprog.c:		af->modifier = 2);
mprog.c:	if(af->modifier == 2 && agrees(ch,speech) == REPLY_YES) {
mprog.c:		af->modifier = 3;
mprog.c:	if(af->modifier == 2 && agrees(ch,speech) == REPLY_NO) {
mprog.c:	if(af->modifier == 1) {
mprog.c:	CHAR_DATA *ch = mob->last_fought;
mprog.c:	switch(mob->pIndexData->vnum)
mprog.c:		mob->last_fought = check_sector( min, max );                                                            
mprog.c:		if(mob->last_fought != NULL)
mprog.c:			ch = mob->last_fought;
mprog.c:			mob->last_fought = NULL;
mprog.c:			mob->tracktimer = 0;
mprog.c:		mob->last_fought = NULL;
mprog.c:		mob->tracktimer = 0;
mprog.c:	if(mob->fighting)
mprog.c:	if(ch->ghost > 0)
mprog.c:		mob->last_fought = NULL;
mprog.c:		mob->tracktimer = 0;
mprog.c:		mob->last_fought = NULL;
mprog.c:		mob->tracktimer = 0;
mprog.c:	if (ch->in_room == mob->in_room)
mprog.c:		if(mob->pIndexData->attack_yell)
mprog.c:			sprintf(buf,"%s", act_msg(mob->pIndexData->attack_yell, ch));
mprog.c:			sprintf(buf,"%s, now you die!", ch->name);
mprog.c:		multi_hit(mob,mob->last_fought,TYPE_UNDEFINED);
mprog.c:			for( tch = pRoom->people; tch != NULL; tch = tch->next_in_room )
mprog.c:			for( ch = pRoom->people; ch != NULL; ch = ch->next_in_room )
mprog.c:	if(!can_see(mob,mob->last_fought) || 
mprog.c:			mob->last_fought->ghost > 0 ||
mprog.c:	if(mob->in_room != mob->last_fought->in_room)
mprog.c:		sprintf(store,"Halt, %s, you murderous scum!  You will bleed from there to the gates!", mob->last_fought->name);
mprog.c:	mob->tracktimer = 12;
mprog.c:	for(obj=mob->in_room->contents; obj != NULL; obj=obj_next) {
mprog.c:		obj_next = obj->next_content;
mprog.c:		if(obj->pIndexData->vnum == 2473)
mprog.c:             > (obj->value[0]) || is_affected(mob,gsn_bash)) {
mprog.c:	if(ch->level != 1)
mprog.c:	if(ch->position == POS_SLEEPING)
mprog.c:		ch->position = POS_RESTING;
mprog.c:	if(!str_cmp(race_table[ch->race].name,"duergar"))
mprog.c:			return("coal-faced dirtbag");
mprog.c:			return("brush-bearded mud eater");
mprog.c:	else if(!str_cmp(race_table[ch->race].name,"dwarf"))
mprog.c:			return("stumpy scump-head");
mprog.c:			return("bearded rock-head");
mprog.c:			return("ugly half-pint ball of scump");
mprog.c:	else if(!str_cmp(race_table[ch->race].name,"elf"))
mprog.c:			return("pale-faced tenderfoot");
mprog.c:			return("lanky-limbed pile of scump");
mprog.c:	else if(!str_cmp(race_table[ch->race].name,"drow"))
mprog.c:			return("slug-eating sneak");
mprog.c:	else if(!str_cmp(race_table[ch->race].name,"planar"))
mprog.c:	else if(!str_cmp(race_table[ch->race].name,"celestial"))
mprog.c:	else if(!str_cmp(race_table[ch->race].name,"abyss"))
mprog.c:	else if(!str_cmp(race_table[ch->race].name,"imp"))
mprog.c:	else if(!str_cmp(race_table[ch->race].name,"minotaur"))
mprog.c:			return("horn-faced bull brain");
mprog.c:	else if(!str_cmp(race_table[ch->race].name,"halfling"))
mprog.c:			return("knee-high bootlicker");
mprog.c:	else if(!str_cmp(race_table[ch->race].name,"sidhe"))
mprog.c:			return("tree-hugging faerie featherbrain");
mprog.c:			return("dimwitted scump-bucket");
mprog.c:	switch(mob->pIndexData->vnum)
mprog.c:			dragon_vnum = mob->pIndexData->vnum + 1;
mprog.c:			hydra_vnum = mob->pIndexData->vnum + 2;
mprog.c:	chance = ((float)ch->hit / (float)ch->max_hit) * 100 + 10;
mprog.c:		mob->last_fought = NULL;
mprog.c:		mob->tracktimer = 0;
mprog.c:		ch->position = POS_SLEEPING;
mprog.c:		switch(mob->pIndexData->vnum)
mprog.c:	if(!mob->in_room->area->nplayer || time_info.hour < mob->armor[2] || time_info.hour > mob->armor[3])
mprog.c:	if(!mob->timer)
mprog.c:		mob->timer = 1;
mprog.c:		mob->regen_rate = mob->level;   //interval in sec = mob level
mprog.c:	mob->regen_rate = UMAX(0,mob->regen_rate - 4); //(PULSE_MOBILE / PULSE_PER_SECOND), one mpulse per 4 sec
mprog.c:	if(mob->regen_rate)
mprog.c:	for(d = descriptor_list; d; d = d->next)
mprog.c:		if(d->connected != CON_PLAYING || !d->character->in_room || d->character->in_room->area != mob->in_room->area 
mprog.c:			   || d->character->in_room->vnum < mob->armor[0] || d->character->in_room->vnum > mob->armor[1])
mprog.c:			colorconv(buf,mob->short_descr,mob);
mprog.c:	mob->regen_rate = mob->level;
mprog.c:      	CHAR_DATA *victim = mob->fighting;
mprog.c:	(*skill_table[sn].spell_fun) ( sn, mob->level+1, mob, victim, TARGET_CHAR );
mprog.c:	CHAR_DATA *victim = mob->fighting;
mprog.c:	(*skill_table[sn].spell_fun) ( sn, mob->level+1, mob, victim, TARGET_CHAR);
mprog.c:	CHAR_DATA *victim = mob->fighting;
mprog.c:	(*skill_table[sn].spell_fun) ( sn, mob->level+1, mob, victim, TARGET_CHAR );
mprog.c:	CHAR_DATA *victim = mob->fighting;
mprog.c:	if(victim==NULL || victim->in_room != mob->in_room || number_percent() > 10)
mprog.c:		af.duration = mob->level/6;
mprog.c:		af.modifier = -mob->level/9;
mprog.c:		af.level = mob->level;
mprog.c:		af.duration = mob->level/6;
mprog.c:		af.modifier = -mob->level/6;
mprog.c:		af.level = mob->level;
mprog.c:	CHAR_DATA *victim = mob->fighting;
mprog.c:	if(victim==NULL ||  victim->in_room != mob->in_room || number_percent() > 15)
mprog.c:	CHAR_DATA *victim = mob->fighting;
mprog.c:	if(victim && victim->in_room == mob->in_room
mprog.c:		af.modifier = -mob->level/5;
mprog.c:		af.duration = mob->level/4;
mprog.c:		af.level = mob->level;
mprog.c:		af.owner = mob->leader;
mprog.c:		caf.level = mob->level;
mprog.c:		caf.owner = mob->leader;
mprog.c:		return (void)SET_BIT(mob->affected_by, AFF_NOSHOW);
mprog.c:		if(mob->fighting)
mprog.c:		SET_BIT(mob->affected_by, AFF_NOSHOW);
mprog.c:		REMOVE_BIT(mob->affected_by, AFF_NOSHOW);
mprog.c:		for(victim = mob->in_room->people; victim; victim = victim->next_in_room)
mprog.c:	else if(mob->fighting && mob->pIndexData->vnum == 3001)
mprog.c:		act("With a vicious clacking noise, $n sinks its razor-sharp pincers into $N!",mob,0,mob->fighting,TO_NOTVICT);
mprog.c:		act("With a vicious clacking noise, $n sinks its razor-sharp pincers into you!",mob,0,mob->fighting,TO_VICT);
mprog.c:		damage_new(mob,mob->fighting,dice(mob->fighting->level/3,3),TYPE_UNDEFINED,DAM_PIERCE,TRUE,
mprog.c:		af.level 	= (short)(mob->fighting->level / 2.5);
mprog.c:		af.duration 	= mob->fighting->level / 10;
mprog.c:		af.modifier = 0 - mob->fighting->level / 11;
mprog.c:		if(!is_affected(mob->fighting, gsn_lbite) && !is_affected(mob->fighting, gsn_abite))
mprog.c:		affect_to_char(mob->fighting, &af);
mprog.c:	for(owner = char_list; owner; owner = owner->next)
mprog.c:		if(IS_NPC(owner) && owner->pIndexData->vnum == 3002 && owner->hunting == ch)
mprog.c:	owner->hit += number_range(20,40);
mprog.c:	if(mob->fighting || IS_NPC(ch) || mob == ch || mob->hunting == ch || !can_see(mob,ch) || is_safe_new(mob,ch,FALSE))
mprog.c:	mob->hunting = ch;
mprog.c:	af.modifier	= -10;
mspec.c:		if(ch->in_room->vnum == 24537)
mspec.c:			if(ch->level < 4)
mspec.c:		if(obj->item_type == ITEM_CORPSE_NPC)
mspec.c:			sprintf(give,"venison %s", ch->true_name);
mspec.c:				free_pstring(venison->name);
mspec.c:				free_pstring(venison->short_descr);
mspec.c:				free_pstring(venison->description);
mspec.c:				venison->name = palloc_string("slice meat raw");
mspec.c:				venison->short_descr = palloc_string("a slice of raw meat");
mspec.c:				venison->description = palloc_string("A slice of raw meat is here.");
mspec.c:	free_pstring(mob->name);
mspec.c:	free_pstring(mob->short_descr);
mspec.c:	free_pstring(mob->long_descr);
mspec.c:	free_pstring(mob->description);
mspec.c:	switch(ch->alignment)
mspec.c:			mob->alignment = 1000;
mspec.c:			sprintf(ldesc,"A winged pixie flutters nervously around %s.\n\r", ch->name);
mspec.c:			mob->description = palloc_string("The wings of this tiny pixie are nearly translucent, yet surprisingly sturdy.  It hovers nervously around its master, flitting through the air.  ");
mspec.c:			mob->alignment = 0;
mspec.c:			sprintf(ldesc,"A mysterious efreet hovers near %s.\n\r", ch->name);
mspec.c:			mob->description = palloc_string("Obscured within a cloud of smoke that never seems to dissipate, this efreet effortlessly levitates near its master.  ");
mspec.c:			mob->alignment = -1000;
mspec.c:			sprintf(ldesc,"A mischievous imp lurks in the shadows near %s.\n\r", ch->name);
mspec.c:			mob->description = palloc_string("Sliding through the shadows and out on thick, leathery wings, your eye seems to slide past this imp unless you concentrate closely.  ");
mspec.c:	mob->name = palloc_string(namebuf);
mspec.c:	mob->short_descr = palloc_string(name);
mspec.c:	mob->long_descr = palloc_string(ldesc);
mspec.c:	mob->description[strlen(mob->description)-2] = '\n';
mspec.c:	mob->description[strlen(mob->description)-1] = '\r';
mspec.c:	char_to_room(mob, ch->in_room);
mspec.c:	if(ch->alignment == 1000)
mspec.c:		do_say(mob, "Greetings, friend.  I have been sent to help you become acclimated to the perils of these lands, for the good-hearted must always be wary.");
mspec.c:	else if(ch->alignment == -1000)
mspec.c:        mob->leader = ch;
mspec.c:	ch->pet = mob;
mspec.c:	sprintf(tbuf,"%s, I need to find food.",mob->short_descr);
mspec.c:	ch->wait = UMIN(ch->wait, 20);
mspec.c:	ch->leader->master = NULL;
mspec.c:	ch->master = ch->leader;
mspec.c:	CHAR_DATA *player = ch->leader;
mspec.c:	sprintf(cname,"%s", (RSTR)player->Class()->name);
mspec.c:	ROOM_INDEX_DATA *room = get_room_index(vnum), *oldroom = ch->in_room;
mspec.c:	if(ch->in_room == room)
mspec.c:	if(ch->in_room == oldroom || ch->in_room != ch->leader->in_room)
mspec.c:		if(ch->in_room != ch->leader->in_room)
mspec.c:			char_to_room(ch,ch->leader->in_room);
mspec.c:		ch->leader->master = ch;
mspec.c:		ch->master = ch->leader;
mspec.c:	WAIT_STATE(ch->leader, PULSE_VIOLENCE);
mspec.c:	if(!ch->leader)
mspec.c:	if(ch->leader->level > 22 && !IS_IMMORTAL(ch->leader))
mspec.c:		ch->leader->pet = NULL;
mspec.c:		ch->leader = NULL;
mspec.c:		ch->master = NULL;
mspec.c:	if(ch->in_room != ch->leader->in_room)
mspec.c:		if(ch->fighting)
mspec.c:		char_to_room(ch, ch->leader->in_room);
mspec.c:		act("$n emerges from the shadows behind you.", ch, 0, ch->leader, TO_VICT);
mspec.c:	if(ch->hit < ch->max_hit / 3)
mspec.c:	if(ch->in_room->vnum == 24527 && number_percent() > 90)
mspec.c:	if(number_percent()>96 && !ch->fighting && !IS_SET(ch->comm, COMM_NOGOSSIP))
mspec.c:				if(get_skill(ch->leader, gsn_enhanced_damage) < 1)
mspec.c:		if(ch->leader->level < 15 && number_percent() > 50)
mspec.c:	if(ch != mob->leader)
mspec.c:	if(argument[0] == '\0' || arg1[0] == '\0' || str_prefix(mob->short_descr,arg1))
mspec.c:		if(str_cmp(mob->in_room->area->name,"Cimar"))
mspec.c:		ch->master = mob;
mspec.c:		mob->master = NULL;
mspec.c:		if(str_cmp(mob->in_room->area->name,"Cimar"))
mspec.c:		ch->master = mob;
mspec.c:		mob->master = NULL;
mspec.c:		if(str_cmp(mob->in_room->area->name,"Cimar"))
mspec.c:		ch->master = mob;
mspec.c:		mob->master = NULL;
mspec.c:		int vnum = 0, cclass = ch->Class()->GetIndex();
mspec.c:		if(ch->alignment == 0)
mspec.c:		if(ch->alignment == 1000)
mspec.c:		if(ch->alignment == -1000)
mspec.c:			do_say(mob,"Darkwalkers like us learn best by killing the weakling do-gooders, although we can kill anybody we want and still gain more experience.");
mspec.c:		if(ch->alignment > -1)
mspec.c:		if(ch->alignment == -1000)
mspec.c:			RS.Queue.AddToQueue(7, 2, do_say, mob, "Although... I've heard of caves around Iseldheim.  Caves where there are zombies nearly impervious to physical attacks: they can rematerialize at the touch of metal.. but if you can think of a way around that - magic, maybe - you'd be good to go.");
mspec.c:		if(str_cmp(mob->in_room->area->name,"Cimar"))
mspec.c:		ch->master = mob;
mspec.c:                mob->master = NULL;
mspec.c:	if((strstr(argument,"be quiet") || strstr(argument, "Be quiet")) && !IS_SET(mob->comm, COMM_NOGOSSIP))
mspec.c:		SET_BIT(mob->comm, COMM_NOGOSSIP);
mspec.c:	if((strstr(argument,"talk") || strstr(argument,"talk")) && IS_SET(mob->comm, COMM_NOGOSSIP))
mspec.c:		REMOVE_BIT(mob->comm, COMM_NOGOSSIP);
mspec.c:	mob->hit = mob->max_hit / 3;
mspec.c:	if(!mob->leader)
mud.c:		*      load up the "tables" - linked lists containing most
necro.c:	if ((corpse->item_type != ITEM_CORPSE_PC &&
necro.c:		corpse->item_type != ITEM_CORPSE_NPC) || IS_SET(corpse->wear_flags,CORPSE_NO_ANIMATE))
necro.c:	if(corpse->level<(ch->level-9))
necro.c:	urn->level    = ch->level;
necro.c:	urn->value[4] = 0;
necro.c:	urn->value[3] = corpse->level;
necro.c:	SET_BIT(corpse->wear_flags,ITEM_NO_SAC);
necro.c:	REMOVE_BIT(corpse->wear_flags,ITEM_TAKE);
necro.c:	if(corpse->item_type == ITEM_CORPSE_NPC)
necro.c:	else if(corpse->item_type == ITEM_CORPSE_PC && corpse->owner)
necro.c:		free_pstring(corpse->description);
necro.c:		sprintf(buf,"The defiled corpse of %s is here, its heart missing.",corpse->owner);
necro.c:		corpse->description = palloc_string(buf);
necro.c:		SET_BIT(corpse->wear_flags, CORPSE_NO_ANIMATE);
necro.c:	for(urn = ch->carrying; urn!=NULL; urn = urn->next_content)
necro.c:		if(urn->item_type == ITEM_URN)
necro.c:	if(urn->value[4]<charges) {
necro.c:	urn->value[4] -= charges;
necro.c:	if(urn->value[4] + charges > urn->value[3])
necro.c:	urn->value[4]+= charges;
necro.c:	sprintf(buf,"You drain a small amount of blood into %s!\n\r",urn->short_descr);
necro.c:	if (IS_SET(victim->imm_flags,IMM_NEGATIVE)
necro.c:		|| IS_SET(victim->imm_flags,IMM_MAGIC))
necro.c:	blood	= URANGE(1,ch->level/15,4);
necro.c:	else if (victim->level > ch->level + 8)
necro.c:    		hex.modifier  = -(ch->level / 5);
necro.c:		hex.modifier  = -(ch->level / 5);
necro.c:	drain_factor = 1 - (0.97 - (0.035 * severity));
necro.c:	drain = (int) (drain_factor * ch->hit);
necro.c:	ch->hit -= drain;
necro.c:    for (search = char_list; search != NULL; search = search->next) {
necro.c:		if (IS_NPC(search) && search->master == ch &&
necro.c:			(search->pIndexData->vnum == MOB_VNUM_ZOMBIE ||
necro.c:			(search->pIndexData->vnum >= 2940 &&
necro.c:			 search->pIndexData->vnum <= 2947)))
necro.c:    if(((control>=3 && ch->level<41) || (control>=4 && ch->level<52))
necro.c:	if (corpse == NULL || (corpse->item_type != ITEM_CORPSE_NPC &&
necro.c:		corpse->item_type != ITEM_CORPSE_PC) || !corpse->ohp)
necro.c:    if (corpse->item_type != ITEM_CORPSE_NPC && corpse->contains!=NULL)
necro.c:	if (IS_SET(corpse->extra_flags,CORPSE_NO_ANIMATE))
necro.c:    chance-= (corpse->level - ch->level)*3;
necro.c:	corpse->value[4] = chance;
necro.c:    SET_BIT(corpse->wear_flags, ITEM_NO_SAC);
necro.c:	ch->disrupted = FALSE;
necro.c:	if (ch->disrupted)	return;
necro.c:	if (!corpse->in_room || corpse->in_room != ch->in_room) {
necro.c:		ch->disrupted = TRUE;
necro.c:	if (ch->fighting) {
necro.c:		ch->disrupted = TRUE;
necro.c:	if (ch->disrupted)	return;
necro.c:	if (!corpse->in_room || corpse->in_room != ch->in_room) {
necro.c:		ch->disrupted = TRUE;
necro.c:	if (ch->fighting) {
necro.c:		ch->disrupted = TRUE;
necro.c:	if (ch->disrupted)	return;
necro.c:    if (!corpse->in_room || corpse->in_room != ch->in_room)
necro.c:    if (number_percent() > corpse->value[4]) {
necro.c:    af.level = ch->level;
necro.c:    ch->wait = 0;
necro.c:    char_to_room(zombie,ch->in_room);
necro.c:    zombie->level = corpse->level;
necro.c:    zombie->max_hit = (short)(corpse->ohp * .55);
necro.c:    zombie->size = corpse->value[2];	
necro.c:    if(corpse->item_type == ITEM_CORPSE_PC) {
necro.c:		zombie->max_hit = corpse->ohp * 6;
necro.c:   	zombie->hit = zombie->max_hit;
necro.c:   	zombie->damage[DICE_NUMBER] = (corpse->level - ((int)(corpse->level / 2.5)));
necro.c:   	zombie->damage[DICE_TYPE]   = 2;
necro.c:    	zombie->damroll	= corpse->level - URANGE(-50,(short)(2.5 * (corpse->level - ch->level)),50);
necro.c:    	name      = corpse->short_descr;
necro.c:    	last_name = one_argument(corpse->short_descr, name);
necro.c:	float dmod = corpse->level * (corpse->item_type == ITEM_CORPSE_PC ? -.55 : -.3);
necro.c:	zombie->defense_mod = (sh_int)dmod;
necro.c:		zombie->size == 0 ? "tiny, " : zombie->size == 1 ? "small, " : zombie->size == 2 ? "" : 
necro.c:		zombie->size == 3 ? "large, " : zombie->size == 4 ? "huge, " : zombie->size == 5 ? "giant, " : "immense, ",
necro.c:		zombie->level < 11 ? "pathetic" : zombie->level < 21 ? "weak" : zombie->level < 31 ? "average" :
necro.c:		zombie->level < 41 ? "strong" : zombie->level < 52 ? "powerful" : "utterly deadly",
necro.c:   	free_pstring(zombie->short_descr);
necro.c:    free_pstring(zombie->long_descr);
necro.c:    zombie->short_descr = palloc_string(buf1);
necro.c:    zombie->long_descr = palloc_string(buf2);
necro.c:    zombie->leader = ch;
necro.c:    SET_BIT(zombie->affected_by,AFF_CHARM);
necro.c:	if (IS_SET(victim->imm_flags,IMM_NEGATIVE))
necro.c:    ch->hit+=dam;
necro.c:	for(pet = char_list; pet!= NULL; pet=pet->next)
necro.c:		if(IS_NPC(pet) && IS_AFFECTED(pet,AFF_CHARM) && pet->master &&
necro.c:			pet->master == ch) {
necro.c:			char_to_room(pet, ch->in_room);
necro.c:	af.level	= ch->level;
necro.c:	for(corpse = object_list; corpse != NULL && corpses < 3; corpse = corpse->next)
necro.c:		if(corpse->in_room && corpse->in_room == ch->in_room && corpse->level>=ch->level &&
necro.c:		  (corpse->pIndexData->item_type == ITEM_CORPSE_PC || corpse->pIndexData->item_type == ITEM_CORPSE_NPC))
necro.c:	ch->disrupted = FALSE;
necro.c:	if(ch->fighting) {
necro.c:		ch->disrupted = TRUE;
necro.c:	if (ch->disrupted)	return;
necro.c:	if (ch->fighting) {
necro.c:		ch->disrupted = TRUE;
necro.c:	if (ch->disrupted)	return;
necro.c:	if (ch->fighting) {
necro.c:	af.level	= ch->level;
necro.c:	af.modifier	= ch->level * 8;
necro.c:	for(mob=ch->in_room->people;mob!=NULL;mob=mob->next_in_room)
necro.c:		if(IS_NPC(mob) && IS_AFFECTED(mob,AFF_CHARM) && mob->master &&
necro.c:			mob->master==ch) {
necro.c:			af.modifier	= (ch->level / 2) - 5;
necro.c:	for (search = char_list; search != NULL; search = search->next) {
necro.c:		if (IS_NPC(search) && search->master == ch &&
necro.c:			search->pIndexData->vnum > 2939 && search->pIndexData->vnum<2945)
necro.c:	if(!IS_NPC(victim) || victim->pIndexData->vnum!=MOB_VNUM_ZOMBIE || victim->master!=ch)
necro.c:	ch->disrupted = FALSE;
necro.c:	if (ch->disrupted)	return;
necro.c:    if (ch->fighting) {
necro.c:		ch->disrupted = TRUE;
necro.c:	if (ch->disrupted)	return;
necro.c:    if (ch->fighting) {
necro.c:		ch->disrupted = TRUE;
necro.c:	ch->mana = (short)(ch->mana * .8);
necro.c:	ch->move = (short)(ch->move * .5);
necro.c:	if (ch->disrupted)	return;
necro.c:	if (ch->fighting) {
necro.c:	char_to_room(mob,ch->in_room);
necro.c:	mob->hit	= victim->hit;
necro.c:	mob->max_hit	= victim->max_hit;
necro.c:	mob->level	= victim->level;
necro.c:        af.duration = -1;
necro.c:        mob->leader = ch;
necro.c:        SET_BIT(mob->affected_by, AFF_CHARM);
necro.c:	af.duration = -1;
necro.c:	for (search = char_list; search != NULL; search = search->next)
necro.c:		if (IS_NPC(search) && search->master == ch &&
necro.c:			search->pIndexData->vnum > 2944 && search->pIndexData->vnum<2948)
necro.c:	if(!IS_NPC(victim) || victim->pIndexData->vnum!=MOB_VNUM_ZOMBIE
necro.c:		|| victim->master!=ch)
necro.c:	ch->disrupted = FALSE;
necro.c:	if (ch->fighting) {
necro.c:		ch->disrupted = TRUE;
necro.c:	if (ch->disrupted)	return;
necro.c:	if (ch->fighting) {
necro.c:		ch->disrupted = TRUE;
necro.c:	ch->hit = (short)(ch->hit * 0.8);
necro.c:	if (ch->disrupted)	return;
necro.c:	if (ch->fighting) {
necro.c:	char_to_room(mob,ch->in_room);
necro.c:	mob->max_hit    = victim->max_hit;
necro.c:	mob->hit        = mob->max_hit;
necro.c:	mob->level      = victim->level;
necro.c:	mob->damage[DICE_NUMBER]	= victim->level + 10;
necro.c:	mob->damage[DICE_TYPE]	= 2;
necro.c:	mob->damroll = victim->level - URANGE(-50,(short)(2.5 * (victim->level - ch->level)),50);
necro.c:        af.duration = -1;
necro.c:   	mob->leader = ch;
necro.c:   	SET_BIT(mob->affected_by, AFF_CHARM);
necro.c:	mv = (short)(ch->level * 3.5);
necro.c:	if(saves_spell(ch->level,victim,DAM_MENTAL))
necro.c:	victim->move -= mv;
necro.c:	af.duration = ch->level/5;
necro.c:	af.level = ch->level;
necro.c:		ch->wait = 0;
necro.c:		ch->wait = 0;
necro.c:	if((obj->pIndexData->vnum != OBJ_VNUM_SEVERED_HEAD)
necro.c:		&& (obj->pIndexData->vnum != OBJ_VNUM_SLICED_ARM)
necro.c:		&& (obj->pIndexData->vnum != OBJ_VNUM_SLICED_LEG))
necro.c:		sprintf(buf,"Help!  I am being attacked by %s!",obj->short_descr);
necro.c:		if(ch->fighting == NULL)
necro.c:		if ((IS_SET(obj2->extra_flags,ITEM_NOREMOVE)) ||
necro.c:			(IS_SET(obj2->extra_flags,ITEM_NODISARM)))
necro.c:			if(IS_SET(obj2->extra_flags,ITEM_NODROP))
necro.c:				obj_to_room(obj2,victim->in_room);
necro.c:		char_to_room(mob,ch->in_room);
necro.c:		mob->level = 1;
necro.c:		mob->leader = ch;
necro.c:	if(corpse->item_type != ITEM_CORPSE_NPC && corpse->item_type != ITEM_CORPSE_PC)
necro.c:	if((corpse->level + 6) < ch->level)
necro.c:	if (corpse->item_type != ITEM_CORPSE_NPC && corpse->contains!=NULL)
necro.c:	chance += ch->level - corpse->level;
necro.c:	trap = create_object(get_obj_index(vnum),corpse->level);
necro.c:	trap->level = ch->level;
necro.c:	trap->timer = number_range(5,8);
necro.c:	if(corpse->item_type == ITEM_CORPSE_NPC)
necro.c:		trap->item_type = ITEM_CORPSE_NPC;
necro.c:	SET_BIT(trap->extra_flags,CORPSE_NO_ANIMATE);
necro.c:	obj_to_room(trap,ch->in_room);
necro.c:	trap->owner = palloc_string(ch->true_name);
necro.c:	af.level = ch->level;
necro.c:	for (check = char_list; check != NULL; check = check->next)
necro.c:		if (IS_NPC(check) && check->master == ch &&
necro.c:			(check->pIndexData->vnum == 2955 || check->pIndexData->vnum == 2956
necro.c:			|| check->pIndexData->vnum == 2957))
necro.c:	af.level = ch->level;
necro.c:	mob->max_hit = (short)(ch->max_hit*1.5);
necro.c:	mob->hit = mob->max_hit;
necro.c:	mob->damroll = 0;
necro.c:	mob->level = ch->level + (num/2);
necro.c:	mob->damage[DICE_TYPE] = 2;
necro.c:	mob->damage[DICE_NUMBER] = mob->level;
necro.c:	mob->damage[DICE_BONUS] = mob->level / 3;
necro.c:	mob->leader = ch;
necro.c:	SET_BIT(mob->affected_by, AFF_CHARM);
necro.c:	char_to_room(mob,ch->in_room);
necro.c:	for (check = char_list; check != NULL; check = check->next)
necro.c:        if (IS_NPC(check) && check->master == ch &&
necro.c:			(check->pIndexData->vnum == 2959 || check->pIndexData->vnum == 2960
necro.c:			|| check->pIndexData->vnum == 2961))
necro.c:		if(str_cmp(obj->pIndexData->material,"glass") || obj->weight < 20)
necro.c:		if(ch->in_room->sector_type != SECT_MOUNTAIN)
necro.c:		if(!IS_SET(ch->in_room->room_flags, ROOM_DARK))
necro.c:	af.level = ch->level;
necro.c:	mob->max_hit = ch->max_hit*2;
necro.c:	mob->hit = mob->max_hit;
necro.c:	mob->damroll = 0;
necro.c:	mob->level = ch->level;
necro.c:	mob->damage[DICE_TYPE] = 4;
necro.c:	mob->damage[DICE_NUMBER] = ch->level;
necro.c:	mob->damage[DICE_BONUS] = ch->level / 2;
necro.c:	mob->leader = ch;
necro.c:	SET_BIT(mob->affected_by, AFF_CHARM);
necro.c:	char_to_room(mob,ch->in_room);	
necro.c:	if((corpse->item_type != ITEM_CORPSE_NPC) && (corpse->item_type != ITEM_CORPSE_PC))
necro.c:	if(corpse->item_type == ITEM_CORPSE_PC && ((corpse->level+ 6) < (ch->level)))
necro.c:	if(corpse->item_type == ITEM_CORPSE_NPC && ((corpse->level + 6) < ch->level))
necro.c:	if(IS_SET(corpse->extra_flags,CORPSE_NO_ANIMATE))
necro.c:		blood   = URANGE(1,ch->level/15,4);
necro.c:		SET_BIT(corpse->extra_flags,CORPSE_NO_ANIMATE);
necro.c:		SET_BIT(corpse->extra_flags,CORPSE_NO_ANIMATE);
necro.c:	if(number_percent() < chance - 20) {
necro.c:		af.duration = -1;
necro.c:	for(mob = char_list; mob!= NULL; mob=mob->next)
necro.c:		if(IS_NPC(mob) && IS_AFFECTED(mob,AFF_CHARM) && mob->master &&
necro.c:			mob->master == ch && is_affected(mob,gsn_unholy_bond)) {
necro.c:		char_to_room(mob, ch->in_room);
necro.c:	if(ch->pcdata->souls > 250)
necro.c:	ch->pcdata->souls += souls;
necro.c:	if(ch->Class()->GetIndex() != CLASS_NECROMANCER)
necro.c:	if(ch->pcdata->souls == 20)
necro.c:	if(ch->pcdata->souls >= 30 && ch->pcdata->learned[skill_lookup("ritual of flesh")] < 1)
necro.c:		ch->pcdata->learned[skill_lookup("ritual of flesh")] = 1;
necro.c:	if(ch->pcdata->souls >= 55 && ch->pcdata->learned[skill_lookup("ritual of soul")] < 1)
necro.c:		ch->pcdata->learned[skill_lookup("ritual of soul")] = 1;
necro.c:    if(ch->pcdata->souls >= 80 && ch->pcdata->learned[skill_lookup("visceral divination")] < 1)
necro.c:        ch->pcdata->learned[skill_lookup("visceral divination")] = 1;
newmem.c://	nAllocString--;
newmem.c://	sAllocString -= strlen(pstr);
newmem.c:	nAllocPerm--;
newmem.c:	sAllocPerm -= sizeof(pstruct);
newmem.c:		for(qch = char_list; qch; qch = qch->next)
newmem.c:			if(IS_NPC(qch) && qch->pIndexData->vnum == 3001)
newmem.c:				qch->dam_mod = atoi(argument);
newmem.c:		for(qch = char_list; qch; qch = qch->next)
newmem.c:			if(IS_NPC(qch) && qch->pIndexData->vnum == 3001)
newmem.c:				qch->max_hit = UMAX(qch->max_hit - atoi(argument), 100);
newmem.c:		for(qch = char_list; qch; qch = qch->next)
newmem.c:			if(IS_NPC(qch) && qch->pIndexData->vnum == 3001 && !IS_AFFECTED(qch, AFF_DETECT_MAGIC))
newmem.c:				SET_BIT(qch->affected_by, AFF_DETECT_MAGIC);
newmem.c:		for(qch = char_list; qch; qch = qch->next)
newmem.c:			if(IS_NPC(qch) && qch->pIndexData->vnum == 3001 && qch->in_room->vnum > 2399 &&
newmem.c:			   qch->in_room->vnum < 2801)
newspec.c:	Cal is a bad ass motha- shut yo' mouth!
note.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
note.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
note.c:	escape = (char *) escape_string(pnote->text);
note.c:	pnote->type, pnote->sender, pnote->date, pnote->to_list, pnote->subject, escape, pnote->date_stamp);
note.c:    if ( !str_cmp( ch->true_name, sender))
note.c:    if ( IS_SET(ch->act, PLR_CODER) && is_name( "coder", to_list ) )
note.c:    if ( !IS_NPC(ch) && is_name(ch->Class()->name, to_list) )
note.c:    if (ch->cabal && is_name(cabal_table[ch->cabal].name,to_list))
note.c:    if (is_name(ch->true_name, to_list))
note.c:    if (is_number(to_list) && ch->level >= atoi(to_list))
note.c:    if ( ch->pnote != NULL )
note.c:    pnote->next		= NULL;
note.c:    pnote->sender	= (IS_NPC(ch)) ? palloc_string(ch->short_descr) : palloc_string(ch->true_name);
note.c:    pnote->date		= palloc_string( "" );
note.c:    pnote->to_list	= palloc_string( "" );
note.c:    pnote->subject	= palloc_string( "" );
note.c:    pnote->text		= palloc_string( "" );
note.c:    pnote->type		= type;
note.c:    ch->pnote		= pnote;
note.c:	    last_read = ch->pcdata->last_note;
note.c:	    last_read = ch->pcdata->last_idea;
note.c:	    last_read = ch->pcdata->last_penalty;
note.c:	    last_read = ch->pcdata->last_news;
note.c:	    last_read = ch->pcdata->last_changes;
note.c:    if (!str_cmp(ch->name,row[1]))
note.c:	    ch->pcdata->last_note = UMAX(ch->pcdata->last_note,stamp);
note.c:	    ch->pcdata->last_idea = UMAX(ch->pcdata->last_idea,stamp);
note.c:	    ch->pcdata->last_penalty = UMAX(ch->pcdata->last_penalty,stamp);
note.c:	    ch->pcdata->last_news = UMAX(ch->pcdata->last_news,stamp);
note.c:	    ch->pcdata->last_changes = UMAX(ch->pcdata->last_changes,stamp);
note.c:            if (!str_cmp(ch->true_name, row[1]) && vnum++ == anum )
note.c:    if ( !str_prefix( arg, "delete" ) && get_trust(ch) >= MAX_LEVEL - 2)
note.c:	if (ch->pnote->type != type)
note.c:	if (strlen(ch->pnote->text)+strlen(argument) >= 4096)
note.c:	add_buf(buffer,ch->pnote->text);
note.c:	free_pstring( ch->pnote->text );
note.c:	ch->pnote->text = palloc_string( buf_string(buffer) );
note.c:    if (!str_cmp(arg,"-"))
note.c:        if (ch->pnote->type != type)
note.c:	if (ch->pnote->text == NULL || ch->pnote->text[0] == '\0')
note.c:	strcpy(buf,ch->pnote->text);
note.c:	for (len = strlen(buf); len > 0; len--)
note.c:			len--;
note.c:		    free_pstring(ch->pnote->text);
note.c:		    ch->pnote->text = palloc_string(buf);
note.c:	free_pstring(ch->pnote->text);
note.c:	ch->pnote->text = palloc_string(buf);
note.c:        if (ch->pnote->type != type)
note.c:	free_pstring( ch->pnote->subject );
note.c:	ch->pnote->subject = palloc_string( argument );
note.c:        if (ch->pnote->type != type)
note.c:	&& !(ch->pcdata->induct == CABAL_LEADER))
note.c:	free_pstring( ch->pnote->to_list );
note.c:	ch->pnote->to_list = palloc_string( argument );
note.c:	if ( ch->pnote != NULL )
note.c:	    free_note(ch->pnote);
note.c:	    ch->pnote = NULL;
note.c:	if ( ch->pnote == NULL )
note.c:	if (ch->pnote->type != type)
note.c:	    ch->pnote->sender,
note.c:	    ch->pnote->subject,
note.c:	    ch->pnote->to_list
note.c:	send_to_char( ch->pnote->text, ch );
note.c:	if ( ch->pnote == NULL )
note.c:        if (ch->pnote->type != type)
note.c:	if (!str_cmp(ch->pnote->to_list,""))
note.c:	if (!str_cmp(ch->pnote->subject,""))
note.c:	ch->pnote->next			= NULL;
note.c:	strtime[strlen(strtime)-1]	= '\0';
note.c:	ch->pnote->date			= palloc_string( strtime );
note.c:	ch->pnote->date_stamp		= current_time;
note.c:	append_note(ch->pnote);
note.c:	ch->pnote = NULL;
olc.c: *  and has been used here for OLC - OLC would not be what it is without   *
olc.c:    switch ( d->editor )
olc.c:			aedit( d->character, d->incomm );
olc.c:			redit( d->character, d->incomm );
olc.c:			oedit( d->character, d->incomm );
olc.c:			medit( d->character, d->incomm );
olc.c:	switch( ch->desc->editor)
olc.c:    switch (ch->desc->editor)
olc.c:    switch ( ch->desc->editor )
olc.c:	pArea = (AREA_DATA *)ch->desc->pEdit;
olc.c:	sprintf( buf, "%d", pArea ? pArea->vnum : 0 );
olc.c:	pRoom = ch->in_room;
olc.c:	sprintf( buf, "%d", pRoom ? pRoom->vnum : 0 );
olc.c:	pObj = (OBJ_INDEX_DATA *)ch->desc->pEdit;
olc.c:	sprintf( buf, "%d", pObj ? pObj->vnum : 0 );
olc.c:	pMob = (MOB_INDEX_DATA *)ch->desc->pEdit;
olc.c:	sprintf( buf, "%d", pMob ? pMob->vnum : 0 );
olc.c:	sprintf( buf, "%-15.15s", olc_table[cmd].name );
olc.c:    switch (ch->desc->editor)
olc.c:    {   "builder",	aedit_builder	}, /* s removed -- Hugin */
olc.c:    for (pArea = area_first; pArea; pArea = pArea->next )
olc.c:        if (pArea->vnum == vnum)
olc.c:    ch->desc->pEdit = NULL;
olc.c:    ch->desc->editor = 0;
olc.c:		TOGGLE_BIT(pArea->area_flags, value);
olc.c:		SET_BIT( pArea->area_flags, AREA_CHANGED );
olc.c:				SET_BIT( pArea->area_flags, AREA_CHANGED );
olc.c:    pArea = pRoom->area;
olc.c:        TOGGLE_BIT(pRoom->room_flags, value);
olc.c:        SET_BIT( pArea->area_flags, AREA_CHANGED );
olc.c:        pRoom->sector_type  = value;
olc.c:        SET_BIT( pArea->area_flags, AREA_CHANGED );
olc.c:				SET_BIT( pArea->area_flags, AREA_CHANGED );
olc.c:    pArea = pObj->area;
olc.c:		SET_BIT( pArea->area_flags, AREA_CHANGED );
olc.c:    pArea = pMob->area;
olc.c:		SET_BIT( pArea->area_flags, AREA_CHANGED );
olc.c:	return ch->pcdata->security;
olc.c:	if(ch->pcdata->security < 1)
olc.c:/*	if(ch->pcdata->security < 4 && mPort == 9999) {
olc.c:	pArea = ch->in_room->area;
olc.c:	    	if (!IS_NPC(ch) && (ch->pcdata->security < 9) )
olc.c:			area_last->next = pArea;
olc.c:			SET_BIT( pArea->area_flags, AREA_ADDED );
olc.c:    ch->desc->pEdit = (void *)pArea;
olc.c:    ch->desc->editor = ED_AREA;
olc.c:    pRoom = ch->in_room;
olc.c:	if ( !IS_BUILDER( ch, pRoom->area ) )
olc.c:	    char_to_room( ch, (ROOM_INDEX_DATA *)ch->desc->pEdit );
olc.c:	    SET_BIT( pRoom->area->area_flags, AREA_CHANGED );
olc.c:	    pRoom = ch->in_room;
olc.c:	    if ( (pRoom2 != NULL) && IS_BUILDER(ch,pRoom2->area) )
olc.c:	       pRoom = ch->in_room;
olc.c:    if ( !IS_BUILDER( ch, pRoom->area ) )
olc.c:    ch->desc->editor = ED_ROOM;
olc.c:	if(!strcmp(arg1,"") && ch->pcdata->editing_item > 0)
olc.c:		value = ch->pcdata->editing_item;
olc.c:		if ( !IS_BUILDER( ch, pObj->area ) )
olc.c:		ch->desc->pEdit = (void *)pObj;
olc.c:		ch->pcdata->editing_item = value;
olc.c:		ch->desc->editor = ED_OBJECT;
olc.c:				SET_BIT( pArea->area_flags, AREA_CHANGED );
olc.c:				ch->desc->editor = ED_OBJECT;
olc.c:	if ( !IS_BUILDER( ch, pMob->area ) )
olc.c:	ch->desc->pEdit = (void *)pMob;
olc.c:	ch->desc->editor = ED_MOBILE;
olc.c:		SET_BIT( pArea->area_flags, AREA_CHANGED );
olc.c:		ch->desc->editor = ED_MOBILE;
olc.c:    for ( pReset = pRoom->reset_first; pReset; pReset = pReset->next )
olc.c:	switch ( pReset->command )
olc.c:	    sprintf( buf, "Bad reset command: %c.", pReset->command );
olc.c:	    if ( !( pMobIndex = get_mob_index( pReset->arg1 ) ) )
olc.c:                sprintf( buf, "Load Mobile - Bad Mob %d\n\r", pReset->arg1 );
olc.c:	    if ( !( pRoomIndex = get_room_index( pReset->arg3 ) ) )
olc.c:                sprintf( buf, "Load Mobile - Bad Room %d\n\r", pReset->arg3 );
olc.c:            sprintf( buf, "M[%5d] %-13.13s in room             R[%5d] %2d-%2d %-15.15s\n\r",
olc.c:                       pReset->arg1, pMob->short_descr, pReset->arg3,
olc.c:                       pReset->arg2, pReset->arg4, pRoomIndex->name );
olc.c:	     * -------------------
olc.c:		pRoomIndexPrev = get_room_index( pRoomIndex->vnum - 1 );
olc.c:		    && IS_SET( pRoomIndexPrev->room_flags, ROOM_PET_SHOP ) )
olc.c:	    if ( !( pObjIndex = get_obj_index( pReset->arg1 ) ) )
olc.c:                sprintf( buf, "Load Object - Bad Object %d\n\r",
olc.c:		    pReset->arg1 );
olc.c:	    if ( !( pRoomIndex = get_room_index( pReset->arg3 ) ) )
olc.c:                sprintf( buf, "Load Object - Bad Room %d\n\r", pReset->arg3 );
olc.c:            sprintf( buf, "O[%5d] %-13.13s in room             "
olc.c:                          "R[%5d]       %-15.15s\n\r",
olc.c:                          pReset->arg1, pObj->short_descr,
olc.c:                          pReset->arg3, pRoomIndex->name );
olc.c:	    if ( !( pObjIndex = get_obj_index( pReset->arg1 ) ) )
olc.c:                sprintf( buf, "Put Object - Bad Object %d\n\r",
olc.c:                    pReset->arg1 );
olc.c:	    if ( !( pObjToIndex = get_obj_index( pReset->arg3 ) ) )
olc.c:                sprintf( buf, "Put Object - Bad To Object %d\n\r",
olc.c:                    pReset->arg3 );
olc.c:		"O[%5d] %-13.13s inside              O[%5d] %2d-%2d %-15.15s\n\r",
olc.c:		pReset->arg1,
olc.c:		pObj->short_descr,
olc.c:		pReset->arg3,
olc.c:		pReset->arg2,
olc.c:		pReset->arg4,
olc.c:		pObjToIndex->short_descr );
olc.c:	    if ( !( pObjIndex = get_obj_index( pReset->arg1 ) ) )
olc.c:                sprintf( buf, "Give/Equip Object - Bad Object %d\n\r",
olc.c:                    pReset->arg1 );
olc.c:                sprintf( buf, "Give/Equip Object - No Previous Mobile\n\r" );
olc.c:	    if ( pMob->pShop )
olc.c:		"O[%5d] %-13.13s in the inventory of S[%5d]       %-15.15s\n\r",
olc.c:		pReset->arg1,
olc.c:		pObj->short_descr,
olc.c:		pMob->vnum,
olc.c:		pMob->short_descr  );
olc.c:		"O[%5d] %-13.13s %-19.19s M[%5d]       %-15.15s\n\r",
olc.c:		pReset->arg1,
olc.c:		pObj->short_descr,
olc.c:		(pReset->command == 'G') ?
olc.c:		  : flag_string_old( wear_loc_strings, pReset->arg3 ),
olc.c:		  pMob->vnum,
olc.c:		  pMob->short_descr );
olc.c:	    pRoomIndex = get_room_index( pReset->arg1 );
olc.c:	    sprintf( buf, "R[%5d] %s door of %-19.19s reset to %s\n\r",
olc.c:		pReset->arg1,
olc.c:		capitalize( dir_name[ pReset->arg2 ] ),
olc.c:		pRoomIndex->name,
olc.c:		flag_string_old( door_resets, pReset->arg3 ) );
olc.c:		pMobIndex = get_mob_index( pReset->arg1);
olc.c:		pMobIndex2 = get_mob_index( pReset->arg2);
olc.c:		sprintf( buf, "R[%5d] %-13.13s %-19.19s M[%5d]        %-15.15s\n\r", 
olc.c:				pMobIndex->vnum, 
olc.c:				pMobIndex->short_descr,
olc.c:				pMobIndex2->vnum,
olc.c:				pMobIndex2->short_descr);
olc.c:	    if ( !( pRoomIndex = get_room_index( pReset->arg1 ) ) )
olc.c:		sprintf( buf, "Randomize Exits - Bad Room %d\n\r",
olc.c:		    pReset->arg1 );
olc.c:		pReset->arg1, pRoomIndex->name );
olc.c:    if ( !room->reset_first )
olc.c:	room->reset_first	= pReset;
olc.c:	room->reset_last	= pReset;
olc.c:	pReset->next		= NULL;
olc.c:    index--;
olc.c:	pReset->next = room->reset_first;
olc.c:	room->reset_first = pReset;
olc.c:    for ( reset = room->reset_first; reset->next; reset = reset->next )
olc.c:    pReset->next	= reset->next;
olc.c:    reset->next		= pReset;
olc.c:    if ( !pReset->next )
olc.c:	room->reset_last = pReset;
olc.c:    if ( !IS_BUILDER( ch, ch->in_room->area ) )
olc.c:     * -------------------------------
olc.c:		if ( ch->in_room->reset_first )
olc.c:     * ------------------------------------------
olc.c:	ROOM_INDEX_DATA *pRoom = ch->in_room;
olc.c:	 * ---------------
olc.c:	    if ( !ch->in_room->reset_first )
olc.c:	    if ( insert_loc-1 <= 0 )
olc.c:			pReset = pRoom->reset_first;
olc.c:			pRoom->reset_first = pRoom->reset_first->next;
olc.c:			if ( !pRoom->reset_first )
olc.c:		    	pRoom->reset_last = NULL;
olc.c:		for ( pReset = pRoom->reset_first;
olc.c:		  pReset = pReset->next )
olc.c:		    prev->next = prev->next->next;
olc.c:		    pRoom->reset_first = pRoom->reset_first->next;
olc.c:		for ( pRoom->reset_last = pRoom->reset_first;
olc.c:		  pRoom->reset_last->next;
olc.c:		  pRoom->reset_last = pRoom->reset_last->next );
olc.c:         pReset->command  = 'D';                                                                               
olc.c:		 pReset->arg1	  = pRoom->vnum;
olc.c:		 pReset->arg2     = flag_lookup( arg3, direction_table); 
olc.c:			 pReset->arg3 = 1;
olc.c:			 pReset->arg3 = 2;
olc.c:	     pReset->arg4     = 0;   
olc.c:		 add_reset( ch->in_room, pReset, atoi( arg1 ) );                                                           
olc.c:         SET_BIT( ch->in_room->area->area_flags, AREA_CHANGED );                                                   
olc.c:		pReset->command = 'F';
olc.c:		pReset->arg1 = atoi(arg3);
olc.c:		pReset->arg2 = atoi(arg4);
olc.c:		pReset->arg3 = 0;
olc.c:		pReset->arg4 = 0;
olc.c:		add_reset( ch->in_room, pReset, atoi( arg1 ) );
olc.c:		SET_BIT( ch->in_room->area->area_flags, AREA_CHANGED );
olc.c:	 * ------------
olc.c:	     * -----------------------
olc.c:		pReset->command = 'M';
olc.c:		pReset->arg1    = atoi( arg3 );
olc.c:		pReset->arg2    = is_number( arg4 ) ? atoi( arg4 ) : 1; /* Max # */
olc.c:		pReset->arg3    = ch->in_room->vnum;
olc.c:		pReset->arg4	= is_number( arg5 ) ? atoi( arg5 ) : 1; /* Min # */
olc.c:	     * -----------------------
olc.c:		pReset->arg1    = atoi( arg3 );
olc.c:		 * ----------------------
olc.c:		    pReset->command = 'P';
olc.c:		    pReset->arg2    = 0;
olc.c:		    if ((get_obj_index(is_number(arg5)? atoi(arg5) : 1 ))->item_type != ITEM_CONTAINER)
olc.c:		    pReset->arg2    = is_number( arg6 ) ? atoi( arg6 ) : 1;
olc.c:		    pReset->arg3    = is_number( arg5 ) ? atoi( arg5 ) : 1;
olc.c:		    pReset->arg4    = is_number( arg7 ) ? atoi( arg7 ) : 1;
olc.c:		 * ----------------
olc.c:		    pReset->command  = 'O';
olc.c:		    pReset->arg1     = atoi ( arg3 );
olc.c:		    pReset->arg2     = 0;
olc.c:		    pReset->arg3     = ch->in_room->vnum;
olc.c:		    pReset->arg4     = 0;
olc.c:		 * --------------------------
olc.c:			send_to_char( "Resets: '? wear-loc'\n\r", ch );
olc.c:		    pReset->arg1 = atoi(arg3);
olc.c:		    pReset->arg3 = flag_value( wear_loc_flags, arg4 );
olc.c:		    if ( pReset->arg3 == WEAR_NONE )
olc.c:			pReset->command = 'G';
olc.c:			pReset->command = 'E';
olc.c:	    add_reset( ch->in_room, pReset, atoi( arg1 ) );
olc.c:	    SET_BIT( ch->in_room->area->area_flags, AREA_CHANGED );
olc.c:    sprintf( result, "[%3s] [%-27s] (%-5s-%5s) [%-10s] %3s [%-10s]\n\r",
olc.c:    for ( pArea = area_first; pArea; pArea = pArea->next )
olc.c:		if(nmatch != NULL && !strstr(lowstring(pArea->name), nmatch))
olc.c:		else if(vmatch && (pArea->min_vnum > vmatch || pArea->max_vnum < vmatch))
olc.c:		sprintf( buf, "[%3d] %-29.29s (%-5d-%5d) %-12.12s [%d] [%-10.10s]\n\r",
olc.c:	    	pArea->vnum,
olc.c:	     	pArea->name,
olc.c:	     	pArea->min_vnum,
olc.c:	     	pArea->max_vnum,
olc.c:	     	pArea->file_name,
olc.c:	     	pArea->security,
olc.c:	     	pArea->credits );
olc_act.c: *  and has been used here for OLC - OLC would not be what it is without   *
olc_act.c: * ------------------------------------------------------------------
olc_act.c:    {	"wear-loc",	wear_loc_flags,	 "Where mobile wears object."	 },
olc_act.c:	    sprintf( buf, "%-19.18s", flag_table[flag].name );
olc_act.c:	if ( tar == -1 || skill_table[sn].target == tar )
olc_act.c:	    sprintf( buf, "%-19.18s", skill_table[sn].name );
olc_act.c:	sprintf( buf, "%-19.18s", &spec_table[spec].name[5] );
olc_act.c:	    sprintf( buf, "%-10.10s -%s\n\r",
olc_act.c:     * ---------------------------------------
olc_act.c:		    show_skill_cmds( ch, -1 );
olc_act.c:    pArea = ch->in_room->area;
olc_act.c:    for ( vnum = pArea->min_vnum; vnum <= pArea->max_vnum; vnum++ )
olc_act.c:			sprintf( buf, "[%5d] %-17.16s", vnum, capitalize( pRoomIndex->name ) );
olc_act.c:	if(arg[0] == '\0' || (vnum=atoi(arg))==-1)
olc_act.c:	pArea = ch->in_room->area;
olc_act.c:	if(vnum < pArea->min_vnum || vnum > pArea->max_vnum)
olc_act.c:	sprintf( buf,"Name:     [%s]\n\r", pMob->player_name);
olc_act.c:	sprintf( buf,"Short:    [%s]\n\r", pMob->short_descr);
olc_act.c:	sprintf( buf,"Long:     [%s]\n\r", pMob->long_descr);
olc_act.c:	sprintf( buf,"Desc:\n\r%s\n\r", pMob->description);
olc_act.c:	sprintf( buf,"Level:    [%d]\n\r", pMob->level);
olc_act.c:    pArea = ch->in_room->area;
olc_act.c:    for ( vnum = pArea->min_vnum; vnum <= pArea->max_vnum; vnum++ )
olc_act.c:	    	if ( fAll || is_name( arg, pMobIndex->player_name ) )
olc_act.c:				sprintf( buf, "[%5d] %-17.16s", pMobIndex->vnum, capitalize( pMobIndex->short_descr ) );
olc_act.c:    pArea = ch->in_room->area;
olc_act.c:    for ( vnum = pArea->min_vnum; vnum <= pArea->max_vnum; vnum++ )
olc_act.c:	    	if ( fAll || is_name( arg, pObjIndex->name ) || flag_value( type_flags, arg ) == pObjIndex->item_type )
olc_act.c:				sprintf( buf, "[%5d] %-17.16s", pObjIndex->vnum, capitalize( pObjIndex->short_descr ) );
olc_act.c:	ch->desc->pEdit = (void *)pMob;
olc_act.c:    ch->desc->pEdit = (void *)ch->in_room;
olc_act.c:	ch->desc->pEdit = (void *)pObj;
olc_act.c:    ch->desc->pEdit = (void *)ch->in_room;
olc_act.c:    for ( pArea = area_first; pArea; pArea = pArea->next )
olc_act.c:        if ( ( lower <= pArea->min_vnum && pArea->min_vnum <= upper )
olc_act.c:	||   ( lower <= pArea->max_vnum && pArea->max_vnum <= upper ) )
olc_act.c:    for ( pArea = area_first; pArea; pArea = pArea->next )
olc_act.c:        if ( vnum >= pArea->min_vnum
olc_act.c:          && vnum <= pArea->max_vnum )
olc_act.c:	if(vnum >= ch->in_room->area->min_vnum && vnum <= ch->in_room->area->max_vnum)
olc_act.c:		pMob->vnum = vnum;
olc_act.c:		send_to_char("Syntax:  group <xxyy>  - First vnum in your area\n\r", ch);
olc_act.c:	pMob->group = atoi(argument);
olc_act.c:					if(!speech->first_line)
olc_act.c:					sprintf(buf,"%s Lines:\n\r", speech->name);
olc_act.c:					for(lptr = speech->first_line; lptr; lptr = lptr->next)
olc_act.c:							lptr->number,
olc_act.c:							lptr->delay,
olc_act.c:							flag_name_lookup(lptr->type,speech_table),
olc_act.c:							lptr->text);
olc_act.c:					new_line->delay = atoi(arg4);
olc_act.c:					new_line->type = type;
olc_act.c:					new_line->text = palloc_string(argument); 
olc_act.c:					for(lptr = speech->first_line; lptr->next != NULL; lptr = lptr->next)
olc_act.c:					lptr->next = new_line;
olc_act.c:					for(lptr = speech->first_line; lptr; lptr = lptr->next)
olc_act.c:						if(lptr->number == atoi(arg3))
olc_act.c:							lptr->delay = atoi(argument);
olc_act.c:							lptr->number = atoi(argument);
olc_act.c:							lptr->type = type;
olc_act.c:							free_pstring(lptr->text);
olc_act.c:							lptr->text = palloc_string(argument);
olc_act.c:			if (!pMobIndex->speech) 
olc_act.c:			for (sptr = pMobIndex->speech; sptr; sptr = sptr->next) 
olc_act.c:				sprintf(buf,"%s\n\r",sptr->name);
olc_act.c:			speech->name = palloc_string(name);
olc_act.c:			if (!pMobIndex->speech)
olc_act.c:				pMobIndex->speech = speech;
olc_act.c:				for (sptr = pMobIndex->speech; sptr->next; sptr = sptr->next);
olc_act.c:				sptr->next = speech;
olc_act.c:				speech->prev = sptr;
olc_act.c:			if(ch->pcdata->security < 10)
olc_act.c:				if(!str_cmp(ch->in_room->area->name, mprog_table[count].owner))
olc_act.c:			if(pMobIndex->mprogs == NULL) {
olc_act.c:            	pMobIndex->mprogs  = new MPROG_DATA;
olc_act.c:		       CLEAR_MEM(pMobIndex->mprogs, sizeof(MPROG_DATA));
olc_act.c:			if(pMobIndex->mprogs && mprog_unset( pMobIndex, prog_type, prog))
olc_act.c:			if(ch->pcdata->security < 10)
olc_act.c:				if(!str_cmp(ch->in_room->area->name, iprog_table[count].owner))
olc_act.c:		if(pObjIndex->iprogs == NULL) {
olc_act.c:			pObjIndex->iprogs  = new IPROG_DATA;
olc_act.c:			CLEAR_MEM(pObjIndex->iprogs, sizeof(IPROG_DATA));
olc_act.c:		if(pObjIndex->spec_prog.func)
olc_act.c:			pObjIndex->spec_prog.func = NULL;
olc_act.c:			pObjIndex->spec_prog.trapvector = 0;
olc_act.c:	if(pRoom->trap && arg1[0] != '\0')
olc_act.c:				pRoom->trap->type = num;
olc_act.c:					pRoom->trap->quality = num;
olc_act.c:					pRoom->trap->complexity = num;
olc_act.c:					pRoom->trap->timer = num;
olc_act.c:				pRoom->trap->trig_echo = palloc_string(argument);
olc_act.c:				pRoom->trap->exec_echo = palloc_string(argument);
olc_act.c:				free_trap(pRoom->trap);
olc_act.c:				pRoom->trap = NULL;
olc_act.c:	else if(!pRoom->trap && !str_cmp(arg1,"new")) 
olc_act.c:		trap->room = pRoom;
olc_act.c:		trap->type = TRAP_NONE;
olc_act.c:		trap->quality = 0;
olc_act.c:		trap->complexity = 0;
olc_act.c:		trap->timer = 0;
olc_act.c:		trap->trig_echo = NULL;
olc_act.c:		trap->exec_echo = NULL;
olc_act.c:		trap->armed = FALSE;
olc_act.c:		pRoom->trap = trap;
olc_act.c:		if(pRoom->trap)
olc_act.c:						 "              quality <#1-10>\n\r"\
olc_act.c:						 "              complexity <#1-10>\n\r"\
olc_act.c:						 "              timer <#1-10>\n\r"\
olc_act.c:			if(ch->pcdata->security < 10)
olc_act.c:				if(!str_cmp(ch->in_room->area->name, rprog_table[count].owner))
olc_act.c:		if(pRoomIndex->rprogs == NULL) {
olc_act.c:			pRoomIndex->rprogs  = new RPROG_DATA;
olc_act.c:			CLEAR_MEM(pRoomIndex->rprogs, sizeof(RPROG_DATA));
olc_act.c:	pArea->area_type = type;
olc_act.c:			if(ch->pcdata->security < 10)
olc_act.c:				if(!str_cmp(ch->in_room->area->name, aprog_table[count].owner))
olc_act.c:		if(pArea->aprogs == NULL) {
olc_act.c:			pArea->aprogs  = new APROG_DATA;
olc_act.c:			CLEAR_MEM(pArea->aprogs, sizeof(APROG_DATA));
olc_act.c:   if ( value > ch->pcdata->security || value < 0 )
olc_act.c:   		if ( ch->pcdata->security != 0 )
olc_act.c:	    	sprintf( buf, "Security is 0-%d.\n\r", ch->pcdata->security );
olc_act.c:   pArea->security = value;                                                                                      
olc_act.c:    sprintf( buf, "Name:     [%5d] %s\n\r", pArea->vnum, pArea->name );
olc_act.c:    sprintf( buf, "File:     %s\n\r", pArea->file_name );
olc_act.c:    sprintf( buf, "Vnums:    [%d-%d]\n\r", pArea->min_vnum, pArea->max_vnum );
olc_act.c:	sprintf( buf, "Levels:   [%2d - %2d]\n\r", pArea->low_range, pArea->high_range);
olc_act.c:	sprintf( buf, "Age:      [%d]\n\r",	pArea->age );
olc_act.c:	sprintf( buf, "Type:     [%s]\n\r", area_type_table[pArea->area_type].name);
olc_act.c:	sprintf( buf, "Players:  [%d]\n\r", pArea->nplayer );
olc_act.c:    sprintf( buf, "Builders: [%s]\n\r", pArea->builders );
olc_act.c:	sprintf( buf, "Credits:  [%s]\n\r", pArea->credits );
olc_act.c:	sprintf( buf, "Security: [%d]\n\r", pArea->security );                                                        
olc_act.c:	sprintf( buf, "Climate:  [%s]\n\r", climate_table[pArea->climate].name);
olc_act.c:    sprintf( buf, "Flags:    [%s]\n\r", flag_string( area_flags, pArea->area_flags ) );
olc_act.c:	if (!IS_ZERO_VECTOR(pArea->progtypes))
olc_act.c:        if(IS_SET(pArea->progtypes, APROG_PULSE))
olc_act.c:        	sprintf(buf, " [pulse_prog] %s\n\r", pArea->aprogs->pulse_name);
olc_act.c:		if(IS_SET(pArea->progtypes, APROG_RESET))
olc_act.c:			sprintf(buf, " [reset_prog] %s\n\r", pArea->aprogs->reset_name);
olc_act.c:		if(IS_SET(pArea->progtypes, APROG_SUN))
olc_act.c:			sprintf(buf, " [sun_prog] %s\n\r", pArea->aprogs->sun_name);
olc_act.c:		if(IS_SET(pArea->progtypes, APROG_TICK))
olc_act.c:			sprintf(buf, " [tick_prog] %s\n\r", pArea->aprogs->tick_name);
olc_act.c:		if(IS_SET(pArea->progtypes, APROG_AGGRESS))
olc_act.c:			sprintf(buf, " [aggress_prog] %s\n\r", pArea->aprogs->aggress_name);
olc_act.c:		if(IS_SET(pArea->progtypes, APROG_MYELL))
olc_act.c:			sprintf(buf, " [myell_prog] %s\n\r", pArea->aprogs->myell_name);
olc_act.c:    area_last->next     =   pArea;
olc_act.c:    ch->desc->pEdit     =   (void *)pArea;
olc_act.c:    SET_BIT( pArea->area_flags, AREA_ADDED );
olc_act.c:    free_pstring( pArea->name );
olc_act.c:    pArea->name = palloc_string( argument );
olc_act.c:	free_pstring( pArea->credits );
olc_act.c:	pArea->credits = palloc_string( argument );
olc_act.c:    free_pstring( pArea->file_name );
olc_act.c:    pArea->file_name = palloc_string( file );
olc_act.c:	pArea->low_range = low;
olc_act.c:	pArea->high_range = high;
olc_act.c:    pArea->age = atoi( age );
olc_act.c:		send_to_char( "Syntax:  builder [$name]  -toggles builder\n\r", ch );
olc_act.c:		send_to_char( "Syntax:  builder All      -allows everyone\n\r", ch );
olc_act.c:    if ( strstr( pArea->builders, argument ) != '\0' )
olc_act.c:		pArea->builders = string_replace( pArea->builders, argument, "\0" );
olc_act.c:		pArea->builders = string_unpad( pArea->builders );
olc_act.c:		if ( pArea->builders[0] == '\0' )
olc_act.c:	    	free_pstring( pArea->builders );
olc_act.c:	    	pArea->builders = palloc_string( "None" );
olc_act.c:		if ( strstr( pArea->builders, "None" ) != '\0' )
olc_act.c:	    	pArea->builders = string_replace( pArea->builders, "None", "\0" );
olc_act.c:	    	pArea->builders = string_unpad( pArea->builders );
olc_act.c:		if (pArea->builders[0] != '\0' )
olc_act.c:	    	strcat( buf, pArea->builders );
olc_act.c:		free_pstring( pArea->builders );
olc_act.c:		pArea->builders = string_proper( palloc_string( buf ) );
olc_act.c:    pArea->min_vnum = ilower;
olc_act.c:    pArea->max_vnum = iupper;
olc_act.c:    if ( ( ilower = atoi( lower ) ) > ( iupper = pArea->max_vnum ) )
olc_act.c:    pArea->min_vnum = ilower;
olc_act.c:    if ( ( ilower = pArea->min_vnum ) > ( iupper = atoi( upper ) ) )
olc_act.c:    pArea->max_vnum = iupper;
olc_act.c:	return -1;
olc_act.c:		pArea->climate = icli;
olc_act.c:	pRoom->cabal = cabal;
olc_act.c:    pRoom->owner = palloc_string(argument);
olc_act.c:    sprintf( buf, "Description:\n\r%s", pRoom->description );
olc_act.c:	    pRoom->name, pRoom->area->vnum, pRoom->area->name );
olc_act.c:	    pRoom->vnum, flag_string_old( sector_flags, pRoom->sector_type ) );
olc_act.c:	sprintf( buf, "Cabal:      [%s]\n\r", cabal_table[pRoom->cabal].name);
olc_act.c:	sprintf( buf, "Owner:      [%s]\n\r", (pRoom->owner) ? pRoom->owner : "None");
olc_act.c:	    flag_string( room_flags, pRoom->room_flags ) );
olc_act.c:            pRoom->heal_rate , pRoom->mana_rate );
olc_act.c:	if(pRoom->trap)
olc_act.c:		sprintf(buf, " Type:          [%s]\n\r", flag_name_lookup( pRoom->trap->type, trap_table));
olc_act.c:		sprintf(buf, "%s Quality:       [%2d]\n\r", buf, pRoom->trap->quality);
olc_act.c:		sprintf(buf, "%s Complexity:    [%3d]\n\r", buf, pRoom->trap->complexity);
olc_act.c:		sprintf(buf, "%s Timer:         [%d seconds]\n\r", buf, pRoom->trap->timer);
olc_act.c:		sprintf(buf, "%s Trigger Echo:  [%s]\n\r", buf, (pRoom->trap->trig_echo != NULL) ? pRoom->trap->trig_echo : "None");
olc_act.c:		sprintf(buf, "%s Execute Echo:  [%s]\n\r", buf, (pRoom->trap->exec_echo != NULL) ? pRoom->trap->exec_echo : "None");
olc_act.c:	if (!IS_ZERO_VECTOR(pRoom->progtypes))
olc_act.c:		if(IS_SET(pRoom->progtypes, RPROG_PULSE))
olc_act.c:			sprintf(buf, " [pulse_prog] %s\n\r", pRoom->rprogs->pulse_name);
olc_act.c:		if(IS_SET(pRoom->progtypes, RPROG_ENTRY))
olc_act.c:			sprintf(buf," [entry_prog] %s\n\r", pRoom->rprogs->entry_name);
olc_act.c:		if(IS_SET(pRoom->progtypes, RPROG_MOVE))
olc_act.c:			sprintf(buf," [move_prog] %s\n\r", pRoom->rprogs->move_name);
olc_act.c:		if(IS_SET(pRoom->progtypes, RPROG_DROP))
olc_act.c:			sprintf(buf," [drop_prog] %s\n\r", pRoom->rprogs->drop_name);
olc_act.c:		if(IS_SET(pRoom->progtypes, RPROG_SPEECH))
olc_act.c:			sprintf(buf," [speech_prog] %s\n\r", pRoom->rprogs->speech_name);
olc_act.c:                if(IS_SET(pRoom->progtypes, RPROG_OPEN))
olc_act.c:                        sprintf(buf," [open_prog] %s\n\r", pRoom->rprogs->open_name);
olc_act.c:    if ( pRoom->extra_descr )
olc_act.c:	for ( ed = pRoom->extra_descr; ed; ed = ed->next )
olc_act.c:	    strcat( buf1, ed->keyword );
olc_act.c:	    if ( ed->next )
olc_act.c:    for ( rch = pRoom->people; rch; rch = rch->next_in_room )
olc_act.c:		one_argument( rch->name, buf );
olc_act.c:	end = strlen(buf1) - 1;
olc_act.c:    for ( obj = pRoom->contents; obj; obj = obj->next_content )
olc_act.c:	one_argument( obj->name, buf );
olc_act.c:	end = strlen(buf1) - 1;
olc_act.c:	if ( ( pexit = pRoom->exit[door] ) != NULL )
olc_act.c:	    sprintf( buf, "-%-5s to [%5d] Key: [%5d] ",
olc_act.c:		pexit->u1.to_room ? pexit->u1.to_room->vnum : 0,      /* ROM OLC */
olc_act.c:		pexit->key );
olc_act.c:	    state = flag_string( exit_flags, pexit->exit_info );
olc_act.c:		    end = strlen(buf1) - 1;
olc_act.c:	    if ( pexit->keyword && pexit->keyword[0] != '\0' )
olc_act.c:		sprintf( buf, "Kwds: [%s]\n\r", pexit->keyword );
olc_act.c:	    if ( pexit->description && pexit->description[0] != '\0' )
olc_act.c:		sprintf( buf, "%s", pexit->description );
olc_act.c:	send_to_char( "Syntax:  resets\n\r---- RESETS ----\n\r", ch);
olc_act.c:     * ----------------------------------------
olc_act.c:		if ( !pRoom->exit[door] )
olc_act.c:	 	/*   pRoom->exit[door] = new_exit(); */
olc_act.c:		TOGGLE_BIT(pRoom->exit[door]->exit_info, value);
olc_act.c:			pToRoom = pRoom->exit[door]->u1.to_room;     /* ROM OLC */
olc_act.c:			if (pToRoom->exit[rev] != NULL)
olc_act.c:	   			TOGGLE_BIT(pToRoom->exit[rev]->exit_info, value);
olc_act.c:		if ( !pRoom->exit[door] )
olc_act.c:		pToRoom = pRoom->exit[door]->u1.to_room;       /* ROM OLC */
olc_act.c:		if ( pToRoom->exit[rev] )
olc_act.c:	    	free_exit( pToRoom->exit[rev] );
olc_act.c:	    	pToRoom->exit[rev] = NULL;
olc_act.c:		free_exit( pRoom->exit[door] );
olc_act.c:		pRoom->exit[door] = NULL;
olc_act.c:	    	send_to_char( "REdit:  Cannot link to non-existant room.\n\r", ch );
olc_act.c:		if ( !IS_BUILDER( ch, get_room_index( value )->area ) )
olc_act.c:		if ( get_room_index( value )->exit[rev_dir[door]] )
olc_act.c:		if ( !pRoom->exit[door] )
olc_act.c:	    	pRoom->exit[door] = new_exit();
olc_act.c:		pRoom->exit[door]->u1.to_room = get_room_index( value );   /* ROM OLC */
olc_act.c:		pRoom->exit[door]->orig_door = door;
olc_act.c:		/*	pRoom->exit[door]->vnum = value;                Can't set vnum in ROM */
olc_act.c:		pExit->u1.to_room       = ch->in_room;
olc_act.c:		/*	pExit->vnum             = ch->in_room->vnum;    Can't set vnum in ROM */
olc_act.c:		pExit->orig_door	= door;
olc_act.c:		pRoom->exit[door]       = pExit;
olc_act.c:		send_to_char( "Two-way link established.\n\r", ch );
olc_act.c:			for( count = ch->in_room->area->min_vnum; count <= ch->in_room->area->max_vnum; count++)
olc_act.c:				send_to_char( "Syntax: [direction] dig        -- Assigns next available vnum\n\r"\
olc_act.c:	                          "        [direction] dig <vnum> -- Assigns that specific vnum\n\r", ch );
olc_act.c:		if ( !pRoom->exit[door] )
olc_act.c:	    	pRoom->exit[door] = new_exit();
olc_act.c:	    	send_to_char( "REdit:  Cannot link to non-existant room.\n\r", ch );
olc_act.c:		pRoom->exit[door]->u1.to_room = get_room_index( value );    /* ROM OLC */
olc_act.c:		pRoom->exit[door]->orig_door = door;
olc_act.c:		/*	pRoom->exit[door]->vnum = value;                 Can't set vnum in ROM */
olc_act.c:		send_to_char( "One-way link established.\n\r", ch );
olc_act.c:		if ( !pRoom->exit[door] )
olc_act.c:	    	pRoom->exit[door] = new_exit();
olc_act.c:		if ( get_obj_index( value )->item_type != ITEM_KEY )
olc_act.c:		pRoom->exit[door]->key = value;
olc_act.c:		if (!pRoom->exit[door]) {
olc_act.c:		if (!pRoom->exit[door]->u1.to_room) {
olc_act.c:		free_pstring(pRoom->exit[door]->u1.to_room->description);
olc_act.c:		pRoom->exit[door]->u1.to_room->description = palloc_string(pRoom->description);
olc_act.c:		if ( !pRoom->exit[door] )
olc_act.c:	    	pRoom->exit[door] = new_exit();
olc_act.c:		free_pstring( pRoom->exit[door]->keyword );
olc_act.c:		pRoom->exit[door]->keyword = palloc_string( arg );
olc_act.c:	    	if ( !pRoom->exit[door] )
olc_act.c:	        	pRoom->exit[door] = new_exit();
olc_act.c:	    	string_append( ch, &pRoom->exit[door]->description );
olc_act.c:	ed->keyword		=   palloc_string( keyword );
olc_act.c:	ed->description		=   palloc_string( "" );
olc_act.c:	ed->next		=   pRoom->extra_descr;
olc_act.c:	pRoom->extra_descr	=   ed;
olc_act.c:	string_append( ch, &ed->description );
olc_act.c:	for ( ed = pRoom->extra_descr; ed; ed = ed->next )
olc_act.c:	    if ( is_name( keyword, ed->keyword ) )
olc_act.c:	string_append( ch, &ed->description );
olc_act.c:	for ( ed = pRoom->extra_descr; ed; ed = ed->next )
olc_act.c:	    if ( is_name( keyword, ed->keyword ) )
olc_act.c:	    pRoom->extra_descr = ed->next;
olc_act.c:	    ped->next = ed->next;
olc_act.c:	for ( ed = pRoom->extra_descr; ed; ed = ed->next )
olc_act.c:	    if ( is_name( keyword, ed->keyword ) )
olc_act.c:	ed->description = format_string( ed->description );
olc_act.c:    pRoom->area			= pArea;
olc_act.c:    pRoom->vnum			= value;
olc_act.c:    pRoom->next			= room_index_hash[iHash];
olc_act.c:    ch->desc->pEdit		= (void *)pRoom;
olc_act.c:    free_pstring( pRoom->name );
olc_act.c:    pRoom->name = palloc_string( argument );
olc_act.c:	free_pstring(ch->in_room->description);
olc_act.c:	ch->in_room->description = palloc_string(ch->pcdata->entered_text);
olc_act.c:	ch->pcdata->entered_text[0] = '\0';
olc_act.c:		string_append( ch, &pRoom->description );
olc_act.c:          pRoom->heal_rate = atoi ( argument );
olc_act.c:          pRoom->mana_rate = atoi ( argument );
olc_act.c:    pRoom->description = format_string( pRoom->description );
olc_act.c:    if ( pMobIndex->area != pRoom->area )
olc_act.c:    pReset->command	= 'M';
olc_act.c:    pReset->arg1	= pMobIndex->vnum;
olc_act.c:    pReset->arg2	= is_number( arg2 ) ? atoi( arg2 ) : MAX_MOB;
olc_act.c:    pReset->arg3	= pRoom->vnum;
olc_act.c:    pReset->arg4	= is_number( argument ) ? atoi (argument) : 1;
olc_act.c:	capitalize( pMobIndex->short_descr ),
olc_act.c:	pMobIndex->vnum,
olc_act.c:	pReset->arg2 );
olc_act.c:        if ( IS_SET_OLD(bits, wear_table[flag].wear_bit) && --count < 1)
olc_act.c:	send_to_char ( "        -no_args               = into room\n\r", ch );
olc_act.c:	send_to_char ( "        -<obj_name>            = into obj\n\r", ch );
olc_act.c:	send_to_char ( "        -<mob_name> <wear_loc> = into mob\n\r", ch );
olc_act.c:    if ( pObjIndex->area != pRoom->area )
olc_act.c:	pReset->command	= 'O';
olc_act.c:	pReset->arg1	= pObjIndex->vnum;
olc_act.c:	pReset->arg2	= 0;
olc_act.c:	pReset->arg3	= pRoom->vnum;
olc_act.c:	pReset->arg4	= 0;
olc_act.c:	    capitalize( pObjIndex->short_descr ),
olc_act.c:	    pObjIndex->vnum );
olc_act.c:    && ( ( to_obj = get_obj_list( ch, arg2, pRoom->contents ) ) != NULL ) )
olc_act.c:		pReset->command	= 'P';
olc_act.c:		pReset->arg1	= pObjIndex->vnum;
olc_act.c:		pReset->arg2	= 0;
olc_act.c:		pReset->arg3	= to_obj->pIndexData->vnum;
olc_act.c:		pReset->arg4	= 1;
olc_act.c:		for(pReset1 = pRoom->reset_first; pReset1 != NULL; pReset1 = pReset1->next )
olc_act.c:			if(pReset1->command == 'O')
olc_act.c:				if(pReset1->arg1 == pReset->arg3)
olc_act.c:					pReset->next = pReset1;
olc_act.c:					pReset2->next = pReset;
olc_act.c:		newobj->cost = 0;
olc_act.c:		newobj->owner = palloc_string("none");
olc_act.c:	    capitalize( newobj->short_descr ),
olc_act.c:	    newobj->pIndexData->vnum,
olc_act.c:	    to_obj->short_descr,
olc_act.c:	    to_obj->pIndexData->vnum );
olc_act.c:	    send_to_char( "REdit: Invalid wear_loc.  '? wear-loc'\n\r", ch );
olc_act.c:	if ( !IS_SET( pObjIndex->wear_flags, wear_bit(wear_loc) ) )
olc_act.c:	        capitalize( pObjIndex->short_descr ),
olc_act.c:	        pObjIndex->vnum,
olc_act.c:		flag_string( wear_flags, pObjIndex->wear_flags ) );
olc_act.c:	pReset->arg1	= pObjIndex->vnum;
olc_act.c:	pReset->arg2	= wear_loc;
olc_act.c:	if ( pReset->arg2 == WEAR_NONE )
olc_act.c:	    pReset->command = 'G';
olc_act.c:	    pReset->command = 'E';
olc_act.c:	pReset->arg3	= wear_loc;
olc_act.c:	olevel  = URANGE( 0, to_mob->level - 2, LEVEL_HERO );
olc_act.c:	if ( to_mob->pIndexData->pShop )	/* Shop-keeper? */
olc_act.c:	    switch ( pObjIndex->item_type )
olc_act.c:	    case ITEM_WEAPON:	if ( pReset->command == 'G' )
olc_act.c:	    if ( pReset->arg2 == WEAR_NONE )
olc_act.c:		SET_BIT( newobj->extra_flags, ITEM_INVENTORY );
olc_act.c:	if ( pReset->command == 'E' )
olc_act.c:	    equip_char( to_mob, newobj, pReset->arg3, FALSE );
olc_act.c:	    capitalize( pObjIndex->short_descr ),
olc_act.c:	    pObjIndex->vnum,
olc_act.c:	    flag_string_old( wear_loc_strings, pReset->arg3 ),
olc_act.c:	    to_mob->short_descr,
olc_act.c:	    to_mob->pIndexData->vnum );
olc_act.c:    switch( obj->item_type )
olc_act.c:            if ( obj->value[2] == -1 || obj->value[2] == 999 ) /* ROM OLC */
olc_act.c:		sprintf( buf, "[v2] Light:  Infinite[-1]\n\r" );
olc_act.c:		sprintf( buf, "[v2] Light:  [%d]\n\r", obj->value[2] );
olc_act.c:		obj->value[0],
olc_act.c:		obj->value[1],
olc_act.c:		obj->value[2],
olc_act.c:		obj->value[3] != -1 ? skill_table[obj->value[3]].name
olc_act.c:	        obj->value[0],
olc_act.c:	        flag_string_old( exit_flags, obj->value[1]),
olc_act.c:	        flag_string_old( portal_flags , obj->value[2]),
olc_act.c:	        obj->value[3] );
olc_act.c:	        obj->value[0],
olc_act.c:	        obj->value[1],
olc_act.c:	        flag_string_old( furniture_flags, obj->value[2]),
olc_act.c:	        obj->value[3],
olc_act.c:	        obj->value[4] );
olc_act.c:		obj->value[0],
olc_act.c:		obj->value[1] != -1 ? skill_table[obj->value[1]].name
olc_act.c:		obj->value[2] != -1 ? skill_table[obj->value[2]].name
olc_act.c:		obj->value[3] != -1 ? skill_table[obj->value[3]].name
olc_act.c:		obj->value[4] != -1 ? skill_table[obj->value[4]].name
olc_act.c:		obj->value[0],
olc_act.c:		obj->value[1],
olc_act.c:		obj->value[2],
olc_act.c:		obj->value[3] );
olc_act.c:/* I had to split the output here, I have no idea why, but it helped -- Hugin */
olc_act.c:        sprintf( buf, "[v0] Weapon class:   %s\n\r", weapon_name_lookup(obj->value[0]));
olc_act.c:	    sprintf( buf, "[v1] Number of dice: [%d]\n\r", obj->value[1] );
olc_act.c:	    sprintf( buf, "[v2] Type of dice:   [%d]\n\r", obj->value[2] );
olc_act.c:	    sprintf( buf, "[v3] Type:           %s\n\r", attack_table[UMAX(0,obj->value[3])].name);
olc_act.c:		     flag_string_old( weapon_type2,  obj->value[4] ) );
olc_act.c:		obj->value[0],
olc_act.c:		cont_bit_name(obj->value[1]),
olc_act.c:                get_obj_index(obj->value[2])
olc_act.c:                    ? get_obj_index(obj->value[2])->short_descr
olc_act.c:                obj->value[2],
olc_act.c:                obj->value[3],
olc_act.c:                obj->value[4] );
olc_act.c:	        obj->value[0],
olc_act.c:	        obj->value[1],
olc_act.c:	        liq_table[obj->value[2]].liq_name,
olc_act.c:	        obj->value[3] != 0 ? "Yes" : "No" );
olc_act.c:	        obj->value[0],
olc_act.c:	        obj->value[1],
olc_act.c:	        liq_table[obj->value[2]].liq_name );
olc_act.c:		obj->value[0],
olc_act.c:		obj->value[1],
olc_act.c:		obj->value[3] != 0 ? "Yes" : "No" );
olc_act.c:            sprintf( buf, "[v0] Gold:   [%d]\n\r", obj->value[0] );
olc_act.c:    switch( pObj->item_type )
olc_act.c:	            pObj->value[2] = atoi( argument );
olc_act.c:	            pObj->value[0] = atoi( argument );
olc_act.c:	            pObj->value[1] = atoi( argument );
olc_act.c:	            pObj->value[2] = atoi( argument );
olc_act.c:	            pObj->value[3] = skill_lookup( argument );
olc_act.c:	            pObj->value[0] = atoi( argument );
olc_act.c:	            pObj->value[1] = skill_lookup( argument );
olc_act.c:	            pObj->value[2] = skill_lookup( argument );
olc_act.c:	            pObj->value[3] = skill_lookup( argument );
olc_act.c:	            pObj->value[4] = skill_lookup( argument );
olc_act.c:		    pObj->value[0] = atoi( argument );
olc_act.c:		    pObj->value[1] = atoi( argument );
olc_act.c:		    pObj->value[2] = atoi( argument );
olc_act.c:		    pObj->value[3] = atoi( argument );
olc_act.c:					pObj->value[0] = weapon_type("weapon");
olc_act.c:					pObj->value[0] = weapon_type(argument);
olc_act.c:	            pObj->value[1] = atoi( argument );
olc_act.c:	            pObj->value[2] = atoi( argument );
olc_act.c:				pObj->value[3] = attack_lookup(argument);
olc_act.c:					TOGGLE_BIT_OLD( pObj->value[4], value);
olc_act.c:	    	    pObj->value[0] = atoi ( argument );
olc_act.c:					TOGGLE_BIT_OLD(pObj->value[1], value);
olc_act.c:					TOGGLE_BIT_OLD(pObj->value[2], value);
olc_act.c:	    	    pObj->value[3] = atoi ( argument );
olc_act.c:	            pObj->value[0] = atoi ( argument );
olc_act.c:	            pObj->value[1] = atoi ( argument );
olc_act.c:					TOGGLE_BIT_OLD(pObj->value[2], value);
olc_act.c:	            pObj->value[3] = atoi ( argument );
olc_act.c:	            pObj->value[4] = atoi ( argument );
olc_act.c:	            pObj->value[0] = atoi( argument );
olc_act.c:	        	TOGGLE_BIT_OLD(pObj->value[1], value);
olc_act.c:			if ( get_obj_index( atoi( argument ) )->item_type != ITEM_KEY )
olc_act.c:		    pObj->value[2] = atoi( argument );
olc_act.c:		    pObj->value[3] = atoi( argument );
olc_act.c:		    pObj->value[4] = atoi ( argument );
olc_act.c:	            pObj->value[0] = atoi( argument );
olc_act.c:	            pObj->value[1] = atoi( argument );
olc_act.c:	            pObj->value[2] = ( liq_lookup(argument) != -1 ?
olc_act.c:	            pObj->value[3] = ( pObj->value[3] == 0 ) ? 1 : 0;
olc_act.c:	            pObj->value[0] = atoi( argument );
olc_act.c:	            pObj->value[1] = atoi( argument );
olc_act.c:	            pObj->value[2] = ( liq_lookup( argument ) != -1 ?
olc_act.c:	            pObj->value[0] = atoi( argument );
olc_act.c:	            pObj->value[1] = atoi( argument );
olc_act.c:	            pObj->value[3] = ( pObj->value[3] == 0 ) ? 1 : 0;
olc_act.c:	            pObj->value[0] = atoi( argument );
olc_act.c:		    pObj->value[1] = atoi( argument );
olc_act.c:	sprintf( buf, "Name:             [%s]\n\r",pObj->name);
olc_act.c:	sprintf( buf, "Short desc:       [%s]\n\r", pObj->short_descr );
olc_act.c:    sprintf( buf, "Long desc:        [%s]\n\r", pObj->description);
olc_act.c:	!pObj->area ? -1        : pObj->area->vnum,
olc_act.c:	!pObj->area ? "No Area" : pObj->area->name );
olc_act.c:    sprintf( buf, "Vnum:             [%5d]\n\r", pObj->vnum);
olc_act.c:	sprintf( buf, "Type:             [%s]\n\r", flag_string_old( type_flags, pObj->item_type ) );
olc_act.c:    sprintf( buf, "Level:            [%5d]\n\r", pObj->level );
olc_act.c:    sprintf( buf, "Wear flags:       [%s]\n\r", flag_string( wear_flags, pObj->wear_flags ) );
olc_act.c:	flag_string( extra_flags, pObj->extra_flags ) );
olc_act.c:	sprintf( buf, "Restrict flags:   [%s]\n\r", restrict_string( restrict_table, pObj->restrict_flags)); 
olc_act.c:    sprintf( buf, "Material:         [%s]\n\r", pObj->material );
olc_act.c:	sprintf( buf, "Condition:        [%5d]\n\r", pObj->condition );
olc_act.c:	sprintf( buf, "Weight:           [%5d]\n\r", pObj->weight);
olc_act.c:	sprintf( buf, "Cost:             [%5d]\n\r", pObj->cost );
olc_act.c:	sprintf( buf, "Object Limit:     [%d]\n\r", (pObj->limtotal > 0) ? pObj->limtotal : -1); 
olc_act.c:	sprintf( buf, "Timer:            [%d]\n\r", pObj->start_timer);                                                          
olc_act.c:    sprintf( buf, "Cabal:            [%s]\n\r", cabal_table[pObj->cabal].name);                                              
olc_act.c:	sprintf( buf, "Verb:             [%s]\n\r", (pObj->verb) ? pObj->verb : "none"); 
olc_act.c:	if(IS_SET(pObj->wear_flags, ITEM_WEAR_COSMETIC))
olc_act.c:		sprintf( buf, "Worn:             [\"%s\"]\n\r", pObj->wear_loc_name ? pObj->wear_loc_name : "Default - Needs Set");	
olc_act.c:	if(pObj->spec_prog.func)
olc_act.c:	     	if(ispec_table[i].spec_func == pObj->spec_prog.func)
olc_act.c:	if (!IS_ZERO_VECTOR(pObj->progtypes))
olc_act.c:		if(IS_SET(pObj->progtypes, IPROG_WEAR))
olc_act.c:			sprintf(buf, " [wear_prog] %s\n\r", pObj->iprogs->wear_name);
olc_act.c:		if(IS_SET(pObj->progtypes, IPROG_REMOVE))
olc_act.c:			sprintf(buf, " [remove_prog] %s\n\r", pObj->iprogs->remove_name);
olc_act.c:		if(IS_SET(pObj->progtypes, IPROG_DROP))
olc_act.c:			sprintf(buf, " [drop_prog] %s\n\r", pObj->iprogs->drop_name);
olc_act.c:		if(IS_SET(pObj->progtypes, IPROG_SAC))
olc_act.c:			sprintf(buf, " [sac_prog] %s\n\r", pObj->iprogs->sac_name);
olc_act.c:		if(IS_SET(pObj->progtypes, IPROG_GIVE))
olc_act.c:			sprintf(buf, " [give_prog] %s\n\r", pObj->iprogs->give_name);
olc_act.c:		if(IS_SET(pObj->progtypes, IPROG_GREET))
olc_act.c:			sprintf(buf, " [greet_prog] %s\n\r", pObj->iprogs->greet_name);
olc_act.c:		if(IS_SET(pObj->progtypes, IPROG_FIGHT))
olc_act.c:			sprintf(buf, " [fight_prog] %s\n\r", pObj->iprogs->fight_name);
olc_act.c:		if(IS_SET(pObj->progtypes, IPROG_DEATH))
olc_act.c:			sprintf(buf, " [death_prog] %s\n\r", pObj->iprogs->death_name);
olc_act.c:		if(IS_SET(pObj->progtypes, IPROG_SPEECH))
olc_act.c:			sprintf(buf, " [speech_prog] %s\n\r", pObj->iprogs->speech_name);
olc_act.c:		if(IS_SET(pObj->progtypes, IPROG_ENTRY))
olc_act.c:			sprintf(buf, " [entry_prog] %s\n\r", pObj->iprogs->entry_name);
olc_act.c:		if(IS_SET(pObj->progtypes, IPROG_GET))
olc_act.c:			sprintf(buf, " [get_prog] %s\n\r", pObj->iprogs->get_name);
olc_act.c:		if(IS_SET(pObj->progtypes, IPROG_PULSE))
olc_act.c:			sprintf(buf, " [pulse_prog] %s\n\r", pObj->iprogs->pulse_name);
olc_act.c:		if(IS_SET(pObj->progtypes, IPROG_INVOKE))
olc_act.c:			sprintf(buf, " [invoke_prog] %s\n\r", pObj->iprogs->invoke_name);
olc_act.c:		if(IS_SET(pObj->progtypes, IPROG_VERB))
olc_act.c:			sprintf(buf, " [verb_prog] %s\n\r", pObj->iprogs->verb_name);
olc_act.c:		if(IS_SET(pObj->progtypes, IPROG_LOOT))
olc_act.c:			sprintf(buf, " [loot_prog] %s\n\r", pObj->iprogs->loot_name);
olc_act.c:		if(IS_SET(pObj->progtypes, IPROG_OPEN))
olc_act.c:			sprintf(buf, " [open_prog] %s\n\r", pObj->iprogs->open_name);
olc_act.c:		if(IS_SET(pObj->progtypes, IPROG_LOOK))
olc_act.c:			sprintf(buf, " [look_prog] %s\n\r", pObj->iprogs->look_name);
olc_act.c:		if(IS_SET(pObj->progtypes, IPROG_HIT))
olc_act.c:			sprintf(buf, " [hit_prog] %s\n\r", pObj->iprogs->hit_name);
olc_act.c:	if ( pObj->wear_echo[0] || pObj->wear_echo[1])
olc_act.c:		if(pObj->wear_echo[0])
olc_act.c:			sprintf(buf," Character [%s]\n\r", pObj->wear_echo[0]);
olc_act.c:		if(pObj->wear_echo[1])
olc_act.c:			sprintf(buf,"      Room [%s]\n\r", pObj->wear_echo[1]);
olc_act.c:    if ( pObj->remove_echo[0] || pObj->remove_echo[1])                                                                
olc_act.c:        if(pObj->remove_echo[0])
olc_act.c:	    	sprintf(buf," Character [%s]\n\r", pObj->remove_echo[0]);
olc_act.c:	    if(pObj->remove_echo[1])
olc_act.c:	    	sprintf(buf,"      Room [%s]\n\r", pObj->remove_echo[1]);
olc_act.c:	if (pObj->notes != NULL)
olc_act.c:		sprintf(buf,"Notes: %s\n\r", pObj->notes);
olc_act.c:	if(!IS_ZERO_VECTOR(pObj->imm_flags) || !IS_ZERO_VECTOR(pObj->res_flags)
olc_act.c:	   || !IS_ZERO_VECTOR(pObj->vuln_flags) || pObj->charaffs)
olc_act.c:		if(!IS_ZERO_VECTOR(pObj->imm_flags))
olc_act.c:			sprintf(buf," IMM [%s]\n\r", flag_string(imm_flags, pObj->imm_flags));
olc_act.c:		if(!IS_ZERO_VECTOR(pObj->res_flags))
olc_act.c:			sprintf(buf," RES [%s]\n\r", flag_string(imm_flags, pObj->res_flags));
olc_act.c:		if(!IS_ZERO_VECTOR(pObj->vuln_flags))
olc_act.c:			sprintf(buf," VUL [%s]\n\r", flag_string(imm_flags, pObj->vuln_flags));
olc_act.c:		if(pObj->charaffs)
olc_act.c:			for (af = pObj->charaffs; af; af = af->next)
olc_act.c:				sprintf(buf,"%s[%s]\n\r", buf, skill_table[af->type].name);
olc_act.c:    if ( pObj->extra_descr )
olc_act.c:	for ( ed = pObj->extra_descr; ed; ed = ed->next )
olc_act.c:	    send_to_char( ed->keyword, ch );
olc_act.c:    for ( cnt = 0, paf = pObj->apply; paf; paf = paf->next )
olc_act.c:	    	send_to_char( "------ -------- -------\n\r", ch );
olc_act.c:		sprintf( buf, "[%4d] %-8d %s\n\r", cnt,
olc_act.c:	    		paf->modifier,
olc_act.c:	    		flag_string_old( apply_flags, paf->location ) );
olc_act.c: * Need to issue warning if flag isn't valid. -- does so now -- Hugin.
olc_act.c:	if ( (value = display_lookup(loc,apply_locations)) == -1)
olc_act.c:    pAf->location   =   value;
olc_act.c:    pAf->modifier   =   atoi( mod );
olc_act.c:    pAf->next       =   pObj->apply;
olc_act.c:    pObj->apply  	=   pAf;
olc_act.c:    pAf->location   =   value;
olc_act.c:    pAf->modifier   =   atoi( mod );
olc_act.c:    pAf->type       =   (value3 == NO_FLAG) ? -1 : skill_lookup(value2);
olc_act.c:    pAf->duration   =   -1;
olc_act.c:    pAf->bitvector  =   (value3 == NO_FLAG) ? 0 : value3;
olc_act.c:    pAf->where	    =	0;
olc_act.c:    pAf->next       =   pObj->affected;
olc_act.c:    pObj->affected  =   pAf;
olc_act.c:		send_to_char( "Only non-negative apply-numbers allowed.\n\r", ch );
olc_act.c:    if ( !( pAf = pObj->apply ) )
olc_act.c:		send_to_char( "OEdit:  Non-existant apply.\n\r", ch );
olc_act.c:		pAf = pObj->apply;
olc_act.c:		pObj->apply = pAf->next;
olc_act.c:		while ( ( pAf_next = pAf->next ) && ( ++cnt < value ) )
olc_act.c:	    pAf->next = pAf_next->next;
olc_act.c:			if(pObj->wear_echo[0])
olc_act.c:				free_pstring(pObj->wear_echo[0]);
olc_act.c:	            pObj->wear_echo[0] = palloc_string(argument);
olc_act.c:			if(pObj->wear_echo[1])
olc_act.c:				free_pstring(pObj->wear_echo[1]);
olc_act.c:	            pObj->wear_echo[1] = palloc_string(argument);
olc_act.c:			if(pObj->remove_echo[0])
olc_act.c:				free_pstring(pObj->remove_echo[0]);
olc_act.c:				pObj->remove_echo[0] = palloc_string(argument);
olc_act.c:			if(pObj->remove_echo[1])
olc_act.c:				free_pstring(pObj->remove_echo[1]);
olc_act.c:				pObj->remove_echo[1] = palloc_string(argument);
olc_act.c:	if((num = atoi(argument)) == -1)
olc_act.c:	pObj->limtotal = num;
olc_act.c:	pObj->verb = palloc_string(argument);
olc_act.c:	pObj->cabal = cabal;
olc_act.c:					 "         -1 is no timer and 0 is one tick.\n\r", ch);
olc_act.c:		send_to_char("Timer must be a number greater than -1.\n\r", ch);
olc_act.c:	pObj->start_timer = num;
olc_act.c:	TOGGLE_BIT(pObj->restrict_flags, bit);
olc_act.c:	string_append( ch, &pObj->notes );
olc_act.c:	pObj->wear_loc_name = palloc_string(argument);
olc_act.c:			TOGGLE_BIT(pObj->imm_flags, bit);
olc_act.c:			TOGGLE_BIT(pObj->res_flags, bit);
olc_act.c:			TOGGLE_BIT(pObj->vuln_flags, bit);
olc_act.c:		if(skill_lookup(arg2) == -1)
olc_act.c:			for(af = pObj->charaffs; af != NULL; af = af->next)
olc_act.c:				if(af->type == skill_lookup(arg2))
olc_act.c:			if(af == NULL || skill_lookup(arg2) == -1)
olc_act.c:		pAf.level = pObj->level;
olc_act.c:    free_pstring( pObj->name );
olc_act.c:    pObj->name = palloc_string( argument );
olc_act.c:    free_pstring( pObj->short_descr );
olc_act.c:    pObj->short_descr = palloc_string( argument );
olc_act.c:    pObj->short_descr[0] = LOWER( pObj->short_descr[0] );
olc_act.c:    free_pstring( pObj->description );
olc_act.c:    pObj->description = palloc_string( argument );
olc_act.c:    pObj->description[0] = UPPER( pObj->description[0] );
olc_act.c:	set_obj_values( ch, pObj, -1, "" );     /* '\0' changed to "" -- Hugin */
olc_act.c: Called by:	The four valueX functions below. (now five -- Hugin )
olc_act.c:    pObj->weight = atoi( argument );
olc_act.c:    pObj->cost = atoi( argument );
olc_act.c:    pObj->vnum			= value;
olc_act.c:    pObj->area			= pArea;
olc_act.c:    pObj->next			= obj_index_hash[iHash];
olc_act.c:    ch->desc->pEdit		= (void *)pObj;
olc_act.c:	ed->keyword         =   palloc_string( keyword );
olc_act.c:	ed->next            =   pObj->extra_descr;
olc_act.c:	pObj->extra_descr   =   ed;
olc_act.c:	string_append( ch, &ed->description );
olc_act.c:	for ( ed = pObj->extra_descr; ed; ed = ed->next )
olc_act.c:	    if ( is_name( keyword, ed->keyword ) )
olc_act.c:	string_append( ch, &ed->description );
olc_act.c:	for ( ed = pObj->extra_descr; ed; ed = ed->next )
olc_act.c:	    if ( is_name( keyword, ed->keyword ) )
olc_act.c:	    pObj->extra_descr = ed->next;
olc_act.c:	    ped->next = ed->next;
olc_act.c:	for ( ed = pObj->extra_descr; ed; ed = ed->next )
olc_act.c:	    if ( is_name( keyword, ed->keyword ) )
olc_act.c:	ed->description = format_string( ed->description );
olc_act.c:OEDIT( oedit_extra )      /* Moved out of oedit() due to naming conflicts -- Hugin */
olc_act.c:	    TOGGLE_BIT(pObj->extra_flags, value);
olc_act.c:OEDIT( oedit_wear )      /* Moved out of oedit() due to naming conflicts -- Hugin */
olc_act.c:	    TOGGLE_BIT(pObj->wear_flags, value);
olc_act.c:OEDIT( oedit_type )      /* Moved out of oedit() due to naming conflicts -- Hugin */
olc_act.c:	    pObj->item_type = value;
olc_act.c:	    pObj->value[0] = 0;
olc_act.c:	    pObj->value[1] = 0;
olc_act.c:	    pObj->value[2] = 0;
olc_act.c:	    pObj->value[3] = 0;
olc_act.c:	    pObj->value[4] = 0;     /* ROM */
olc_act.c:    free_pstring( pObj->material );
olc_act.c:    pObj->material = palloc_string( argument );
olc_act.c:	    pObj->material = material_name(value);
olc_act.c:    send_to_char( "Syntax:  material [material-name]\n\r"
olc_act.c:    pObj->level = atoi( argument );
olc_act.c:	pObj->condition = value;
olc_act.c:	if((low = atoi(arg1)) == -1 || (high = atoi(arg2)) == -1)
olc_act.c:	pMob->restrict_low = low;
olc_act.c:	pMob->restrict_high = high;
olc_act.c:				pMob->affect_sn[sn]=-1;
olc_act.c:				pMob->affect_bit[sn]=0;
olc_act.c:		if((sn = skill_lookup(arg2)) == -1)
olc_act.c:				if(pMob->affect_sn[i]<1)                                                                 
olc_act.c:					pMob->affect_sn[i]=sn;                                                               
olc_act.c:					pMob->affect_bit[i]=bit;
olc_act.c:		if(pMob->barred_entry)
olc_act.c:				pMob->barred_entry = NULL;
olc_act.c:				delete pMob->barred_entry;
olc_act.c:		bar->type = flag_lookup(arg2,criterion_flags);
olc_act.c:		if(bar->type == NO_FLAG)
olc_act.c:		bar->comparison = -1;
olc_act.c:			bar->comparison = BAR_EQUAL_TO;
olc_act.c:			bar->comparison = BAR_LESS_THAN;
olc_act.c:			bar->comparison = BAR_GREATER_THAN;
olc_act.c:		if(bar->type == 1)
olc_act.c:			bar->value = CClass::Lookup(arg4);
olc_act.c:			bar->value = atoi(arg4);
olc_act.c:		if(bar->value == -1)
olc_act.c:		if((bar->vnum = atoi(arg5)) == -1)
olc_act.c:			bar->msg_type = BAR_SAY;
olc_act.c:			bar->msg_type = BAR_EMOTE;
olc_act.c:			bar->msg_type = BAR_ECHO;
olc_act.c:			bar->message = palloc_string(arg7);
olc_act.c:			bar->message_two = palloc_string(argument);
olc_act.c:			if(!str_cmp(bar->message_two,""))
olc_act.c:				bar->message_two = NULL;
olc_act.c:			pMob->barred_entry = bar;
olc_act.c:		bar->message = palloc_string(argument);
olc_act.c:		pMob->barred_entry = bar;
olc_act.c:				free_pstring(pMob->cast_spell[sn]);
olc_act.c:				free_pstring(pMob->cast_spell[sn] = NULL);
olc_act.c:		if((sn = skill_lookup(arg2)) == -1)
olc_act.c:				if(pMob->cast_spell[i]==NULL)
olc_act.c:					pMob->cast_spell[i] = palloc_string(arg2);
olc_act.c:	pMob->attack_yell = palloc_string(argument);
olc_act.c:    string_append( ch, &pMob->notes );
olc_act.c:		pMob->ele_major = 0;
olc_act.c:		pMob->ele_para = 0;
olc_act.c:		zero_vector(pMob->styles);
olc_act.c:	pMob->SetClass(class_index);
olc_act.c:		if((style_count(pMob->styles) >= 2) && !IS_SET(pMob->styles, style_table[style].bit))
olc_act.c:		TOGGLE_BIT(pMob->styles, style_table[style].bit);
olc_act.c:		if(IS_ZERO_VECTOR(pMob->styles))
olc_act.c:			pMob->SetClass(CLASS_NONE);
olc_act.c:			pMob->ele_major = style;
olc_act.c:			pMob->ele_para = style;
olc_act.c:		if(pMob->ele_major==ELE_NONE && 
olc_act.c:		   pMob->ele_para==ELE_NONE)
olc_act.c:			pMob->SetClass(CLASS_NONE);
olc_act.c:	pMob->player_name,
olc_act.c:	!pMob->area ? -1        : pMob->area->vnum,
olc_act.c:	!pMob->area ? "No Area" : pMob->area->name );
olc_act.c:	sprintf( buf, "Cabal:       [%s]\n\r", cabal_table[pMob->cabal].name);
olc_act.c:	flag_string( act_flags, pMob->act ) );
olc_act.c:	pMob->vnum,
olc_act.c:	pMob->sex == SEX_MALE    ? "male"   :
olc_act.c:	pMob->sex == SEX_FEMALE  ? "female" :
olc_act.c:	pMob->sex == 3           ? "random" : "neutral" );  /* ROM magic number */
olc_act.c:	race_table[pMob->race].name );
olc_act.c:	if(pMob->Class()->GetIndex() != CLASS_NONE)
olc_act.c:		sprintf(buf,"Class:       [%s]\n\r", (RSTR)pMob->Class()->name);
olc_act.c:		if(pMob->Class()->GetIndex() == CLASS_WARRIOR)
olc_act.c:			sprintf(buf,"-Styles:     [%s]\n\r", style_string(style_table, pMob->styles));
olc_act.c:		else if(pMob->Class()->GetIndex() == CLASS_SORCERER)
olc_act.c:			sprintf(buf,"-Major:      [%s]\n\r"\
olc_act.c:						"-Para:       [%s]\n\r", 
olc_act.c:						sphere_table[pMob->ele_major].name,
olc_act.c:						sphere_table[pMob->ele_para].name);
olc_act.c:	pMob->level,       pMob->alignment );
olc_act.c:             pMob->hitroll );
olc_act.c:    	     attack_table[pMob->dam_type].name );
olc_act.c:    sprintf( buf, "Hitdice:     [%2dd%-3d+%4d]\n\r",
olc_act.c:	     pMob->hit[DICE_NUMBER],
olc_act.c:	     pMob->hit[DICE_TYPE],
olc_act.c:	     pMob->hit[DICE_BONUS] );
olc_act.c:    sprintf( buf, "Damdice:     [%2dd%-3d+%4d]\n\r",
olc_act.c:	     pMob->damage[DICE_NUMBER],
olc_act.c:	     pMob->damage[DICE_TYPE],
olc_act.c:	     pMob->damage[DICE_BONUS] );
olc_act.c:	flag_string( affect_flags, pMob->affected_by ) );
olc_act.c:	pMob->ac[AC_PIERCE], pMob->ac[AC_BASH],
olc_act.c:	pMob->ac[AC_SLASH], pMob->ac[AC_EXOTIC] );
olc_act.c:	flag_string( form_flags, pMob->form ) );
olc_act.c:	flag_string( part_flags, pMob->parts ) );
olc_act.c:	flag_string( imm_flags, pMob->imm_flags ) );
olc_act.c:	flag_string( res_flags, pMob->res_flags ) );
olc_act.c:	flag_string( vuln_flags, pMob->vuln_flags ) );
olc_act.c:	flag_string( off_flags,  pMob->off_flags ) );
olc_act.c:	flag_string_old( size_flags, pMob->size ) );
olc_act.c:	flag_string_old( position_flags, pMob->start_pos ) );
olc_act.c:	flag_name_lookup(pMob->wealth, wealth_table));
olc_act.c:	pMob->short_descr,
olc_act.c:	pMob->long_descr );
olc_act.c:    sprintf( buf, "Description:\n\r%s", pMob->description );
olc_act.c:	if(pMob->notes)
olc_act.c:		sprintf(buf, "Notes:\n\r%s\n\r", pMob->notes);
olc_act.c:	if(pMob->attack_yell)
olc_act.c:	 	sprintf(buf, "Attack yell: [%s]\n\r", pMob->attack_yell);
olc_act.c:    if ( pMob->pShop )
olc_act.c:		pShop = pMob->pShop;
olc_act.c:	    pShop->open_hour, pShop->close_hour );
olc_act.c:	if((pMob->restrict_low != LOW_VNUM) && (pMob->restrict_high != HIGH_VNUM))
olc_act.c:		sprintf(buf,"Limit:       [%d-%d]\n\r", pMob->restrict_low, pMob->restrict_high);
olc_act.c:        if (pMob->affect_sn[i] > -1)
olc_act.c:            sprintf(buf," [%2d] '%s' %s\n", i, skill_table[pMob->affect_sn[i]].name,                                   
olc_act.c:	                flag_name_lookup(pMob->affect_bit[i],affect_flags));
olc_act.c:        if (pMob->cast_spell[i])
olc_act.c:            sprintf(buf," [%2d] '%s'\n\r", i, pMob->cast_spell[i]);
olc_act.c:	if(pMob->barred_entry)
olc_act.c:		switch(pMob->barred_entry->comparison) 
olc_act.c:		switch(pMob->barred_entry->msg_type) 
olc_act.c:		sprintf(buf," Check Type:   [%s]\n\r", flag_name_lookup(pMob->barred_entry->type, criterion_flags));
olc_act.c:		sprintf(buf," Value:        [%d]\n\r", pMob->barred_entry->value);
olc_act.c:        sprintf(buf," Target Vnum:  [%d]\n\r", pMob->barred_entry->vnum);
olc_act.c:		if(pMob->barred_entry->msg_type == BAR_ECHO)
olc_act.c:			sprintf(buf," Message to:   [%s]\n\r", pMob->barred_entry->message);
olc_act.c:			sprintf(buf," Message room: [%s]\n\r", pMob->barred_entry->message_two);
olc_act.c:			sprintf(buf," Message:      [%s]\n\r", pMob->barred_entry->message);
olc_act.c:	if (pMob->pShop)
olc_act.c:					 " Direction: [%s]\n\r", pMob->pShop->open_hour,
olc_act.c:				pMob->pShop->close_hour, flag_name_lookup(pMob->pShop->direction, direction_table));
olc_act.c:	if (!IS_ZERO_VECTOR(pMob->progtypes))
olc_act.c:		if(IS_SET(pMob->progtypes, MPROG_BRIBE))
olc_act.c:			sprintf(buf, " [bribe_prog] %s\n\r", pMob->mprogs->bribe_name);
olc_act.c:		if(IS_SET(pMob->progtypes, MPROG_ENTRY))
olc_act.c:			sprintf(buf, " [entry_prog] %s\n\r", pMob->mprogs->entry_name);
olc_act.c:		if(IS_SET(pMob->progtypes, MPROG_GREET))
olc_act.c:			sprintf(buf, " [greet_prog] %s\n\r", pMob->mprogs->greet_name);
olc_act.c:		if(IS_SET(pMob->progtypes, MPROG_FIGHT))
olc_act.c:			sprintf(buf, " [fight_prog] %s\n\r", pMob->mprogs->fight_name);
olc_act.c:		if(IS_SET(pMob->progtypes, MPROG_DEATH))
olc_act.c:			sprintf(buf, " [death_prog] %s\n\r", pMob->mprogs->death_name);
olc_act.c:		if(IS_SET(pMob->progtypes, MPROG_BEAT))
olc_act.c:			sprintf(buf, " [beat_prog] %s\n\r", pMob->mprogs->beat_name);
olc_act.c:		if(IS_SET(pMob->progtypes, MPROG_PULSE))
olc_act.c:			sprintf(buf, " [pulse_prog] %s\n\r", pMob->mprogs->pulse_name);
olc_act.c:		if(IS_SET(pMob->progtypes, MPROG_SPEECH))
olc_act.c:			sprintf(buf, " [speech_prog] %s\n\r", pMob->mprogs->speech_name);
olc_act.c:		if(IS_SET(pMob->progtypes, MPROG_GIVE))
olc_act.c:			sprintf(buf, " [give_prog] %s\n\r", pMob->mprogs->give_name);
olc_act.c:		if(IS_SET(pMob->progtypes, MPROG_ATTACK))
olc_act.c:			sprintf(buf, " [attack_prog] %s\n\r", pMob->mprogs->attack_name);
olc_act.c:		if(IS_SET(pMob->progtypes, MPROG_AGGRESS))
olc_act.c:			sprintf(buf, " [aggress_prog] %s\n\r", pMob->mprogs->aggress_name);
olc_act.c:		if(IS_SET(pMob->progtypes, MPROG_MOVE))
olc_act.c:			sprintf(buf, " [move_prog] %s\n\r", pMob->mprogs->move_name);
olc_act.c:    pMob->vnum			= value;
olc_act.c:    pMob->area			= pArea;
olc_act.c:    SET_BIT(pMob->act, ACT_IS_NPC);
olc_act.c:    pMob->next			= mob_index_hash[iHash];
olc_act.c:    ch->desc->pEdit		= (void *)pMob;
olc_act.c:        pMob->spec_fun = NULL;
olc_act.c:	pMob->spec_fun = spec_lookup( argument );
olc_act.c:	pMob->dam_type = value;
olc_act.c:    pMob->alignment = atoi( argument );
olc_act.c:    pMob->level = atoi( argument );
olc_act.c:	pMob->hit[DICE_NUMBER] = (pMob->level/2);
olc_act.c:	pMob->hit[DICE_TYPE] = 8;
olc_act.c:	pMob->hit[DICE_BONUS] = (int)pow((double)((double)pMob->level/(double)5),(double)((double)pMob->level/(double)20)) + (int)(pow(pMob->level,2) * 3 / 2);
olc_act.c:	send_to_char( "Auto-hitdice Set.\n\r", ch);
olc_act.c:	string_append( ch, &pMob->description );
olc_act.c:    send_to_char( "Syntax:  desc    - line edit\n\r", ch );
olc_act.c:    free_pstring( pMob->long_descr );
olc_act.c:    pMob->long_descr = palloc_string( argument );
olc_act.c:    pMob->long_descr[0] = UPPER( pMob->long_descr[0]  );
olc_act.c:    free_pstring( pMob->short_descr );
olc_act.c:    pMob->short_descr = palloc_string( argument );
olc_act.c:    free_pstring( pMob->player_name );
olc_act.c:    pMob->player_name = palloc_string( argument );
olc_act.c:	pMob->cabal = cabal;
olc_act.c:		free_shop(pMob->pShop);
olc_act.c:		pMob->pShop = NULL;
olc_act.c:	if ( !pMob->pShop )
olc_act.c:		pMob->pShop         = pShop;
olc_act.c:        pShop->pMobIndex    = pMob;
olc_act.c:	pMob->pShop->open_hour = atoi( arg1 );
olc_act.c:	pMob->pShop->close_hour = atoi( arg2 );
olc_act.c:	pMob->pShop->direction = direction;
olc_act.c:MEDIT( medit_sex )          /* Moved out of medit() due to naming conflicts -- Hugin */
olc_act.c:	    pMob->sex = value;
olc_act.c:MEDIT( medit_act )          /* Moved out of medit() due to naming conflicts -- Hugin */
olc_act.c:	    TOGGLE_BIT(pMob->act, value);
olc_act.c:	    SET_BIT( pMob->act, ACT_IS_NPC );
olc_act.c:MEDIT( medit_affect )      /* Moved out of medit() due to naming conflicts -- Hugin */
olc_act.c:	    TOGGLE_BIT(pMob->affected_by, value);
olc_act.c:	    bash = pMob->ac[AC_BASH];
olc_act.c:	    slash = pMob->ac[AC_SLASH];
olc_act.c:	    exotic = pMob->ac[AC_EXOTIC];
olc_act.c:	pMob->ac[AC_PIERCE] = pierce;
olc_act.c:	pMob->ac[AC_BASH]   = bash;
olc_act.c:	pMob->ac[AC_SLASH]  = slash;
olc_act.c:	pMob->ac[AC_EXOTIC] = exotic;
olc_act.c:    send_to_char( "Syntax:  ac [ac-pierce [ac-bash [ac-slash [ac-exotic]]]]\n\r"
olc_act.c:		  "help MOB_AC  gives a list of reasonable ac-values.\n\r", ch );
olc_act.c:	    TOGGLE_BIT(pMob->form, value);
olc_act.c:	    TOGGLE_BIT(pMob->parts, value);
olc_act.c:	    TOGGLE_BIT(pMob->imm_flags,value);
olc_act.c:	    TOGGLE_BIT(pMob->res_flags, value);
olc_act.c:	    TOGGLE_BIT(pMob->vuln_flags, value);
olc_act.c:        pMob->material = material_name(value);
olc_act.c:	    TOGGLE_BIT(pMob->off_flags, value);
olc_act.c:	    pMob->size = value;
olc_act.c:    pMob->hit[DICE_NUMBER] = atoi( num   );
olc_act.c:    pMob->hit[DICE_TYPE]   = atoi( type  );
olc_act.c:    pMob->hit[DICE_BONUS]  = atoi( bonus );
olc_act.c:    pMob->mana[DICE_NUMBER] = atoi( num   );
olc_act.c:    pMob->mana[DICE_TYPE]   = atoi( type  );
olc_act.c:    pMob->mana[DICE_BONUS]  = atoi( bonus );
olc_act.c:    pMob->damage[DICE_NUMBER] = atoi( num   );
olc_act.c:    pMob->damage[DICE_TYPE]   = atoi( type  );
olc_act.c:    pMob->damage[DICE_BONUS]  = atoi( bonus );
olc_act.c:    && ( race = race_lookup( argument ) ) != -1 )
olc_act.c:	pMob->race = race;
olc_act.c:	BITWISE_OR(pMob->off_flags, race_data_lookup(race)->off);
olc_act.c:	BITWISE_OR(pMob->imm_flags, race_data_lookup(race)->imm);
olc_act.c:	BITWISE_OR(pMob->res_flags, race_data_lookup(race)->res);
olc_act.c:	BITWISE_OR(pMob->vuln_flags, race_data_lookup(race)->vuln);
olc_act.c:	BITWISE_OR(pMob->form, race_data_lookup(race)->form);
olc_act.c:	BITWISE_OR(pMob->parts, race_data_lookup(race)->parts);
olc_act.c:	    sprintf( buf, " %-15s", race_table[race].name );
olc_act.c:	if ( ( value = position_lookup(arg) ) == -1 )
olc_act.c:	pMob->start_pos = value;
olc_act.c:	pMob->wealth = index;
olc_act.c:    pMob->hitroll = atoi( argument );
olc_act.c:	sprintf(buf, "%-20s %-14s %5d %4d %6d %4d %5d\n\r",
olc_save.c: *  and has been used here for OLC - OLC would not be what it is without   *
olc_save.c: * -If a good syntax checker is used for setting vnum ranges of areas
olc_save.c:	REMOVE_BIT( pArea->area_flags, AREA_CHANGED );
olc_save.c:	REMOVE_BIT( pArea->area_flags, AREA_LOADING );
olc_save.c:	REMOVE_BIT( pArea->area_flags, AREA_ADDED);
olc_save.c:		for( pArea = area_first; pArea; pArea = pArea->next )
olc_save.c:	    	fprintf( fp, "%s\n", pArea->file_name );
olc_save.c: * -- Hugin
olc_save.c:    /* 32 -- number of bits in a long */
olc_save.c:	    if ( offset <= 'Z' - 'A' )
olc_save.c:		*(cp++) = 'a' + offset - ( 'Z' - 'A' + 1 );
olc_save.c: Purpose:	Save one mobile to file, new format -- Hugin
olc_save.c:fprintf(fp,"#%d\n", pMobIndex->vnum);
olc_save.c:fprintf(fp,"%s~\n", pMobIndex->player_name);
olc_save.c:fprintf(fp,"%s~\n%s~\n", pMobIndex->short_descr,
olc_save.c:munch(pMobIndex->long_descr));
olc_save.c:fprintf(fp,"%s~\n", munch(pMobIndex->description));
olc_save.c:fprintf(fp,"%d %d %d %s~\n", pMobIndex->alignment, pMobIndex->group,
olc_save.c:pMobIndex->xp_mod, race_table[pMobIndex->race].name);
olc_save.c:fprintf(fp,"%d %dd%d+%d %dd%d+%d %d %d %s\n", pMobIndex->level,
olc_save.c:    pMobIndex->hit[DICE_NUMBER], pMobIndex->hit[DICE_TYPE],
olc_save.c:    pMobIndex->hit[DICE_BONUS], pMobIndex->damage[DICE_NUMBER],
olc_save.c:    pMobIndex->damage[DICE_TYPE], pMobIndex->damage[DICE_BONUS],
olc_save.c:    pMobIndex->hitroll, (int)pMobIndex->dam_mod,
olc_save.c:    attack_table[pMobIndex->dam_type].name);
olc_save.c:    fprintf(fp,"%d %d %d %d\n", pMobIndex->ac[AC_PIERCE], pMobIndex->ac[AC_BASH],
olc_save.c:    pMobIndex->ac[AC_SLASH], pMobIndex->ac[AC_EXOTIC]);
olc_save.c:    fprintf(fp,"%s %s ", position_table[UMAX(pMobIndex->start_pos,0)].name,
olc_save.c:    sex_table[UMAX(pMobIndex->sex,1)].name);
olc_save.c:	fprintf(fp,"%s\n", wealth_lookup(pMobIndex->wealth));
olc_save.c:    copy_vector(dummy, pMobIndex->form);
olc_save.c:	BITWISE_XAND(dummy, race_data_lookup(pMobIndex->race)->form);
olc_save.c:	copy_vector(dummy2, pMobIndex->parts);
olc_save.c:	BITWISE_XAND(dummy2, race_data_lookup(pMobIndex->race)->parts);
olc_save.c:    size_table[UMAX(pMobIndex->size,0)].name);
olc_save.c:		if(IS_SET(pMobIndex->act, i) && !IS_SET(race_data_lookup(pMobIndex->race)->act, i))
olc_save.c:		if(IS_SET(pMobIndex->off_flags,i) && !IS_SET(race_data_lookup(pMobIndex->race)->off,i))
olc_save.c:		if(IS_SET(pMobIndex->affected_by, i) && !IS_SET(race_data_lookup(pMobIndex->race)->aff,i))
olc_save.c:		if(IS_SET(pMobIndex->imm_flags, i) && !IS_SET(race_data_lookup(pMobIndex->race)->imm,i))
olc_save.c:		if(IS_SET(pMobIndex->res_flags, i) && !IS_SET(race_data_lookup(pMobIndex->race)->res,i))
olc_save.c:		if(IS_SET(pMobIndex->vuln_flags, i) && !IS_SET(race_data_lookup(pMobIndex->race)->vuln,i))
olc_save.c:	if (pMobIndex->Class()->GetIndex() != CLASS_NONE) {
olc_save.c:		fprintf(fp,"CLASS %s ", (RSTR)pMobIndex->Class()->name);
olc_save.c:		switch(pMobIndex->Class()->GetIndex()) {
olc_save.c:					if(IS_SET(pMobIndex->styles, style_table[i].bit)) {
olc_save.c:				fprintf(fp,"%s %s",sphere_table[pMobIndex->ele_major].name,
olc_save.c:					sphere_table[pMobIndex->ele_para].name);
olc_save.c:	if(pMobIndex->restrict_low != -1 && pMobIndex->restrict_high != 65535)
olc_save.c:		fprintf(fp,"LIMIT %d %d\n",pMobIndex->restrict_low,pMobIndex->restrict_high);
olc_save.c:	if(pMobIndex->attack_yell)
olc_save.c:		fprintf(fp,"YELL %s~\n", pMobIndex->attack_yell);
olc_save.c:	if(pMobIndex->pShop)
olc_save.c:		fprintf(fp,"SHOPKEEPER OPEN %d CLOSE %d EXIT %s\n", pMobIndex->pShop->open_hour, pMobIndex->pShop->close_hour,
olc_save.c:				direction_table[pMobIndex->pShop->direction].name);
olc_save.c:	if(pMobIndex->cabal)
olc_save.c:		fprintf(fp,"CABAL %s\n", cabal_table[pMobIndex->cabal].name);
olc_save.c:	if (pMobIndex->notes)
olc_save.c:		fprintf(fp,"NOTES %s~\n", pMobIndex->notes);
olc_save.c:	if (pMobIndex->barred_entry) {
olc_save.c:		switch(pMobIndex->barred_entry->comparison) {
olc_save.c:		switch(pMobIndex->barred_entry->msg_type) {
olc_save.c:			flag_name_lookup(pMobIndex->barred_entry->type, criterion_flags),
olc_save.c:			pMobIndex->barred_entry->value,
olc_save.c:			pMobIndex->barred_entry->vnum,
olc_save.c:			pMobIndex->barred_entry->message,
olc_save.c:			(pMobIndex->barred_entry->message_two
olc_save.c:			&& pMobIndex->barred_entry->msg_type == BAR_ECHO) ? 
olc_save.c:				pMobIndex->barred_entry->message_two : "",
olc_save.c:			(pMobIndex->barred_entry->message_two
olc_save.c:			&& pMobIndex->barred_entry->msg_type == BAR_ECHO) ?
olc_save.c:		if (pMobIndex->affect_sn[i] > -1) 
olc_save.c:			fprintf(fp,"A '%s' %s\n",skill_table[pMobIndex->affect_sn[i]].name,
olc_save.c:				flag_name_lookup(pMobIndex->affect_bit[i],affect_flags));
olc_save.c:		if (pMobIndex->cast_spell[i])
olc_save.c:			fprintf(fp,"C '%s'\n", pMobIndex->cast_spell[i]);
olc_save.c:	if (pMobIndex->speech) {
olc_save.c:		for (sptr = pMobIndex->speech; sptr; sptr = sptr->next) {
olc_save.c:			fprintf(fp,"SPEECH %s\n", sptr->name);
olc_save.c:			for (lptr = sptr->first_line; lptr; lptr = lptr->next)
olc_save.c:					lptr->delay,
olc_save.c:					flag_name_lookup(lptr->type,speech_table),
olc_save.c:					lptr->text);
olc_save.c:    for( i = pArea->min_vnum; i <= pArea->max_vnum; i++ )
olc_save.c:                new ROM format saving -- Hugin
olc_save.c:	fprintf(fp,"#%d\n", pObjIndex->vnum);
olc_save.c:	fprintf(fp,"%s~\n", pObjIndex->name);
olc_save.c:        fprintf(fp,"%s~\n", pObjIndex->short_descr);
olc_save.c:        fprintf(fp,"%s~\n",munch(pObjIndex->description));
olc_save.c:        fprintf(fp,"%s\n", item_name(pObjIndex->item_type));
olc_save.c:        fprintf(fp,"%s~\n", pObjIndex->material);
olc_save.c:        switch(pObjIndex->item_type)
olc_save.c:                    pObjIndex->value[0], pObjIndex->value[1],
olc_save.c:                    pObjIndex->value[2], pObjIndex->value[3],
olc_save.c:                    pObjIndex->value[4]);
olc_save.c:				dummy[0] = pObjIndex->value[4];
olc_save.c:                    weapon_name_lookup(pObjIndex->value[0]),
olc_save.c:                    pObjIndex->value[1], pObjIndex->value[2],
olc_save.c:                    attack_table[UMAX(0,pObjIndex->value[3])].name,
olc_save.c:                fprintf(fp,"%d %d '%s' %d %d\n", pObjIndex->value[0],
olc_save.c:                    pObjIndex->value[1],
olc_save.c:                    liq_table[UMAX(pObjIndex->value[2],0)].liq_name,
olc_save.c:                    pObjIndex->value[3], pObjIndex->value[4]);
olc_save.c:                fprintf(fp,"%d %d %d '%s' %d\n", pObjIndex->value[0],
olc_save.c:                    pObjIndex->value[1], pObjIndex->value[2],
olc_save.c:                    skill_table[UMAX(pObjIndex->value[3],0)].name,
olc_save.c:                    pObjIndex->value[4]);
olc_save.c:                fprintf(fp, "%d '%s' '%s' '%s' '%s'\n", pObjIndex->value[0],
olc_save.c:                    skill_table[UMAX(pObjIndex->value[1],0)].name,
olc_save.c:                    skill_table[UMAX(pObjIndex->value[2],0)].name,
olc_save.c:                    skill_table[UMAX(pObjIndex->value[3],0)].name,
olc_save.c:                    skill_table[UMAX(pObjIndex->value[4],0)].name);
olc_save.c:				dummy[0] = pObjIndex->value[1];
olc_save.c:                    pObjIndex->value[0], bitvector_to_flag(dummy),
olc_save.c:                    pObjIndex->value[2], pObjIndex->value[3],
olc_save.c:                    pObjIndex->value[4]);
olc_save.c:				dummy[0] = pObjIndex->value[2];
olc_save.c:                    pObjIndex->value[0], pObjIndex->value[1],
olc_save.c:                    pObjIndex->value[3], pObjIndex->value[4]);
olc_save.c:                    pObjIndex->value[0], pObjIndex->value[1],
olc_save.c:                    pObjIndex->value[2], pObjIndex->value[3],
olc_save.c:                    pObjIndex->value[4]);
olc_save.c:            pObjIndex->level, pObjIndex->weight, pObjIndex->cost);
olc_save.c:		if(IS_SET(pObjIndex->wear_flags, i)) {
olc_save.c:		if(IS_SET(pObjIndex->restrict_flags, i)) {
olc_save.c:		if(IS_SET(pObjIndex->extra_flags, i)) {
olc_save.c:        for(app = pObjIndex->apply; app; app = app->next)
olc_save.c:                (upstring(display_name_lookup(app->location,apply_locations))),
olc_save.c:                app->modifier);
olc_save.c:        fprintf(fp,"LIMIT %d\n",pObjIndex->limtotal);
olc_save.c:		if(pObjIndex->wear_echo[0] && pObjIndex->wear_echo[1])
olc_save.c:            fprintf(fp,"MSG WEAR %s~\n%s~\n",pObjIndex->wear_echo[0],pObjIndex->wear_echo[1]);
olc_save.c:        if(pObjIndex->remove_echo[0] && pObjIndex->remove_echo[1])
olc_save.c:            fprintf(fp,"MSG REMOVE %s~\n%s~\n", pObjIndex->remove_echo[0],
olc_save.c:                pObjIndex->remove_echo[1]);
olc_save.c:        if (pObjIndex->verb)
olc_save.c:            fprintf(fp,"VERB %s\n", pObjIndex->verb);
olc_save.c:	if (pObjIndex->cabal)
olc_save.c:	    	fprintf(fp,"CABAL %s\n", upstring(cabal_table[pObjIndex->cabal].name));
olc_save.c:        if(pObjIndex->start_timer>-1)
olc_save.c:            fprintf(fp,"TIMER %d\n",pObjIndex->start_timer);
olc_save.c:		if(IS_SET(pObjIndex->imm_flags,i)) {
olc_save.c:		if(IS_SET(pObjIndex->res_flags,i)) {
olc_save.c:		if(IS_SET(pObjIndex->vuln_flags,i)) {
olc_save.c:        for (paf = pObjIndex->charaffs; paf; paf = paf->next)
olc_save.c:				(skill_table[paf->type].name),
olc_save.c:                (affect_bit_name(paf->bitvector)),
olc_save.c:                (paf->aftype == AFT_SPELL) ? "SHOW" : "NOSHOW");
olc_save.c:		if (pObjIndex->wear_loc_name)
olc_save.c:			fprintf(fp,"NAMEOFLOC %s~\n", pObjIndex->wear_loc_name);
olc_save.c:        if (pObjIndex->notes)
olc_save.c:            fprintf(fp,"NOTES %s~\n", pObjIndex->notes);
olc_save.c:        for(ed = pObjIndex->extra_descr; ed; ed = ed->next)
olc_save.c:            fprintf(fp,"E %s~\n%s~\n", ed->keyword,
olc_save.c:                munch(ed->description));
olc_save.c:    for( i = pArea->min_vnum; i <= pArea->max_vnum; i++ )
olc_save.c:		for ( pRoom = room_index_hash[iHash]; pRoom; pRoom = pRoom->next)
olc_save.c:			if(pRoom->area != pArea)
olc_save.c:			sprintf(buf1,munch(pRoom->name));
olc_save.c:			sprintf(buf2,munch(pRoom->description));
olc_save.c:			fprintf(fp,"#%d\n",pRoom->vnum);
olc_save.c:			fprintf(fp,"%s\n",sect_table[UMAX(0,pRoom->sector_type)].name);
olc_save.c:				if(IS_SET(pRoom->room_flags,i))
olc_save.c:				if((pexit = pRoom->exit[i]))
olc_save.c:					sprintf(buf1,pexit->keyword ? munch(pexit->keyword) : "door");
olc_save.c:					sprintf(buf2,munch(pexit->description));
olc_save.c:						pexit->u1.to_room ? pexit->u1.to_room->vnum : 0,
olc_save.c:						bitvector_to_flag(pexit->exit_info), pexit->key,
olc_save.c:			if (pRoom->trap)
olc_save.c:					flag_name_lookup(pRoom->trap->type,trap_table),
olc_save.c:					pRoom->trap->quality,
olc_save.c:					pRoom->trap->complexity,
olc_save.c:					pRoom->trap->timer,
olc_save.c:					pRoom->trap->trig_echo,
olc_save.c:					pRoom->trap->exec_echo);
olc_save.c:			for(ed = pRoom->extra_descr; ed; ed = ed->next)
olc_save.c:				fprintf(fp,"E %s~\n%s~\n",ed->keyword, munch(ed->description));
olc_save.c:			if(pRoom->cabal)
olc_save.c:				fprintf(fp,"CABAL %s\n", cabal_table[pRoom->cabal].name);
olc_save.c:			if(pRoom->owner && pRoom->owner[0] != '\0')
olc_save.c:				fprintf(fp,"OWNER %s~\n", pRoom->owner);
olc_save.c:	if(IS_SET(pArea->progtypes, APROG_PULSE))
olc_save.c:		fprintf(fp,"A pulse_prog %s\n",pArea->aprogs->pulse_name);
olc_save.c:	if(IS_SET(pArea->progtypes, APROG_RESET))
olc_save.c:		fprintf(fp,"A reset_prog %s\n",pArea->aprogs->reset_name);
olc_save.c:	if(IS_SET(pArea->progtypes, APROG_SUN))
olc_save.c:		fprintf(fp,"A sun_prog %s\n",pArea->aprogs->sun_name);
olc_save.c:	if (IS_SET(pArea->progtypes, APROG_TICK))
olc_save.c:		fprintf(fp,"A tick_prog %s\n",pArea->aprogs->tick_name);
olc_save.c:	if (IS_SET(pArea->progtypes, APROG_AGGRESS))
olc_save.c:		fprintf(fp,"A aggress_prog %s\n",pArea->aprogs->aggress_name);
olc_save.c:	if (IS_SET(pArea->progtypes, APROG_MYELL))
olc_save.c:		fprintf(fp,"A myell_prog %s\n", pArea->aprogs->myell_name);
olc_save.c:	  for ( pRoomIndex = room_index_hash[iHash]; pRoomIndex; pRoomIndex = pRoomIndex->next)
olc_save.c:		if(pRoomIndex->area != pArea)
olc_save.c:		if(pRoomIndex->progtypes)
olc_save.c:			if(IS_SET(pRoomIndex->progtypes, RPROG_PULSE))
olc_save.c:				fprintf(fp,"R %d pulse_prog %s\n", pRoomIndex->vnum, pRoomIndex->rprogs->pulse_name);
olc_save.c:			if(IS_SET(pRoomIndex->progtypes, RPROG_ENTRY))
olc_save.c:				fprintf(fp,"R %d entry_prog %s\n", pRoomIndex->vnum, pRoomIndex->rprogs->entry_name);
olc_save.c:			if(IS_SET(pRoomIndex->progtypes, RPROG_MOVE))
olc_save.c:				fprintf(fp,"R %d move_prog %s\n", pRoomIndex->vnum, pRoomIndex->rprogs->move_name);
olc_save.c:			if(IS_SET(pRoomIndex->progtypes, RPROG_DROP))
olc_save.c:				fprintf(fp,"R %d drop_prog %s\n", pRoomIndex->vnum, pRoomIndex->rprogs->drop_name);
olc_save.c:			if(IS_SET(pRoomIndex->progtypes, RPROG_SPEECH))
olc_save.c:				fprintf(fp,"R %d speech_prog %s\n", pRoomIndex->vnum, pRoomIndex->rprogs->speech_name);
olc_save.c:			if(IS_SET(pRoomIndex->progtypes, RPROG_OPEN))
olc_save.c:                fprintf(fp,"R %d open_prog %s\n", pRoomIndex->vnum, pRoomIndex->rprogs->open_name);
olc_save.c:	  for(mIndex = mob_index_hash[iHash]; mIndex; mIndex = mIndex->next)
olc_save.c:        if(mIndex->area != pArea)
olc_save.c:        if(!mIndex->progtypes)
olc_save.c:        if(mIndex->progtypes)
olc_save.c:            if(IS_SET(mIndex->progtypes, MPROG_BRIBE))
olc_save.c:                fprintf(fp,"M %d bribe_prog %s\n", mIndex->vnum,
olc_save.c:                    mIndex->mprogs->bribe_name);
olc_save.c:            if(IS_SET(mIndex->progtypes, MPROG_ENTRY))
olc_save.c:                fprintf(fp,"M %d entry_prog %s\n", mIndex->vnum,
olc_save.c:                    mIndex->mprogs->entry_name);
olc_save.c:            if(IS_SET(mIndex->progtypes, MPROG_GREET))
olc_save.c:                fprintf(fp,"M %d greet_prog %s\n", mIndex->vnum,
olc_save.c:                    mIndex->mprogs->greet_name);
olc_save.c:            if(IS_SET(mIndex->progtypes, MPROG_GIVE))
olc_save.c:                fprintf(fp,"M %d give_prog %s\n", mIndex->vnum,
olc_save.c:                    mIndex->mprogs->give_name);
olc_save.c:            if(IS_SET(mIndex->progtypes, MPROG_FIGHT))
olc_save.c:                fprintf(fp,"M %d fight_prog %s\n", mIndex->vnum,
olc_save.c:                    mIndex->mprogs->fight_name);
olc_save.c:            if(IS_SET(mIndex->progtypes, MPROG_DEATH))
olc_save.c:                fprintf(fp,"M %d death_prog %s\n", mIndex->vnum,
olc_save.c:                    mIndex->mprogs->death_name);
olc_save.c:            if(IS_SET(mIndex->progtypes, MPROG_BEAT))
olc_save.c:                fprintf(fp,"M %d beat_prog %s\n", mIndex->vnum,
olc_save.c:                    mIndex->mprogs->beat_name);
olc_save.c:            if(IS_SET(mIndex->progtypes, MPROG_PULSE))
olc_save.c:                fprintf(fp,"M %d pulse_prog %s\n", mIndex->vnum,
olc_save.c:                    mIndex->mprogs->pulse_name);
olc_save.c:            if(IS_SET(mIndex->progtypes, MPROG_SPEECH))
olc_save.c:                fprintf(fp,"M %d speech_prog %s\n", mIndex->vnum,
olc_save.c:                    mIndex->mprogs->speech_name);
olc_save.c:            if(IS_SET(mIndex->progtypes, MPROG_ATTACK))
olc_save.c:                fprintf(fp,"M %d attack_prog %s\n", mIndex->vnum,
olc_save.c:                    mIndex->mprogs->attack_name);
olc_save.c:            if(IS_SET(mIndex->progtypes, MPROG_MOVE))
olc_save.c:                fprintf(fp,"M %d move_prog %s\n", mIndex->vnum,
olc_save.c:                    mIndex->mprogs->move_name);
olc_save.c:			if(IS_SET(mIndex->progtypes, MPROG_AGGRESS))
olc_save.c:				fprintf(fp,"M %d aggress_prog %s\n", mIndex->vnum,
olc_save.c:					mIndex->mprogs->aggress_name);
olc_save.c:    for(pObjIndex=obj_index_hash[iHash];pObjIndex; pObjIndex = pObjIndex->next)
olc_save.c:        if(pObjIndex->area != pArea || !pObjIndex->progtypes)
olc_save.c:        if(IS_SET(pObjIndex->progtypes, IPROG_WEAR))
olc_save.c:            fprintf(fp,"I %d wear_prog %s\n", pObjIndex->vnum,
olc_save.c:                pObjIndex->iprogs->wear_name);
olc_save.c:        if(IS_SET(pObjIndex->progtypes, IPROG_REMOVE))
olc_save.c:            fprintf(fp,"I %d remove_prog %s\n", pObjIndex->vnum,
olc_save.c:                pObjIndex->iprogs->remove_name);
olc_save.c:        if(IS_SET(pObjIndex->progtypes, IPROG_DROP))
olc_save.c:            fprintf(fp,"I %d drop_prog %s\n", pObjIndex->vnum,
olc_save.c:                pObjIndex->iprogs->drop_name);
olc_save.c:        if(IS_SET(pObjIndex->progtypes, IPROG_SAC))
olc_save.c:            fprintf(fp,"I %d sac_prog %s\n", pObjIndex->vnum,
olc_save.c:                pObjIndex->iprogs->sac_name);
olc_save.c:        if(IS_SET(pObjIndex->progtypes, IPROG_GIVE))
olc_save.c:            fprintf(fp,"I %d give_prog %s\n", pObjIndex->vnum,
olc_save.c:                pObjIndex->iprogs->give_name);
olc_save.c:        if(IS_SET(pObjIndex->progtypes, IPROG_GREET))
olc_save.c:            fprintf(fp,"I %d greet_prog %s\n", pObjIndex->vnum,
olc_save.c:                pObjIndex->iprogs->greet_name);
olc_save.c:        if(IS_SET(pObjIndex->progtypes, IPROG_FIGHT))
olc_save.c:            fprintf(fp,"I %d fight_prog %s\n", pObjIndex->vnum,
olc_save.c:                pObjIndex->iprogs->fight_name);
olc_save.c:        if(IS_SET(pObjIndex->progtypes, IPROG_DEATH))
olc_save.c:            fprintf(fp,"I %d death_prog %s\n", pObjIndex->vnum,
olc_save.c:                pObjIndex->iprogs->death_name);
olc_save.c:        if(IS_SET(pObjIndex->progtypes, IPROG_SPEECH))
olc_save.c:            fprintf(fp,"I %d speech_prog %s\n", pObjIndex->vnum,
olc_save.c:                pObjIndex->iprogs->speech_name);
olc_save.c:        if(IS_SET(pObjIndex->progtypes, IPROG_ENTRY))
olc_save.c:            fprintf(fp,"I %d entry_prog %s\n", pObjIndex->vnum,
olc_save.c:                pObjIndex->iprogs->entry_name);
olc_save.c:        if(IS_SET(pObjIndex->progtypes, IPROG_GET))
olc_save.c:            fprintf(fp,"I %d get_prog %s\n", pObjIndex->vnum,
olc_save.c:                pObjIndex->iprogs->get_name);
olc_save.c:        if(IS_SET(pObjIndex->progtypes, IPROG_PULSE))
olc_save.c:            fprintf(fp,"I %d pulse_prog %s\n", pObjIndex->vnum,
olc_save.c:                pObjIndex->iprogs->pulse_name);
olc_save.c:        if(IS_SET(pObjIndex->progtypes, IPROG_INVOKE))
olc_save.c:            fprintf(fp,"I %d invoke_prog %s\n", pObjIndex->vnum,
olc_save.c:                pObjIndex->iprogs->invoke_name);
olc_save.c:        if (IS_SET(pObjIndex->progtypes, IPROG_VERB))
olc_save.c:            fprintf(fp,"I %d verb_prog %s\n", pObjIndex->vnum,
olc_save.c:                pObjIndex->iprogs->verb_name);
olc_save.c:		if (IS_SET(pObjIndex->progtypes, IPROG_SAC))
olc_save.c:			fprintf(fp,"I %d sac_prog %s\n", pObjIndex->vnum,
olc_save.c:				pObjIndex->iprogs->sac_name);
olc_save.c:		if (IS_SET(pObjIndex->progtypes, IPROG_LOOK))
olc_save.c:			fprintf(fp,"I %d look_prog %s\n", pObjIndex->vnum,
olc_save.c:				pObjIndex->iprogs->look_name);
olc_save.c:		if (IS_SET(pObjIndex->progtypes, IPROG_OPEN))
olc_save.c:			fprintf(fp,"I %d open_prog %s\n", pObjIndex->vnum,
olc_save.c:				pObjIndex->iprogs->open_name);
olc_save.c:		if (IS_SET(pObjIndex->progtypes, IPROG_LOOT))
olc_save.c:			fprintf(fp,"I %d loot_prog %s\n", pObjIndex->vnum,
olc_save.c:				pObjIndex->iprogs->loot_name);
olc_save.c:		if (IS_SET(pObjIndex->progtypes, IPROG_HIT))
olc_save.c:			fprintf(fp,"I %d hit_prog %s\n", pObjIndex->vnum,
olc_save.c:				pObjIndex->iprogs->hit_name);
olc_save.c:    	for( pObjIndex = obj_index_hash[iHash]; pObjIndex; pObjIndex = pObjIndex->next)
olc_save.c:			if(pObjIndex->area != pArea || !pObjIndex->spec_prog.func)
olc_save.c:				if(ispec_table[i].spec_func == pObjIndex->spec_prog.func)
olc_save.c:					fprintf(fp,"I %d %s\n", pObjIndex->vnum, ispec_table[i].spec_name);
olc_save.c:					bug("Problem saving ispec on obj %d.", pObjIndex->vnum);*/
olc_save.c:		for(pMob = mob_index_hash[iHash]; pMob; pMob = pMob->next)
olc_save.c:			if(pMob->area != pArea || !pMob->spec_prog.func)
olc_save.c:				if(mspec_table[i].spec_func == pMob->spec_prog.func)
olc_save.c:					fprintf(fp,"M %d %s\n", pMob->vnum, mspec_table[i].spec_name);
olc_save.c:				/*else if(mspec_table[i].spec_func != pMob->spec_prog.func)
olc_save.c:					bug("Problem saving mspec on mob %d.", pMob->vnum);*/
olc_save.c:	for(i = pArea->min_vnum; i < (pArea->max_vnum + 1); i++)
olc_save.c:		for (pReset = pRoomIndex->reset_first; pReset != NULL; pReset = pReset->next )
olc_save.c:        	switch(pReset->command)
olc_save.c:                fprintf(fp,"MOB %d TO %d GLIMIT %d LLIMIT %d\n", pReset->arg1, pReset->arg3, pReset->arg2, pReset->arg4);
olc_save.c:                fprintf(fp,"OBJECT %d TO %d\n", pReset->arg1, pReset->arg3);
olc_save.c:                fprintf(fp,"PUT %d IN %d COUNT %d\n", pReset->arg1,pReset->arg3, pReset->arg4);
olc_save.c:                fprintf(fp,"GIVE %d\n", pReset->arg1);
olc_save.c:                fprintf(fp,"FOLLOW %d %d\n", pReset->arg1, pReset->arg2);
olc_save.c:                fprintf(fp,"EQUIP %d %s\n", pReset->arg1,(upstring(flag_name_lookup(pReset->arg3, wear_locations))));
olc_save.c:                fprintf(fp,"DOOR %d %s %s\n", pReset->arg1,
olc_save.c:                    (direction_table[pReset->arg2].name),
olc_save.c:                    pReset->arg3 == 0 ? "OPEN" : pReset->arg3 == 1 ? "CLOSED"
olc_save.c:                fprintf(fp,"RANDOMIZE %d %d\n", pReset->arg1, pReset->arg2);
olc_save.c:	sprintf(buf,"mv -f %s ../area/backup/%s.bak",pArea->file_name,pArea->file_name);
olc_save.c:	system("touch /home/rift/code/area-dump.txt");
olc_save.c:	if ( !( fp = fopen( pArea->file_name, "w" ) ) )
olc_save.c:		perror( pArea->file_name );
olc_save.c:	fprintf(fp,"%s~\n%s~\n%s~\n", pArea->file_name, pArea->name, pArea->credits);
olc_save.c:	fprintf(fp,"%d %d\n", pArea->low_range, pArea->high_range);
olc_save.c:	fprintf(fp,"%d %d\n", pArea->min_vnum, pArea->max_vnum);
olc_save.c:	fprintf(fp,"%s\n", area_type_table[pArea->area_type].name);
olc_save.c:	fprintf(fp,"%s\n", climate_table[pArea->climate].name);
olc_save.c:	fprintf(fp,"%s\n", bitvector_to_flag(pArea->area_flags));
olc_save.c:	fprintf(fp,"%d\n", pArea->security);
olc_save.c:	fprintf(fp,"%s~\n\n", pArea->builders);
olc_save.c:	temp_bit = pArea->area_flags[0] + pArea->area_flags[1];
olc_save.c:		for( pArea = area_first; pArea; pArea = pArea->next )
olc_save.c:			if(IS_BUILDER(ch, ch->in_room->area))
olc_save.c:				clean_olc_aflags( ch->in_room->area);
olc_save.c:				save_area( ch->in_room->area);
olc_save.c:			for( pArea = area_first; pArea; pArea = pArea->next )                                                     
olc_save.c:				if ( IS_SET(pArea->area_flags, AREA_CHANGED) || IS_SET(pArea->area_flags, AREA_ADDED))                
olc_save.c:					sprintf( buf, "%24s - '%s'\n\r", pArea->name, pArea->file_name );                                 
olc_save.c:			send_to_char( "  asave         - saves area you are currently in.\n\r", ch);
olc_save.c:			send_to_char( "  asave changed - saves all areas in your name that have been changed.\n\r", ch);
olc_save.c:    		send_to_char( "  asave <vnum>   - saves a particular area\n\r",	ch );
olc_save.c:			send_to_char( "  asave list     - saves the area.lst file\n\r",	ch );
olc_save.c:    		send_to_char( "  asave area     - saves the area being edited\n\r",	ch );
olc_save.c:			send_to_char( "  asave changed  - saves all changed zones\n\r",	ch );
olc_save.c:			send_to_char( "  asave world    - saves the world! (db dump)\n\r",	ch );
olc_save.c:    	/* ------------------------ */
olc_save.c:    /* -------------------------------------- */
olc_save.c:		for( pArea = area_first; pArea != NULL; pArea = pArea->next )
olc_save.c:			if ( !IS_SET(pArea->area_flags, AREA_CHANGED) && !IS_SET(pArea->area_flags, AREA_ADDED))
olc_save.c:			log_string(pArea->name);
olc_save.c:			sprintf(buf,"Saving..%s\n", pArea->name);
olc_save.c:    /* ------------------------------------------ */
olc_save.c:		for( pArea = area_first; pArea; pArea = pArea->next )
olc_save.c:	    	if ( IS_SET(pArea->area_flags, AREA_CHANGED) || IS_SET(pArea->area_flags, AREA_ADDED))
olc_save.c:				sprintf( buf, "%24s - '%s'\n\r", pArea->name, pArea->file_name );
olc_save.c:    /* ----------------------- */
olc_save.c:    /* -------------------------------------- */
olc_save.c:		if ( ch->desc->editor == 0 )
olc_save.c:		switch (ch->desc->editor)
olc_save.c:				pArea = (AREA_DATA *)ch->desc->pEdit;
olc_save.c:				pArea = ch->in_room->area;
olc_save.c:				pArea = ( (OBJ_INDEX_DATA *)ch->desc->pEdit )->area;
olc_save.c:				pArea = ( (MOB_INDEX_DATA *)ch->desc->pEdit )->area;
olc_save.c:				pArea = ch->in_room->area;
olc_save.c:    /* -------------------- */
paladin.c:	for(to = ch->in_room->people; to!=NULL; to = to->next_in_room)
paladin.c:			to->pcdata->condition[COND_HUNGER] = 0;
paladin.c:			to->pcdata->condition[COND_THIRST] = 0;
paladin.c:			af.modifier = (ch->level/7);
paladin.c:			af.level = ch->level;
paladin.c:			af.modifier = (ch->level/7);
paladin.c:			af.level = ch->level;
paladin.c:			af.modifier = -(ch->level/8);
paladin.c:			af.level = ch->level;
paladin.c:		af.level = ch->level;
paladin.c:	if(ch->mana < 75)
paladin.c:	for(victim = ch->in_room->people; victim != NULL; victim = v_next)
paladin.c:		v_next = victim->next_in_room;
paladin.c:		if(!IS_NPC(victim) || victim == ch || !IS_SET(victim->act,ACT_UNDEAD))
paladin.c:		difference = ch->level - victim->level;
paladin.c:		if(IS_SET(victim->act,ACT_UNDEAD))
paladin.c:			dam = dice(ch->level,20);
paladin.c:		else if(difference > -5)
paladin.c:			dam = dice(ch->level,10);
paladin.c:		if(forceflee == TRUE && !IS_SET(victim->act,ACT_SENTINEL))
paladin.c:	af.level = ch->level;
paladin.c:	if (paladin->fighting != ch)
paladin.c:	for(gch = paladin->in_room->people; gch; gch = gch->next_in_room)
paladin.c:		if (check_posture(ch) == POSTURE_DEFENSE && style_check(gsn_posture, ch->pcdata->style))
paladin.c:		chance += (victim->level - ch->level) / 2;
paladin.c:			IS_NPC(ch) ? ch->short_descr : ch->name, attack);
paladin.c:			IS_NPC(paladin) ? paladin->short_descr : paladin->name, attack);
paladin.c:			IS_NPC(victim) ? victim->short_descr : victim->name, attack);
paladin.c:	for (victim=ch->in_room->people; victim != NULL; victim = victim->next_in_room)
paladin.c:		if(!saves_spell(ch->level,victim,DAM_LIGHT) && !IS_AFFECTED(victim,AFF_BLIND))
paladin.c:			af.modifier = -4;
paladin.c:	for(victim = ch->in_room->people; victim !=NULL; victim = vch_next)
paladin.c:		vch_next = victim->next_in_room;
paladin.c:		|| (!IS_NPC(victim) && (IS_GOOD(victim) || IS_NEUTRAL(victim)) && (victim->pcdata->kills[PK_GOOD] <= victim->pcdata->kills[PK_EVIL])))
paladin.c:		damage_new(ch,victim,dice(ch->level,5),sn,DAM_MENTAL,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,NULL);
paladin.c:	af.modifier = -40;
paladin.c:	af.duration = ch->level/5;
paladin.c:	af.level = ch->level;
paladin.c:	af.modifier = -(ch->level/2);
paladin.c:	af.level = ch->level;
paladin.c:	if(weapon->item_type != ITEM_WEAPON)
paladin.c:	oaf.level = ch->level;
paladin.c:	af.duration = ch->level;
paladin.c:	af.level = ch->level;
paladin.c:	if(weapon->item_type != ITEM_WEAPON)
paladin.c:	oaf.level = ch->level;
paladin.c:	af.level = ch->level;
paladin.c:	if(weapon->item_type != ITEM_WEAPON)
paladin.c:	oaf.level = ch->level;
paladin.c:	af.duration = ch->level;                                                                     
paladin.c:	af.level = ch->level;                                                                        
paladin.c:	if(weapon->item_type != ITEM_WEAPON)
paladin.c:	oaf.level = ch->level;
paladin.c:	af.duration = ch->level;                                                                     
paladin.c:	af.level = ch->level;                                                                        
paladin.c:	CHAR_DATA *victim = ch->fighting;
paladin.c:	if(ch->position != POS_FIGHTING)
paladin.c:	af.level = ch->level;
paladin.c:	af.level = ch->level;
paladin.c:	CHAR_DATA *victim = ch->fighting;
paladin.c:	if(!ch->fighting)
paladin.c:	pexit = ch->in_room->exit[dir];
paladin.c:	if(skill-10 < number_percent())
paladin.c:		for(to = ch->in_room->people; to != NULL; to = to->next_in_room)
paladin.c:	   && ((to_room = pexit->u1.to_room) != NULL)
paladin.c:	   && (!IS_SET(pexit->exit_info,EX_CLOSED)
paladin.c:	   || ((IS_SET(pexit->exit_info,EX_CLOSED) 
paladin.c:	   && !IS_SET(pexit->exit_info,EX_NOPASS))))
paladin.c:		for(to = ch->in_room->people; to != NULL; to = vch_next)
paladin.c:			vch_next = to->next_in_room;
paladin.c:	if(victim->hit < victim->hit/2)
paladin.c:	for(to = ch->in_room->people; to!=NULL; to = to->next_in_room)
paladin.c:	for(to = ch->in_room->people; to!=NULL; to = to->next_in_room)
paladin.c:		return send_to_char("You are already radiating an awe-inspiring holy aura.\n\r",ch);
paladin.c:	af.level = ch->level;
paladin.c:	af.level = ch->level;
paladin.c:	af.duration = ch->level/3;
paladin.c:	af.level = ch->level;
paladin.c:	af.duration = ch->level/5;
paladin.c:	CHAR_DATA *victim = ch->fighting;
paladin.c:			if(!saves_spell(ch->level,victim,DAM_LIGHT))
paladin.c:				af.duration = ch->level/12;
paladin.c:				af.modifier = -4;
paladin.c:		if(bOncePerRound == FALSE && number_percent() < ch->level/2)
paladin.c:		damage_new(ch,victim,dice(ch->level,2),0,DAM_HOLY,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"holy wrath");
paladin.c:		if(number_percent() < ch->level/2)
paladin.c:			obj_cast_spell(skill_lookup("cure critical"), ch->level,ch,ch,wield);
paladin.c:		if(bOncePerRound == TRUE && number_percent() > 75 && !IS_NPC(victim) && (IS_EVIL(victim) || victim->pcdata->kills[PK_GOOD] < victim->pcdata->kills[PK_EVIL]))
paladin.c:			if(!saves_spell(ch->level,victim,DAM_HOLY))
paladin.c:		if(bOncePerRound == FALSE && ch->level/2 > number_percent())
paladin.c:	af.level = ch->level;
paladin.c:	act("You feel pained as your spiritual link with $n is severed!", af->owner, 0, ch, TO_CHAR);
paladin.c:	af.level = ch->level;
paladin.c:	af.duration = ch->level / 6;
paladin.c:	af.level = ch->level;
paladin.c:	af.duration = ch->level / 5;
paladin.c:	if(ch->hit < 0)
paladin.c:		diff = abs(ch->hit);
paladin.c:		if(diff > (ch->mana / 2))
paladin.c:	if(ch->hit < 0)
paladin.c:	for (from_af = vict->affected; from_af != NULL; from_af = from_af->next )                                                       
paladin.c:		if (skill_table[from_af->type].dispel & CAN_CLEANSE)
paladin.c:			to_af.owner = from_af->owner;
paladin.c:			if(from_af->name != NULL)
paladin.c:				to_af.name = talloc_string(from_af->name);
paladin.c:			to_af.valid = from_af->valid;
paladin.c:			to_af.where = from_af->where;
paladin.c:			to_af.type = from_af->type;
paladin.c:			to_af.level = from_af->level;
paladin.c:			to_af.duration = from_af->duration;
paladin.c:			to_af.location = from_af->location;
paladin.c:			to_af.modifier = from_af->modifier;
paladin.c:			copy_vector(from_af->bitvector, to_af.bitvector);
paladin.c:			to_af.aftype = from_af->aftype;
paladin.c:			to_af.tick_fun = from_af->tick_fun;
paladin.c:			to_af.pulse_fun = from_af->pulse_fun;
paladin.c:			to_af.end_fun = from_af->end_fun;
paladin.c:			to_af.init_duration = from_af->init_duration;
quest.c:/* Eladrian's Kickin' Quest Tracking System -- ph34r */
quest.c:			"Gave Pete meat -- Quest Completed.",
quest.c:		if(victim->pcdata->quests[i]) {
quest.c:			victim->pcdata->quests[i] = 0;
quest.c:	if (((ch->level < quest_table[quest].minlevel) || (ch->level > quest_table[quest].maxlevel)))
quest.c:#define STAGE(ch)		ch->pcdata->quests[nQuestIndex]
quest.c:#define SET_STAGE(ch, i) ch->pcdata->quests[nQuestIndex] = i
quest.c:	af.duration = -1;
quest.c:	for(paf = ch->affected; paf; paf = paf->next)
quest.c:		if(paf->type == gsn_timer && paf->name && !str_cmp(paf->name, valname))
quest.c:			SET_BIT_OLD(paf->level, value);
quest.c:	for(paf = ch->affected; paf; paf = paf->next)
quest.c:		if(paf->type == gsn_timer && paf->name && !str_cmp(paf->name, valname))
quest.c:			return paf->level;
quest.c:	return -1;
quest.c:	for(paf = ch->affected; paf; paf = paf_next)
quest.c:		paf_next = paf->next;
quest.c:		if(paf->type == gsn_timer && paf->name && !str_cmp(paf->name, valname))
quest.c:/* QUEST #1 -- Return the doll (2298) to the red-eyed girl (2481) in Cimar */
quest.c:	switch (ch->pcdata->quests[DOLL_QUEST]) {
quest.c:			sprintf(buf,"A red-eyed girl asks '%sD-did you find my d-doll?%s'\n\r",get_char_color(ch,"speech"),END_COLOR(ch));
quest.c:	switch (ch->pcdata->quests[DOLL_QUEST]) {
quest.c:				sprintf(buf,"A red-eyed girl says '%sI lost it somewhere on Wormwood Avenue... I saw a rat, and it tried to bite me, so I ran away... and I think I dropped my doll somewhere b-by the sewer g-grate....%s'\n\r",get_char_color(ch,"speech"),END_COLOR(ch));
quest.c:				ch->pcdata->quests[DOLL_QUEST] = 1;
quest.c:				ch->pcdata->quests[DOLL_QUEST] = 2;
quest.c:				ch->pcdata->reputation -= 10;
quest.c:					do_say(mob,"Why... would you l-lie to me?  W-why?");
quest.c:					ch->pcdata->quests[DOLL_QUEST] = 3;
quest.c:					ch->pcdata->reputation -= 15;
quest.c:	if (obj->pIndexData->vnum != 2298)
quest.c:	if (ch->pcdata->quests[DOLL_QUEST] != 1)
quest.c:	ch->pcdata->quests[DOLL_QUEST] = 4;
quest.c:	ch->pcdata->reputation += 15;
quest.c:/* QUEST #2 -- Talismanic aura quest for sorcerers, at level 35+ */
quest.c:	if (str_cmp(ch->Class()->name,"sorcerer"))
quest.c:	if (ch->pcdata->quests[TALISMANIC_QUEST] == 0) {
quest.c:		sprintf(buf,"$n whispers '%sAh, %s.  I have been noting your progress with some interest.  I believe you are now ready to grasp a powerful new form of magic.  I have sworn an oath not to divulge its secrets, but I can tell you this: seek out a hermit in a valley north and to the west of this place.  He is in hiding, however, for there are many who would seek to learn his secrets.  Pelamon is his name.  Speak it that he may know you are a friend.  Do not shame me by proving unworthy in his eyes.%s'", get_char_color(ch,"red"), ch->name, END_COLOR(ch));
quest.c:		ch->pcdata->quests[TALISMANIC_QUEST] =1;
quest.c:	} else if (ch->pcdata->quests[TALISMANIC_QUEST] == 1 ) {
quest.c:	if (ch->in_room != room)
quest.c:	if (str_cmp(ch->Class()->name,"sorcerer"))
quest.c:	for (rch = room->people; rch; rch = rch->next_in_room) {
quest.c:	switch(ch->pcdata->quests[TALISMANIC_QUEST]) {
quest.c:				sprintf(buf,"%s Who're those people with you?  If you want any dealings with me, get rid of them.",ch->name);
quest.c:				act("A previously-unnoticed door on the shack to the west creaks loudly open.",ch,0,0,TO_ALL);
quest.c:				sprintf(buf,"%s Who're those people with you?  If you want any dealings with me, get rid of them.",ch->name);
quest.c:					sprintf(buf,"%s Hmm... moss?  You don't have my moss!  Don't come back until you do, grubber!",ch->name);
quest.c:					act("A previously-unnoticed door on the shack to the west creaks loudly open.",ch,0,0,TO_ALL);
quest.c:				sprintf(buf,"%s Who're those people with you?  If you want any dealings with me, get rid of them.",ch->name);
quest.c:					sprintf(buf,"%s I can't do a thing for you unless you find that blasted page!  And if you find it, you best come back here right away before some grubber gets it, yes!",ch->name);
quest.c:					act("A previously-unnoticed door on the shack to the west creaks loudly open.",ch,0,0,TO_ALL);
quest.c:			damage_new(mob,ch,dice(ch->level,8),gsn_call_lightning,DAM_LIGHTNING,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"The lightning strike*");
quest.c:			sprintf(buf,"%s Get the hell away from here, and don't you ever come back, you dirty grubber!",ch->name);
quest.c:			sprintf(buf,"%s Nope, you're not getting another thing out of me, grubber!",ch->name);
quest.c:	if (ch->pcdata->quests[TALISMANIC_QUEST] != 1)
quest.c:		ch->pcdata->quests[TALISMANIC_QUEST] = 3;
quest.c:		ch->pcdata->quests[TALISMANIC_QUEST] = 2;
quest.c:	if (obj->pIndexData->vnum != 230 && obj->pIndexData->vnum != 1709)
quest.c:	if (obj->pIndexData->vnum == 230 &&
quest.c:		ch->pcdata->quests[TALISMANIC_QUEST] == 3) {
quest.c:		ch->pcdata->quests[TALISMANIC_QUEST] = 4;
quest.c:	if (obj->pIndexData->vnum == 1709 &&
quest.c:		ch->pcdata->quests[TALISMANIC_QUEST] == 4) {
quest.c:	if (ch->in_room->vnum == 9148) {
quest.c:		ch->pcdata->quests[TALISMANIC_QUEST] = 6;
quest.c:		ch->pcdata->learned[skill_lookup("talismanic aura")] = 70;
quest.c:	if (!obj->carried_by)
quest.c:	ch = obj->carried_by;
quest.c:	if (ch->pcdata->quests[TALISMANIC_QUEST] == 4)
quest.c:	if (!obj->carried_by)
quest.c:	ch = obj->carried_by;
quest.c:	if (ch->pcdata->quests[TALISMANIC_QUEST] != 4)
quest.c:	if (obj->pIndexData->vnum != 1708)
quest.c:	attacker->pcdata->quests[TALISMANIC_QUEST] = 5;
quest.c:	if (mob->in_room->area->nplayer == 0)
quest.c:	for (d = descriptor_list; d; d = d->next) {
quest.c:		if (d->connected == CON_PLAYING 
quest.c:			&& !IS_NPC(d->character)
quest.c:			&& d->character->in_room != NULL 
quest.c:			&& d->character->in_room->area != NULL
quest.c:			&& d->character->in_room->area == mob->in_room->area
quest.c:			&& d->character->pcdata->quests[TALISMANIC_QUEST] == 5
quest.c:			sprintf(buf,"%s You!  Coming again to grub, eh?  You'll pay, oh yes yes, you will!",d->character->name);
quest.c:			act("A bolt of lightning streaks down from the clouds above!",d->character,0,0,TO_ALL);
quest.c:			do_myell(d->character,"Argh!  I've been struck by lightning!",NULL);
quest.c:			damage_new(mob,d->character,dice(d->character->level,8),gsn_call_lightning,DAM_LIGHTNING,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"The lightning strike*");
quest.c:/* QUEST 3 - Bring the drow scribe (23811) fruit from island in the Crimson Sea */
quest.c:	if(ch->pcdata->quests[SCRIBE_QUEST] == 0) {
quest.c:		ch->pcdata->quests[SCRIBE_QUEST] = 1;
quest.c:	} else if(ch->pcdata->quests[SCRIBE_QUEST] == 1) {
quest.c:		sprintf(buf,"Well, %s?  Do you want the job or not?",ch->name);
quest.c:	} else if(ch->pcdata->quests[SCRIBE_QUEST] == 2) {
quest.c:		sprintf(buf,"Hand me the fruit, %s.",ch->name);
quest.c:	if(ch->pcdata->quests[SCRIBE_QUEST] == 1 && agrees(ch,speech) == REPLY_YES) {
quest.c:		ch->pcdata->quests[SCRIBE_QUEST] = 2;
quest.c:	} else if(ch->pcdata->quests[SCRIBE_QUEST] == 1 && agrees(ch,speech) == REPLY_NO) {
quest.c:		ch->pcdata->quests[SCRIBE_QUEST] = 3;
quest.c:	if(ch->pcdata->quests[SCRIBE_QUEST] != 2)
quest.c:	if(obj->pIndexData->vnum != 14222) {
quest.c:		obj_to_room(obj,mob->in_room);
quest.c:	if(obj->pIndexData->vnum == 14222 && ch->pcdata->quests[SCRIBE_QUEST] == 2) {
quest.c:		ch->gold += gold;
quest.c:		ch->pcdata->quests[SCRIBE_QUEST] = 4;
quest.c:	if(ch->pcdata->quests[MUD_SCHOOL])
quest.c:	ch->pcdata->quests[MUD_SCHOOL] = 1;
quest.c:	if(ch->pcdata->quests[MUD_SCHOOL] > 1)
quest.c:	ch->pcdata->quests[MUD_SCHOOL] = 2;
quest.c:	if(ch->pcdata->quests[MUD_SCHOOL] > 2)
quest.c:	ch->gold += 500;
quest.c:	ch->pcdata->quests[MUD_SCHOOL] = 3;
quest.c:	switch(ch->pcdata->quests[PETE_QUEST]) {
quest.c:			do_sing(mob,"Boiled meat, bitter meat/Garbage, trash, or litter meat/Sour, burnt, or livin' meat/Don't care what you're givin' Pete;/Pete'll eat it -- Pete likes meat./What you got for Starvin' Pete?");
quest.c:			ch->pcdata->quests[PETE_QUEST] = 1;
quest.c:	switch(ch->pcdata->quests[PETE_QUEST]) {
quest.c:			if(!str_cmp(material_table[obj->pIndexData->material_index].mat_name,"meat")) {
quest.c:				((paf = affect_find(mob->affected,gsn_bash))!= NULL && 
quest.c:				(ch == paf->owner))) {
quest.c:				ch->gold += 10;
quest.c:			if(obj->pIndexData->vnum == 2416) {
quest.c:				ch->pcdata->quests[PETE_QUEST] = 3;
quest.c:				obj_to_room(obj,ch->in_room);
quest.c:                        if(!str_cmp(material_table[obj->pIndexData->material_index].mat_name,"meat")) {
quest.c:                                ch->gold += 10;
quest.c:/* academy blacksmith quest - bring him components for a better weapon -cal */
quest.c:			if(obj->pIndexData->vnum < MIN_COMPONENT || obj->pIndexData->vnum > MAX_COMPONENT)
quest.c:			if((ival = get_quest_val(ch, SMITH_QUEST_COMP_ACQUIRED)) > -1 && IS_SET_OLD(ival, obj->pIndexData->vnum - MIN_COMPONENT))
quest.c:			store_quest_val(ch, SMITH_QUEST_LASTCOMP, obj->pIndexData->vnum);
quest.c:			if(obj->pIndexData->vnum < OBJ_VNUM_SCHOOL_FLAIL || obj->pIndexData->vnum > OBJ_VNUM_SCHOOL_SWORD)
quest.c:			if((comp_vnum = get_quest_val(ch, SMITH_QUEST_LASTCOMP)) == -1)
quest.c:			if((done_comps = get_quest_val(ch, SMITH_QUEST_COMP_ACQUIRED)) == -1)
quest.c:				setbit_quest_val(ch, SMITH_QUEST_COMP_ACQUIRED, (comp_vnum - MIN_COMPONENT));
quest.c:				//obj->value[1] == 3; obj->value[2] = 4;i
quest.c:				obj->value[1] = 15;
quest.c:				obj->value[2] = 1;
quest.c:/*				if(obj->value[1] == 3 && obj->value[2] == 5)
quest.c:				{	obj->value[1] = 4; obj->value[2] = 4; improved = 3;}
quest.c:				else if(obj->value[1] == 4 && obj->value[2] == 3)
quest.c:				{	obj->value[1] = 3; obj->value[2] = 5; improved = 2;}
quest.c:				else if(obj->value[1] == 3 && obj->value[2] == 4)
quest.c:				{	obj->value[1] = 4; obj->value[2] = 3; improved = 1;}*/
quest.c:				obj->value[1] = UMAX(obj->value[1] + 1, 18);
quest.c:			sprintf(buf,"%s",obj->short_descr);
quest.c:			REMOVE_BIT(obj->extra_flags, ITEM_MELT_DROP);
quest.c:				sprintf(buf, "a fully strengthened Academy %s", weapon_name(obj->value[0]));
quest.c:				sprintf(buf, "a reinforced Academy %s", weapon_name(obj->value[0]));
quest.c:			free_pstring(obj->short_descr);
quest.c:			obj->short_descr = palloc_string(buf);
quest.c:			setbit_quest_val(ch, SMITH_QUEST_COMP_ACQUIRED, (comp_vnum - MIN_COMPONENT));
queue.c:		qf_next = qf->queue_next;
queue.c:		if(qf->queue_delay < 0) /* weird bug i don't want to find, probably a fucked up addtoq somewhere in the code */
queue.c:			qf->FreeQueue();
queue.c:		if(--qf->queue_delay == 0)
queue.c:						movl	%eax, -24(%ebp)
queue.c:						movl	%edx, -28(%ebp)
queue.c:						movl	%ecx, -32(%ebp)
queue.c:						movl	-24(%ebp), %eax
queue.c:						movl    -28(%ebp), %edx
queue.c:						movl	-32(%ebp), %ecx
queue.c:			(*qf->queue_function) ();
queue.c:			qf->FreeQueue();
queue.c:		bug("Negative Queue Timer - NumArgs: %d", nArgs);	
queue.c:	nq->queue_delay = nTimer;
queue.c:	nq->queue_numargs = nArgs;
queue.c:	nq->queue_next = queue_first;
queue.c:	nq->queue_function = (QUEUE_FUNCTION)va_arg(ap, void *);
queue.c:		nq->queue_args[i] = NULL;
queue.c:		nq->queue_args[i] = hax[nArgs - i - 1]; //don't even ask why
queue.c:		return (void) (queue_first = this->queue_next);
queue.c:	for(r = queue_first; r && r->queue_next != this; r = r->queue_next)
queue.c:	r->queue_next = this->queue_next;
queue.c:	for(r = queue_first; r; r = r->queue_next)
queue.c:		for(int i = 0; i < r->queue_numargs; i++)
queue.c:			if(r->queue_args[i] == qChar && r->queue_delay > 0)
race.c:	if(!str_cmp(race_table[ch->race].name,"elf"))
race.c:	else if(!str_cmp(race_table[ch->race].name,"drow"))
race.c:	if(room->sector_type == SECT_UNDERWATER
race.c:	   || room->sector_type == SECT_AIR
race.c:	   || room->sector_type == SECT_WATER)
race.c:	if(elf && !(room->sector_type == SECT_INSIDE)
race.c:		   && !(room->sector_type == SECT_CITY)
race.c:		   && !(room->sector_type == SECT_CAVE))
race.c:	else if(drow && ((room->sector_type == SECT_INSIDE)
race.c:				 || (room->sector_type == SECT_CITY)
race.c:				 || (room->sector_type == SECT_CAVE)))
race.c:		|| ((str_cmp(race_table[ch->race].name,"elf"))
race.c:		&& (str_cmp(race_table[ch->race].name,"drow"))))
race.c:	if(!check_silent_movement(ch, ch->in_room))                                                                   
race.c:		af.level     = ch->level;
race.c:		af.duration  = ch->level;
recycle.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
recycle.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
recycle.c:	note_free = note_free->next;
recycle.c:    free_pstring( note->text    );
recycle.c:    free_pstring( note->subject );
recycle.c:    free_pstring( note->to_list );
recycle.c:    free_pstring( note->date    );
recycle.c:    free_pstring( note->sender  );
recycle.c:    note->next = note_free;
recycle.c:	ban_free = ban_free->next;
recycle.c:    ban->name = &str_empty[0];
recycle.c:    free_pstring(ban->name);
recycle.c:    ban->next = ban_free;
recycle.c:	descriptor_free = descriptor_free->next;
recycle.c:    free_pstring( d->host );
recycle.c:    if(d->outbuf)
recycle.c:    	delete[] d->outbuf;
recycle.c:    d->next = descriptor_free;
recycle.c:	gen_data_free = gen_data_free->next;
recycle.c:    gen->next = gen_data_free;
recycle.c:	trophy->victname = palloc_string(victname);
recycle.c:	trophy->next = NULL;
recycle.c:	if(trophy->next == NULL) {
recycle.c:		free_trophy(trophy->next);
recycle.c:	speech->next = NULL;
recycle.c:	speech->prev = NULL;
recycle.c:	speech->mob = NULL;
recycle.c:	speech->name = NULL;
recycle.c:	speech->first_line = NULL;
recycle.c:	speech->current_line = NULL;
recycle.c:	free_pstring(speech->name);
recycle.c:	if (speech->next) {
recycle.c:		if (speech->prev) {
recycle.c:			speech->prev->next = speech->next;
recycle.c:			speech->next->prev = speech->prev;
recycle.c:			speech->mob->speech = speech->next;
recycle.c:	free_pstring(line->text);
recycle.c:	if (line->next) {
recycle.c:		if (line->prev) {
recycle.c:			line->prev->next = line->next;
recycle.c:			line->next->prev = line->prev;
recycle.c:			line->speech->first_line = line->next;
recycle.c:	for (lptr = line; lptr; lptr = lptr->next)
recycle.c:		lptr->number--;
recycle.c:	line->speech = NULL;
recycle.c:	line->next = NULL;
recycle.c:	line->prev = NULL;
recycle.c:	line->number = -1;
recycle.c:	line->delay = -1;
recycle.c:	line->type = -1;
recycle.c:	line->text = NULL;
recycle.c:	ipr->wear_name = NULL;
recycle.c:	ipr->remove_name = NULL;
recycle.c:	ipr->get_name = NULL;
recycle.c:	ipr->loot_name = NULL;
recycle.c:	ipr->drop_name = NULL;
recycle.c:	ipr->sac_name = NULL;
recycle.c:	ipr->sac_name = NULL;
recycle.c:	ipr->entry_name = NULL;
recycle.c:	ipr->give_name = NULL;
recycle.c:	ipr->greet_name = NULL;
recycle.c:	ipr->fight_name = NULL;
recycle.c:	ipr->death_name = NULL;
recycle.c:	ipr->speech_name = NULL;
recycle.c:	ipr->pulse_name = NULL;
recycle.c:	ipr->invoke_name = NULL;
recycle.c:	ipr->open_name = NULL;
recycle.c:	ipr->look_name = NULL;
recycle.c:	ipr->verb_name = NULL;
recycle.c:	ipr->hit_name = NULL;
recycle.c:	race_specs->next = NULL;
recycle.c:	race_specs->first = NULL;
recycle.c:	race_specs->name = NULL;
recycle.c:	race_specs->number = -1;
recycle.c:	zero_vector(race_specs->act);
recycle.c:	zero_vector(race_specs->aff);
recycle.c:	zero_vector(race_specs->off);
recycle.c:	zero_vector(race_specs->imm);
recycle.c:	zero_vector(race_specs->res);
recycle.c:	zero_vector(race_specs->vuln);
recycle.c:	zero_vector(race_specs->form);
recycle.c:	zero_vector(race_specs->parts);
recycle.c:	if (race_specs->next == NULL) {
recycle.c:		free_race_data(race_specs->next);
recycle.c:	tracks->prey = NULL;
recycle.c:	tracks->time = time_info;
recycle.c:	tracks->direction = -1;
recycle.c:	path->room 		=	NULL;
recycle.c:	path->evaluated	=	FALSE;
recycle.c:	path->dir_from	=	-1;
recycle.c:	path->steps		=	-1;
recycle.c:	path->prev		=	NULL;
recycle.c:		path->dir_to[i] = NULL;
recycle.c:	if (!path->dir_to[DIR_NORTH]
recycle.c:		&& !path->dir_to[DIR_EAST]
recycle.c:		&& !path->dir_to[DIR_SOUTH]
recycle.c:		&& !path->dir_to[DIR_WEST]
recycle.c:		&& !path->dir_to[DIR_UP]
recycle.c:		&& !path->dir_to[DIR_DOWN]) {
recycle.c:			if (path->dir_to[i])
recycle.c:				free_path(path->dir_to[i]);
recycle.c:/* stuff for recycling extended descs -- UGLY */
recycle.c:	extra_descr_free = extra_descr_free->next;
recycle.c:    ed->keyword = &str_empty[0];
recycle.c:    ed->description = &str_empty[0];
recycle.c:    free_pstring(ed->keyword);
recycle.c:    free_pstring(ed->description);
recycle.c:    ed->next = extra_descr_free;
recycle.c:		apply_free = apply_free->next;
recycle.c:	app->next = apply_free;
recycle.c:	affect_free = affect_free->next;
recycle.c:	free_pstring(trap->exec_echo);
recycle.c:	free_pstring(trap->trig_echo);
recycle.c:	rune_free = rune->next;
recycle.c:    rune->next = rune_free;
recycle.c:        queue_free = queue->next;
recycle.c:    queue->next = queue_free;
recycle.c:    free_pstring(af->name);
recycle.c:    af->next = affect_free;
recycle.c:        raffect_free = raffect_free->next;
recycle.c:    af->next = raffect_free;
recycle.c:		oaffect_free = oaffect_free->next;
recycle.c:	af->next = oaffect_free;
recycle.c:		aaffect_free = aaffect_free->next;
recycle.c:	af->next = aaffect_free;
recycle.c:	obj_free = obj_free->next;
recycle.c:    for (paf = obj->affected; paf != NULL; paf = paf_next)
recycle.c:	paf_next = paf->next;
recycle.c:    obj->affected = NULL;
recycle.c:    for (ed = obj->extra_descr; ed != NULL; ed = ed_next )
recycle.c:	ed_next = ed->next;
recycle.c:     obj->extra_descr = NULL;
recycle.c:    free_pstring( obj->name        );
recycle.c:    free_pstring( obj->description );
recycle.c:    free_pstring( obj->short_descr );
recycle.c:   // free_pstring( obj->owner     );
recycle.c:    obj->next   = obj_free;
recycle.c:	char_free = char_free->next;
recycle.c:    ch->name                    = &str_empty[0];
recycle.c:    ch->short_descr             = &str_empty[0];
recycle.c:    ch->long_descr              = &str_empty[0];
recycle.c:    ch->description             = &str_empty[0];
recycle.c:    ch->prompt                  = &str_empty[0];
recycle.c:    ch->prefix			= &str_empty[0];
recycle.c:    ch->logon                   = current_time;
recycle.c:    ch->lines                   = PAGELEN;
recycle.c:        ch->armor[i]            = 0;
recycle.c:    ch->position                = POS_STANDING;
recycle.c:    ch->hit                     = 20;
recycle.c:    ch->max_hit                 = 20;
recycle.c:    ch->mana                    = 100;
recycle.c:    ch->max_mana                = 100;
recycle.c:    ch->move                    = 100;
recycle.c:    ch->max_move                = 100;
recycle.c:    ch->arms					= 2;
recycle.c:    ch->legs					= 2;
recycle.c:	ch->regen_rate				= 0;
recycle.c:    ch->balance					= 0;
recycle.c:	ch->batter					= 0;
recycle.c:	ch->analyze					= 0;
recycle.c:	ch->talismanic				= 0;
recycle.c:    ch->law_pass				= FALSE;
recycle.c:	zero_vector(ch->imm_flags);
recycle.c:        ch->perm_stat[i] = 13;
recycle.c:        ch->mod_stat[i] = 0;
recycle.c:	mobile_count--;
recycle.c:    for (obj = ch->carrying; obj != NULL; obj = obj_next)
recycle.c:		obj_next = obj->next_content;
recycle.c:    for (paf = ch->affected; paf != NULL; paf = paf_next)
recycle.c:		paf_next = paf->next;
recycle.c:		paf->pulse_fun	= NULL;
recycle.c:		paf->tick_fun	= NULL;
recycle.c:		paf->end_fun	= NULL;
recycle.c:    free_pstring(ch->name);
recycle.c:    free_pstring(ch->short_descr);
recycle.c:    free_pstring(ch->long_descr);
recycle.c:    free_pstring(ch->true_name);
recycle.c:    free_pstring(ch->description);
recycle.c:    free_pstring(ch->prompt);
recycle.c:    free_pstring(ch->prefix);
recycle.c:    if (ch->pcdata != NULL)
recycle.c:    	free_pcdata(ch->pcdata);
recycle.c:    ch->next = char_free;
recycle.c:	pcdata_free = pcdata_free->next;
recycle.c:	pcdata->alias[alias] = NULL;
recycle.c:	pcdata->alias_sub[alias] = NULL;
recycle.c:    pcdata->buffer = new_buf();
recycle.c:	pcdata->trusting = NULL;
recycle.c:	pcdata->death_status = 0;
recycle.c:        oldtype_free = oldtype_free->next;
recycle.c:	free_pstring(old->name);
recycle.c:	free_pstring(old->short_descr);
recycle.c:	free_pstring(old->long_descr);
recycle.c:	free_pstring(old->description);
recycle.c:	old->next = oldtype_free;
recycle.c:    free_pstring(pcdata->pwd);
recycle.c:    free_pstring(pcdata->bamfin);
recycle.c:    free_pstring(pcdata->bamfout);
recycle.c:    free_pstring(pcdata->title);
recycle.c:    free_buf(pcdata->buffer);
recycle.c:		if(pcdata->recentkills[i] != NULL)
recycle.c:			free_pstring(pcdata->recentkills[i]);
recycle.c:		if(pcdata->alias[alias] != NULL)
recycle.c:			free_pstring(pcdata->alias[alias]);
recycle.c:			free_pstring(pcdata->alias_sub[alias]);
recycle.c:    pcdata->next = pcdata_free;
recycle.c:	mem_data_free = mem_data_free->next;
recycle.c:    memory->next = NULL;
recycle.c:    memory->id = 0;
recycle.c:    memory->reaction = 0;
recycle.c:    memory->when = 0;
recycle.c:    memory->next = mem_data_free;
recycle.c:/* -1 indicates out-of-boundary error */
recycle.c:    return -1;
recycle.c:		buf_free = buf_free->next;
recycle.c:    buffer->next	= NULL;
recycle.c:    buffer->state	= BUFFER_SAFE;
recycle.c://    buffer->size	= get_size(BASE_BUF);
recycle.c://    buffer->string	= palloc_struct(buffer->size);
recycle.c://    buffer->string[0]	= '\0';					JUST SAY NO TO DIKU.  --D
recycle.c:    buffer->size	= 0;
recycle.c:    buffer->string	= NULL;
recycle.c:    if(buffer->string)
recycle.c:        free_pstring(buffer->string);
recycle.c:    buffer->string = NULL;
recycle.c:    buffer->size   = 0;
recycle.c:    buffer->state  = BUFFER_FREED;
recycle.c:    buffer->next  = buf_free;
recycle.c:    if (!buffer->string || !strlen(buffer->string)) //like a virgin.. touched for the very first tiiiiime
recycle.c:	buffer->string = palloc_string(string);
recycle.c:	buffer->size = strlen(string) + 1;
recycle.c:    len = strlen(buffer->string) + strlen(string) + 1;
recycle.c:	tptr = buffer->string;
recycle.c:    buffer->string = new char[len];
recycle.c:    if(!buffer->string)
recycle.c:	buffer->size = len;
recycle.c:	strcpy(buffer->string, tptr);
recycle.c:    strcat(buffer->string, string);
recycle.c:    free_pstring(buffer->string);
recycle.c:    buffer->string = NULL;
recycle.c:    buffer->state     = BUFFER_SAFE;
recycle.c:    return buffer->string;
rprog.c:		room->rprogs->pulse_prog = NULL;
rprog.c:		free_pstring(room->rprogs->pulse_name);
rprog.c:		REMOVE_BIT(room->progtypes, RPROG_PULSE);
rprog.c:		room->rprogs->entry_prog = NULL;
rprog.c:		free_pstring(room->rprogs->entry_name);
rprog.c:		REMOVE_BIT(room->progtypes, RPROG_ENTRY);
rprog.c:		room->rprogs->move_prog = NULL;
rprog.c:		free_pstring(room->rprogs->move_name);
rprog.c:		REMOVE_BIT(room->progtypes, RPROG_MOVE);
rprog.c:		room->rprogs->drop_prog = NULL;
rprog.c:		free_pstring(room->rprogs->drop_name);
rprog.c:		REMOVE_BIT(room->progtypes, RPROG_DROP);
rprog.c:		room->rprogs->speech_prog = NULL;
rprog.c:		free_pstring(room->rprogs->speech_name);
rprog.c:		REMOVE_BIT(room->progtypes, RPROG_SPEECH);
rprog.c:		room->rprogs->open_prog = NULL;
rprog.c:		free_pstring(room->rprogs->open_name);
rprog.c:		REMOVE_BIT(room->progtypes, RPROG_OPEN);
rprog.c:		return bug("Lood_improgs: 'R': Function not found for vnum %d",room->vnum);
rprog.c:			room->rprogs->pulse_prog = (RPROG_FUN_PULSE *)rprog_table[i].function;
rprog.c:				free_pstring(room->rprogs->pulse_name);
rprog.c:			room->rprogs->pulse_name = palloc_string(name);
rprog.c:			SET_BIT(room->progtypes, RPROG_PULSE);
rprog.c:			room->rprogs->entry_prog = (RPROG_FUN_ENTRY *)rprog_table[i].function;
rprog.c:				free_pstring(room->rprogs->entry_name);
rprog.c:			room->rprogs->entry_name = palloc_string(name);
rprog.c:			SET_BIT(room->progtypes, RPROG_ENTRY);
rprog.c:			room->rprogs->move_prog = (RPROG_FUN_MOVE *)rprog_table[i].function;
rprog.c:			if(room->progtypes)
rprog.c:			free_pstring(room->rprogs->move_name);
rprog.c:			room->rprogs->move_name = palloc_string(name);
rprog.c:			SET_BIT(room->progtypes, RPROG_MOVE);
rprog.c:			room->rprogs->drop_prog = (RPROG_FUN_DROP *)rprog_table[i].function;
rprog.c:				free_pstring(room->rprogs->drop_name);
rprog.c:			room->rprogs->drop_name = palloc_string(name);
rprog.c:			SET_BIT(room->progtypes, RPROG_DROP);
rprog.c:		room->rprogs->speech_prog = (RPROG_FUN_SPEECH *)rprog_table[i].function;
rprog.c:			free_pstring(room->rprogs->speech_name);
rprog.c:		room->rprogs->speech_name = palloc_string(name);
rprog.c:		SET_BIT(room->progtypes, RPROG_SPEECH);
rprog.c:		room->rprogs->open_prog = (RPROG_FUN_OPEN *)rprog_table[i].function;
rprog.c:			free_pstring(room->rprogs->open_name);
rprog.c:		room->rprogs->open_name = palloc_string(name);
rprog.c:		SET_BIT(room->progtypes, RPROG_OPEN);
rprog.c:	bug ("Load_improgs: 'R': invalid program type for vnum %d", room->vnum);
rprog.c:	if (!room->people)
rprog.c:	act("The sewer grate emits a soft burbling sound, and a stench fills the air.",room->people,0,0,TO_ALL);
rprog.c:	if(!room->people)
rprog.c:	act("Conversations buffet you, and your eyes are drawn to a sign on the wall.",room->people,0,0,TO_ALL);
rprog.c:	for (vch = cliff->people; vch; vch = vch->next_in_room) {
rprog.c:		if (vch->pIndexData->vnum == 9010) {
rprog.c:		sprintf(buf,"%sThe weathered old man ceases his flute-playing and regards you intently.%s",get_char_color(ch,"magenta"),END_COLOR(ch));
rprog.c:	damage_new(ch,ch,dice(ch->level,2),TYPE_UNDEFINED,DAM_BASH,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"twisted ankle");
rprog.c:	if (number_percent() < 20 && ch->legs > 0)
rprog.c:		af.level = ch->level;
rprog.c:		af.modifier = -4;
rprog.c:		af.modifier = -1;
rprog.c:	for(obj2 = ch->carrying; obj2 != NULL; obj2 = obj2->next_content) {
rprog.c:		if(obj2->pIndexData->vnum == 24596) {
rprog.c:	if(!IS_SET(exit->exit_info,EX_LOCKED))
rprog.c:	EXIT_DATA *exit = room->exit[dir];
rprog.c:	for(obj = ch->carrying; obj != NULL; obj = obj->next) {
rprog.c:		if(obj->pIndexData->vnum == 24596) {
rprog.c:	if(IS_SET(exit->exit_info,EX_CLOSED))
rprog.c:    SET_BIT(exit->exit_info,EX_CLOSED);
rprog.c:    SET_BIT(exit->exit_info,EX_LOCKED);
rprog.c:	if(room->people)
rprog.c:		act("The eastern door slams shut.",room->people,0,0,TO_ROOM);
rprog.c:	EXIT_DATA *exit = room->exit[dir];
rprog.c:	if(IS_SET(exit->exit_info,EX_CLOSED))
rprog.c:	SET_BIT(exit->exit_info,EX_CLOSED);
rprog.c:	SET_BIT(exit->exit_info,EX_LOCKED);
rprog.c:	SET_BIT(exit->exit_info,EX_NONOBVIOUS);
rprog.c:	if(!room->people)
rprog.c:	for(ch = room->people; ch != NULL; ch = ch->next_in_room)
rprog.c:	do_murder(snake,ch->name);
rprog.c:	int dir = exit->orig_door;
rprog.c:	EXIT_DATA *exit = room2->exit[DIR_EAST];
rprog.c:	if(IS_SET(exit->exit_info,EX_CLOSED))
rprog.c:	SET_BIT(exit->exit_info,EX_CLOSED);
rprog.c:	SET_BIT(exit->exit_info,EX_LOCKED);
rprog.c:	SET_BIT(exit->exit_info,EX_NONOBVIOUS);
rprog.c:	for(corpse = room->contents; corpse != NULL; corpse = corpse->next) {
rprog.c:		if(corpse->pIndexData->vnum == 24558) {
rprog.c:	if(corpse->contains)
rprog.c:	if(obj->pIndexData->vnum != (4637 || 4638 || 4639 || 4640 || 4641))
rprog.c:		REMOVE_BIT(room->exit[DIR_DOWN]->exit_info,EX_CLOSED);
rprog.c:		REMOVE_BIT(room->exit[DIR_DOWN]->exit_info,EX_NONOBVIOUS);
rprog.c:		REMOVE_BIT(room->exit[DIR_DOWN]->exit_info,EX_LOCKED);
rprog.c:	CHAR_DATA *ch=room->people;
rprog.c:	for(obj=room->contents; obj != NULL; obj=obj->next_content) {
rprog.c:		if(obj->pIndexData->vnum == (4637 || 4638 || 4639 || 4640 || 4641)) {
rstring.c:	return (int)*(myString-1);
rstring.c:	*(myString - 1) = nRef;
rstring.c:	SetRefCount(RefCount()-1);
rstring.c:		SetRefCount(RefCount() - 1);
rstring.c:	myString--;
rstring.c:	return (int)(i-myString);
rstring.c:		return -1;
rstring.c:	return (cptr - myString);
rstring.c:		return -1;
rstring.c:	return (cptr - myString);
rstring.c:	return (Find(substr, 0, fIgnoreCase) > -1);
rstring.c:			*(myString + i) += 'A' - 'a';
rstring.c:			*(myString + i) += 'a' - 'A';
rstring.c:		*myString += 'A' - 'a';
rstring.c:			*(myString + i) += 'a' - 'A';
rstring.c:	*this->Format(arglist, msg);
save.c:	/* Morg - Valgrind fix */
save.c:                buf[pos] = 'a' + (count - 26);
save.c: * Array of containers read for proper re-nesting of objects.
save.c:    if ( ch->desc != NULL && ch->desc->original != NULL )
save.c:	ch = ch->desc->original;
save.c:	if (!check_parse_name(ch->true_name)) {
save.c:		ch->pcdata->frags[PK_KILLS], ch->level, ch->Class()->GetIndex(), ch->race, ch->cabal, ch->pcdata->true_sex,
save.c:		(ch->played + current_time - ch->logon) / 3600,ch->alignment,ch->pcdata->ethos,ch->gold+ch->gold_bank,ch->true_name);
save.c:	sprintf(strsave, "%s%s.plr",PLAYER_DIR, capitalize(ch->true_name));
save.c:	if(ch->carrying)
save.c:	    fwrite_obj( ch, ch->carrying, fp, 0 );
save.c:	if(!ch->carrying && ch->pcdata->old && ch->pcdata->old->carrying)
save.c:	    fwrite_obj( ch, ch->pcdata->old->carrying, fp, 0);
save.c:	if (ch->pet != NULL && ch->pet->in_room == ch->in_room)
save.c:	    fwrite_pet(ch->pet,fp);
save.c:        for (search = char_list; search != NULL; search = search->next)
save.c:                if (IS_NPC(search) && (search->master == ch) && 
save.c:			(IS_SET(search->act,ACT_UNDEAD) || (!strcmp(ch->Class()->name,"necromancer") && 
save.c:				!IS_SET(search->act, ACT_PET)))
save.c:                      /*  && search->in_room->vnum==ch->in_room->vnum */ && IS_AFFECTED(search,AFF_CHARM))
save.c:    fprintf(fp, "%d %d %s~ %s~\n",	ch->pIndexData->vnum, ch->in_room->vnum, ch->name, ch->short_descr);
save.c:    fprintf(fp, "%s~\n",	ch->long_descr);
save.c:    fprintf(fp, "%d %d %d %d\n",	ch->level, ch->max_hit, ch->hit, ch->size);
save.c:    fprintf(fp, "%d %d %d %d %d\n",ch->alignment, ch->damage[DICE_NUMBER], ch->damage[DICE_TYPE], ch->damroll, ch->defense_mod);
save.c:	free_pstring(charmed->short_descr);
save.c:	free_pstring(charmed->long_descr);
save.c:	free_pstring(charmed->name);
save.c:	charmed->name		= fread_string(fp);
save.c:	charmed->short_descr= fread_string(fp);
save.c:	charmed->long_descr	= fread_string(fp);
save.c:	charmed->level		= fread_number(fp);
save.c:	charmed->max_hit	= fread_number(fp);
save.c:	charmed->hit		= fread_number(fp);
save.c:	charmed->size		= fread_number(fp);
save.c:	charmed->alignment		= fread_number(fp);
save.c:	charmed->damage[DICE_NUMBER]	= fread_number(fp);
save.c:	charmed->damage[DICE_TYPE]	= fread_number(fp);
save.c:	charmed->damroll		= fread_number(fp);
save.c:	charmed->defense_mod	= fread_number(fp);
save.c:	charmed->leader		= ch;
save.c:	af.level	= ch->level;
save.c:	af.duration	= -1;
save.c:	if(charmed->pIndexData->vnum==MOB_VNUM_ZOMBIE)
save.c:    fprintf( fp, "Name %s~\n",	ch->true_name		);
save.c:    fprintf( fp, "Id   %ld\n", ch->id			);
save.c:    if (!ch->pcdata->old && ch->short_descr[0] != '\0')
save.c:      	fprintf( fp, "ShD  %s~\n",	ch->short_descr	);
save.c:    if (ch->pcdata->old && ch->pcdata->old->short_descr[0]!='\0')
save.c:	fprintf(fp,"ShD  %s~\n",	ch->pcdata->old->short_descr);
save.c:    if(!ch->pcdata->old && ch->long_descr[0] != '\0')
save.c:	fprintf( fp, "LnD  %s~\n",	ch->long_descr	);
save.c:    if (ch->pcdata->old && ch->pcdata->old->long_descr[0]!='\0')
save.c:        fprintf(fp,"LnD  %s~\n",        ch->pcdata->old->long_descr);
save.c:    if(!ch->pcdata->old && ch->description[0] != '\0')
save.c:    	fprintf( fp, "Desc %s~\n",	ch->description	);
save.c:    if(ch->pcdata->old && ch->pcdata->old->description[0] != '\0')
save.c:	fprintf( fp, "Desc %s~\n",	ch->pcdata->old->description);
save.c:    if (ch->prompt != NULL || !str_cmp(ch->prompt,"<%hhp %mm %vmv> "))
save.c:        fprintf( fp, "Prom %s~\n",      ch->prompt  	);
save.c:    fprintf( fp, "Race %s~\n", pc_race_table[ch->race].name );
save.c:    if (ch->cabal)
save.c:        fprintf( fp, "Cabal %s~\n",cabal_table[ch->cabal].name);
save.c:		fprintf( fp, "CabalLevel %d\n",ch->pcdata->cabal_level);
save.c:	if (ch->cabal == CABAL_HORDE)
save.c:		fprintf( fp, "Tribe %d\n",ch->pcdata->tribe	);
save.c:    fprintf( fp, "Sex  %d\n",	ch->sex			);
save.c:	fprintf( fp, "Beauty %d\n", ch->pcdata->beauty);
save.c:	fprintf( fp, "Cla  %s~\n",	(RSTR)ch->Class()->name);
save.c:    fprintf( fp, "Levl %d\n",	ch->level		);
save.c:    if (ch->trust != 0)
save.c:	fprintf( fp, "Tru  %d\n",	ch->trust	);
save.c:    fprintf( fp, "Sec  %d\n",    ch->pcdata->security	);	/* OLC */
save.c:	ch->played + (int) (current_time - ch->logon)	);
save.c:    fprintf( fp, "Agemod %d\n",	ch->pcdata->age_mod);
save.c:	if (ch->pcdata->death_status == HAS_DIED)
save.c:	fprintf(fp,"Died %d\n",	ch->pcdata->death_status);
save.c:	fprintf(fp,"Dtime %d\n",ch->pcdata->death_timer);
save.c:	ch->pcdata->last_note,ch->pcdata->last_idea,ch->pcdata->last_penalty,
save.c:	ch->pcdata->last_news,ch->pcdata->last_changes	);
save.c:    fprintf( fp, "Scro %d\n", 	ch->lines		);
save.c:    fprintf( fp, "HomeTown %d\n",ch->hometown);
save.c:        (  ch->in_room == get_room_index( ROOM_VNUM_LIMBO )
save.c:        && ch->was_in_room != NULL )
save.c:            ? ch->was_in_room->vnum
save.c:            : ch->in_room == NULL ? ROOM_VNUM_TEMPLE : ch->in_room->vnum );
save.c:	ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move );
save.c:    if (ch->pcdata->death_count == 0)
save.c:	fprintf( fp, "Deaths %d\n", ch->pcdata->death_count);
save.c:     if (ch->pcdata->sp == 0)
save.c:	fprintf( fp, "Sp %d\n",ch->pcdata->sp);
save.c:    fprintf( fp, "RollTime %ld\n",	ch->pcdata->roll_time);
save.c:    fprintf( fp, "Born %d\n",		ch->pcdata->birth_date);
save.c:    fprintf( fp, "DeathTime %d\n",	ch->pcdata->death_time);
save.c:	fprintf(fp, "Styles %s\n", print_flags(ch->pcdata->styles));
save.c:    fprintf( fp, "Instyle %d\n",	ch->pcdata->style);
save.c:    fprintf( fp, "Special %d\n",	ch->pcdata->special);
save.c:    fprintf( fp, "Bounty %ld\n",  	ch->pcdata->bounty	);
save.c:	fprintf( fp, "BountyKilled %d\n",	ch->pcdata->bounty_killed);
save.c:	fprintf( fp, "Paladin_path %d\n",	ch->pcdata->paladin_path);
save.c:	if (ch->Class()->GetIndex() == CLASS_SORCERER) {
save.c:		fprintf( fp, "EleMaj %d\n",	ch->pcdata->ele_major);
save.c:		fprintf( fp, "ElePar %d\n", ch->pcdata->ele_para);
save.c:	if(ch->Class()->GetIndex() == CLASS_NECROMANCER) {
save.c:		fprintf(fp, "Souls %d\n", ch->pcdata->souls);
save.c:	if (ch->gold > 0)
save.c:      fprintf( fp, "Gold %ld\n",	ch->gold		);
save.c:    if (ch->gold_bank > 0)
save.c:      fprintf( fp, "Bgold %ld\n",	ch->gold_bank		);
save.c:    fprintf( fp, "Exp  %d\n",	ch->exp			);
save.c:    if (ch->act != 0)
save.c:	fprintf( fp, "Act  %s\n",   print_flags(ch->act));
save.c:    if (ch->affected_by != 0)
save.c:	fprintf( fp, "AfBy %s\n",   print_flags(ch->affected_by));
save.c:    fprintf( fp, "Comm %s\n",       print_flags(ch->comm));
save.c:    if (ch->wiznet)
save.c:    	fprintf( fp, "Wizn %s\n",   print_flags(ch->wiznet));
save.c:    if (ch->invis_level)
save.c:	fprintf( fp, "Invi %d\n", 	ch->invis_level	);
save.c:    if (ch->incog_level)
save.c:	fprintf(fp,"Inco %d\n",ch->incog_level);
save.c:	ch->position == POS_FIGHTING ? POS_STANDING : ch->position );
save.c:    if (ch->practice != 0)
save.c:    	fprintf( fp, "Prac %d\n",	ch->practice	);
save.c:    if (ch->train != 0)
save.c:	fprintf( fp, "Trai %d\n",	ch->train	);
save.c:    if (ch->saving_throw != 0 && !ch->pcdata->old)
save.c:	fprintf( fp, "Save  %d\n",	ch->saving_throw);
save.c:    if (ch->saving_throw != 0 && ch->pcdata->old)
save.c:        fprintf( fp, "Save  %d\n",      ch->pcdata->old->saving_throw);
save.c:    fprintf( fp, "Alig  %d\n",	ch->alignment		);
save.c:    fprintf( fp, "Etho  %d\n",  ch->pcdata->ethos       );
save.c:    fprintf( fp, "OAli  %d\n",  ch->pcdata->oalign      );
save.c:    fprintf( fp, "OEth  %d\n",  ch->pcdata->oethos      );
save.c:    fprintf( fp, "Indu  %d\n",  ch->pcdata->induct      );
save.c:    if (ch->hitroll != 0)
save.c:	fprintf( fp, "Hit   %d\n",	ch->hitroll	);
save.c:    if (ch->damroll != 0)
save.c:	fprintf( fp, "Dam   %d\n",	ch->damroll	);
save.c:    if(!ch->pcdata->old)
save.c:    fprintf( fp, "ACs %d %d %d %d\n", ch->armor[0],ch->armor[1],ch->armor[2],ch->armor[3]);
save.c:	ch->pcdata->old->armor[0],ch->pcdata->old->armor[1],ch->pcdata->old->armor[2],ch->pcdata->old->armor[3]);
save.c:    fprintf( fp, "BCredits %d\n",	ch->pcdata->bounty_credits);
save.c:	fprintf( fp, "TrSet %s\n", print_flags(ch->pcdata->trust));
save.c:		if (ch->pcdata->quests[pos] > 0)
save.c:			fprintf(fp,"Quest %d %d\n", pos, ch->pcdata->quests[pos]);
save.c:	fprintf(fp,"Rep %d\n",  ch->pcdata->reputation);
save.c:    		fprintf(fp, "CScheme %s %s\n",	color_event[pos].event_name, ch->pcdata->color_scheme[pos]);
save.c:	fprintf(fp,"%ld ",ch->pcdata->sect_time[pos]);
save.c:    fprintf( fp, "-1\n");
save.c:    fprintf( fp, "Newbie %d~\n",	ch->pcdata->newbie );
save.c:	fprintf( fp, "Immune %s\n", print_flags(ch->imm_flags));
save.c:	fprintf( fp, "Vuln %s\n", print_flags(ch->vuln_flags));
save.c:	fprintf( fp, "Resist %s\n", print_flags(ch->res_flags));
save.c:    if(ch->pcdata->start_weapon >= 0)
save.c:    	fprintf( fp, "StartWeap %d\n",	ch->pcdata->start_weapon);
save.c:    if (ch->wimpy !=0 )
save.c:		fprintf( fp, "Wimp  %d\n",	ch->wimpy	);
save.c:	fprintf(fp,"%d%c",ch->pcdata->deposited_items[i], i == MAX_STORED_ITEMS - 1 ? '\n' : ' ');
save.c:    if(!ch->pcdata->old)
save.c:	ch->perm_stat[STAT_STR],
save.c:	ch->perm_stat[STAT_INT],
save.c:	ch->perm_stat[STAT_WIS],
save.c:	ch->perm_stat[STAT_DEX],
save.c:	ch->perm_stat[STAT_CON] );
save.c:    if(ch->pcdata->old)
save.c:        ch->pcdata->old->perm_stats[STAT_STR],
save.c:        ch->pcdata->old->perm_stats[STAT_INT],
save.c:        ch->pcdata->old->perm_stats[STAT_WIS],
save.c:        ch->pcdata->old->perm_stats[STAT_DEX],
save.c:        ch->pcdata->old->perm_stats[STAT_CON] );
save.c:	ch->mod_stat[STAT_STR],
save.c:	ch->mod_stat[STAT_INT],
save.c:	ch->mod_stat[STAT_WIS],
save.c:	ch->mod_stat[STAT_DEX],
save.c:	ch->mod_stat[STAT_CON] );
save.c:	fprintf( fp, "Vnum %d\n",	ch->pIndexData->vnum	);
save.c:	fprintf( fp, "Pass %s~\n",	ch->pcdata->pwd		);
save.c:	if (ch->pcdata->bamfin[0] != '\0')
save.c:	    fprintf( fp, "Bin  %s~\n",	ch->pcdata->bamfin);
save.c:	if (ch->pcdata->bamfout[0] != '\0')
save.c:		fprintf( fp, "Bout %s~\n",	ch->pcdata->bamfout);
save.c:	if (ch->pcdata->imm_death)
save.c:		fprintf( fp, "Dmsg %s~\n", ch->pcdata->imm_death);
save.c:	fprintf( fp, "Titl %s~\n",	ch->pcdata->title	);
save.c:	if(ch->pcdata->extitle) fprintf( fp, "EXTitl %s~\n", ch->pcdata->extitle);
save.c:	fprintf( fp, "TSex %d\n",	ch->pcdata->true_sex	);
save.c:	fprintf( fp, "LLev %d\n",	ch->pcdata->last_level	);
save.c:	fprintf( fp, "HMVP %d %d %d\n", ch->pcdata->perm_hit,
save.c:						   ch->pcdata->perm_mana,
save.c:						   ch->pcdata->perm_move);
save.c:	    ch->pcdata->condition[0],
save.c:	    ch->pcdata->condition[1],
save.c:	    ch->pcdata->condition[2],
save.c:	    ch->pcdata->condition[3],
save.c:	    ch->pcdata->condition[4],
save.c:	    ch->pcdata->condition[5]);
save.c:	        ch->pcdata->kills[PK_KILLS],
save.c:		ch->pcdata->kills[PK_GOOD],
save.c:		ch->pcdata->kills[PK_NEUTRAL],
save.c:		ch->pcdata->kills[PK_EVIL]);
save.c:		(int)((float)(ch->pcdata->frags[PK_KILLS] * 1000000)),
save.c:		(int)((float)(ch->pcdata->frags[PK_GOOD] * 1000000)),
save.c:		(int)((float)(ch->pcdata->frags[PK_NEUTRAL] * 1000000)),
save.c:		(int)((float)(ch->pcdata->frags[PK_EVIL]) * 1000000));
save.c:	        ch->pcdata->killed[PK_KILLED],
save.c:		ch->pcdata->killed[MOB_KILLED]);
save.c:	fprintf( fp, "frgd %d\n", (int)((float)(ch->pcdata->fragged * 1000000)));
save.c:	if (ch->pcdata->recentkills[0] && ch->pcdata->recentkills[0][0] != '\0')  {
save.c:			if (ch->pcdata->recentkills[i] == NULL)
save.c:			fprintf(fp, "%s ", ch->pcdata->recentkills[i]);
save.c:	if (ch->Class()->name == "anti-paladin") {
save.c:			fprintf(fp, "%d ", ch->pcdata->lesserdata[i]);
save.c:			fprintf(fp, "%d ", ch->pcdata->greaterdata[i]);
save.c:			fprintf(fp, "%d ", ch->pcdata->devildata[i]);
save.c:	    if (ch->pcdata->alias[pos] == NULL
save.c:	    ||  ch->pcdata->alias_sub[pos] == NULL)
save.c:	    fprintf(fp,"Alias %s %s~\n",ch->pcdata->alias[pos],
save.c:		    ch->pcdata->alias_sub[pos]);
save.c:	    if ( skill_table[sn].name != NULL && (ch->pcdata->learned[sn] > 0
save.c:		|| ch->pcdata->learned[sn] == -2 ))
save.c:		    ch->pcdata->learned[sn], skill_table[sn].name );
save.c:            if ( group_table[gn].name != NULL && ch->pcdata->group_known[gn])
save.c:    for ( paf = ch->affected; paf != NULL; paf = paf->next )
save.c:	if (paf->type < 0 || paf->type>= MAX_SKILL)
save.c:	if (paf->type == gsn_word_of_command)
save.c:	paf->aftype = isAftSpell(paf->aftype);
save.c:	    skill_table[paf->type].name,
save.c:	    paf->where,
save.c:	    paf->level,
save.c:	    paf->duration,
save.c:	    paf->modifier,
save.c:	    paf->location,
save.c:		print_flags(paf->bitvector),
save.c:	    paf->aftype,
save.c:		(paf->owner) ? (paf->owner->name) : "none",
save.c:		(paf->name) ? (paf->name) : "none"
save.c:	if (ch->pcdata->trophy && ch->pcdata->trophy->victname
save.c:		&& ch->cabal == CABAL_HORDE
save.c:		&& belt->pIndexData->vnum == OBJ_VNUM_TROPHY_BELT
save.c:		&& belt->value[4] >= 1)
save.c:		fprintf(fp,"%d ",belt->value[4]);
save.c:		placeholder = ch->pcdata->trophy;
save.c:		for (j=1;j<=belt->value[4];j++) {
save.c:			if (!ch->pcdata->trophy) 		break;
save.c:			fprintf(fp,"%s%s",ch->pcdata->trophy->victname," ");
save.c:			if (!ch->pcdata->trophy->next)	break;
save.c:			ch->pcdata->trophy = ch->pcdata->trophy->next;
save.c:		ch->pcdata->trophy = placeholder;
save.c:	if (ch->pcdata->logon_time)
save.c:		fprintf(fp,"LogonTime %s~\n",ch->pcdata->logon_time);
save.c:	fprintf(fp,"TimePlayed %d~\n",(int) ((current_time - ch->logon) / 60 ));
save.c:	if (ch->pcdata->history_buffer != NULL)
save.c:		fprintf(fp,"History %s~\n",ch->pcdata->history_buffer);
save.c:        if (ch->pcdata->role != NULL)
save.c:                fprintf(fp,"Role %s~\n",ch->pcdata->role);
save.c:			fprintf(fp, " %d", obj->pIndexData->vnum);
save.c:    fprintf(fp,"Vnum %d\n",pet->pIndexData->vnum);
save.c:    fprintf(fp,"Name %s~\n", pet->name);
save.c:    if (pet->short_descr != pet->pIndexData->short_descr)
save.c:    	fprintf(fp,"ShD  %s~\n", pet->short_descr);
save.c:    if (pet->long_descr != pet->pIndexData->long_descr)
save.c:    	fprintf(fp,"LnD  %s~\n", pet->long_descr);
save.c:    if (pet->description != pet->pIndexData->description)
save.c:    	fprintf(fp,"Desc %s~\n", pet->description);
save.c:    if (pet->race != pet->pIndexData->race)
save.c:    	fprintf(fp,"Race %s~\n", race_data_lookup(pet->race)->name);
save.c:    if (pet->cabal)
save.c:        fprintf( fp, "Cabal %s~\n",cabal_table[pet->cabal].name);
save.c:    fprintf(fp,"Sex  %d\n", pet->sex);
save.c:    if (pet->level != pet->pIndexData->level)
save.c:    	fprintf(fp,"Levl %d\n", pet->level);
save.c:    	pet->hit, pet->max_hit, pet->mana, pet->max_mana, pet->move, pet->max_move);
save.c:    if (pet->gold > 0)
save.c:    	fprintf(fp,"Gold %ld\n",pet->gold);
save.c:    if (pet->exp > 0)
save.c:    	fprintf(fp, "Exp  %d\n", pet->exp);
save.c:    if (pet->act != pet->pIndexData->act)
save.c:    	fprintf(fp, "Act  %s\n", print_flags(pet->act));
save.c:    if (pet->affected_by != pet->pIndexData->affected_by)
save.c:    	fprintf(fp, "AfBy %s\n", print_flags(pet->affected_by));
save.c:    if (pet->comm != 0)
save.c:    	fprintf(fp, "Comm %s\n", print_flags(pet->comm));
save.c:    fprintf(fp,"Pos  %d\n", pet->position = POS_FIGHTING ? POS_STANDING : pet->position);
save.c:    if (pet->saving_throw != 0)
save.c:    	fprintf(fp, "Save %d\n", pet->saving_throw);
save.c:    if (pet->alignment != pet->pIndexData->alignment)
save.c:    	fprintf(fp, "Alig %d\n", pet->alignment);
save.c:    if (pet->hitroll != pet->pIndexData->hitroll)
save.c:    	fprintf(fp, "Hit  %d\n", pet->hitroll);
save.c:    if (pet->damroll != pet->pIndexData->damage[DICE_BONUS])
save.c:    	fprintf(fp, "Dam  %d\n", pet->damroll);
save.c:    	pet->armor[0],pet->armor[1],pet->armor[2],pet->armor[3]);
save.c:    	pet->perm_stat[STAT_STR], pet->perm_stat[STAT_INT],
save.c:    	pet->perm_stat[STAT_WIS], pet->perm_stat[STAT_DEX],
save.c:    	pet->perm_stat[STAT_CON]);
save.c:    	pet->mod_stat[STAT_STR], pet->mod_stat[STAT_INT],
save.c:    	pet->mod_stat[STAT_WIS], pet->mod_stat[STAT_DEX],
save.c:    	pet->mod_stat[STAT_CON]);
save.c:    for ( paf = pet->affected; paf != NULL; paf = paf->next )
save.c:    	if (paf->type < 0 || paf->type >= MAX_SKILL)
save.c:	paf->aftype = isAftSpell(paf->aftype);
save.c:    	    skill_table[paf->type].name,
save.c:    	    paf->where,
save.c:			paf->level,
save.c:			paf->duration,
save.c:			paf->modifier,
save.c:			paf->location,
save.c:			print_flags(paf->bitvector),
save.c:			paf->aftype,
save.c:			(paf->owner) ? (paf->owner->name) : "none",
save.c:			(paf->name) ? (paf->name) : "none");
save.c:    if ( obj->next_content != NULL )
save.c:	fwrite_obj( ch, obj->next_content, fp, iNest );
save.c:    if ( obj->item_type == ITEM_KEY
save.c:    ||   (obj->item_type == ITEM_MAP && !obj->value[0]))
save.c:    fprintf( fp, "Vnum %d\n",   obj->pIndexData->vnum        );
save.c:    if (!obj->pIndexData->new_format)
save.c:    if ( str_cmp(obj->name, obj->pIndexData->name))
save.c:    	fprintf( fp, "Name %s~\n",	obj->name		     );
save.c:    if ( str_cmp(obj->short_descr, obj->pIndexData->short_descr))
save.c:        fprintf( fp, "ShD  %s~\n",	obj->short_descr	     );
save.c:    if ( str_cmp(obj->description,obj->pIndexData->description))
save.c:        fprintf( fp, "Desc %s~\n",	obj->description	     );
save.c:    if (obj->owner != "")
save.c:		fprintf( fp, "Owner %s~\n",	obj->owner );
save.c:    if ( !vector_equal(obj->extra_flags, obj->pIndexData->extra_flags))
save.c:		fprintf(fp, "ExtF %s\n", print_flags(obj->extra_flags));
save.c:    if ( !vector_equal(obj->wear_flags, obj->pIndexData->wear_flags))
save.c:		fprintf(fp, "WeaF %s\n", print_flags(obj->wear_flags));
save.c:    if ( obj->item_type != obj->pIndexData->item_type)
save.c:		fprintf( fp, "Ityp %d\n",   obj->item_type           );
save.c:    if ( obj->weight != obj->pIndexData->weight)
save.c:        fprintf( fp, "Wt   %d\n",	obj->weight		     );
save.c:	if ( str_cmp (obj->material, obj->pIndexData->material))
save.c:		fprintf( fp, "Mat  %s~\n",	obj->material			 );
save.c:	if (obj->wear_loc_name)
save.c:		fprintf( fp, "WLName %s~\n", obj->wear_loc_name);
save.c:    if ( obj->condition != obj->pIndexData->condition)
save.c:		fprintf( fp, "Cond %d\n",	obj->condition		     );
save.c:    fprintf( fp, "Wear %d\n",   obj->wear_loc                );
save.c:    if (obj->level != obj->pIndexData->level)
save.c:        fprintf( fp, "Lev  %d\n",	obj->level		     );
save.c:    if (obj->timer != 0)
save.c:        fprintf( fp, "Time %d\n",	obj->timer	     );
save.c:    fprintf( fp, "Cost %d\n",	obj->cost		     );
save.c:    if (obj->value[0] != obj->pIndexData->value[0]
save.c:    ||  obj->value[1] != obj->pIndexData->value[1]
save.c:    ||  obj->value[2] != obj->pIndexData->value[2]
save.c:    ||  obj->value[3] != obj->pIndexData->value[3]
save.c:    ||  obj->value[4] != obj->pIndexData->value[4])
save.c:	    obj->value[0], obj->value[1], obj->value[2], obj->value[3],
save.c:	    obj->value[4]	     );
save.c:    switch ( obj->item_type )
save.c:	if ( obj->value[1] > 0 )
save.c:		skill_table[obj->value[1]].name );
save.c:	if ( obj->value[2] > 0 )
save.c:		skill_table[obj->value[2]].name );
save.c:	if ( obj->value[3] > 0 )
save.c:		skill_table[obj->value[3]].name );
save.c:	if ( obj->value[3] > 0 )
save.c:		skill_table[obj->value[3]].name );
save.c:    for ( paf = obj->affected; paf != NULL; paf = paf->next )
save.c:	if (paf->type < 0 || paf->type >= MAX_SKILL)
save.c:	paf->aftype = isAftSpell(paf->aftype);
save.c:            skill_table[paf->type].name,
save.c:            paf->where,
save.c:            paf->level,
save.c:            paf->duration,
save.c:            paf->modifier,
save.c:            paf->location,
save.c:			print_flags(paf->bitvector),
save.c:            paf->aftype,
save.c:			(paf->owner) ? (paf->owner->name) : "none"
save.c:	if ((ed = obj->extra_descr) != NULL)
save.c:		if ((!obj->pIndexData->extra_descr)
save.c:			|| (str_cmp(ed->keyword,obj->pIndexData->extra_descr->keyword)))
save.c:				fprintf( fp, "ExDe %s~ %s~\n", ed->keyword, ed->description );
save.c:    if ( obj->contains != NULL )
save.c:	fwrite_obj( ch, obj->contains, fp, iNest + 1 );
save.c:    ch->pcdata = new_pcdata();
save.c:	d->character			= ch;
save.c:	ch->desc			= d;
save.c:    ch->pcdata->entering_text		= FALSE;
save.c:    ch->name				= palloc_string( name );
save.c:    ch->id				= get_pc_id();
save.c:    ch->race				= race_lookup("human");
save.c:    SET_BIT(ch->act, PLR_NOSUMMON);
save.c:	SET_BIT(ch->comm, COMM_COMBINE);
save.c:	SET_BIT(ch->comm, COMM_PROMPT);
save.c:    zero_vector(ch->pcdata->trust);
save.c:    ch->prompt 				= palloc_string("<%hhp %mm %vmv> ");
save.c:		ch->pcdata->queue[i][0] = '\0';
save.c:	ch->pcdata->read_next = 0;
save.c:	ch->pcdata->write_next = 0;
save.c:	ch->pcdata->pending = 0;
save.c:    ch->pcdata->confirm_delete		= FALSE;
save.c:    ch->pcdata->pwd			= NULL;
save.c:    ch->pcdata->bamfin			= palloc_string( "" );
save.c:    ch->pcdata->bamfout			= palloc_string( "" );
save.c:    ch->pcdata->title			= palloc_string( "" );
save.c:    ch->pcdata->roll_time		= current_time;
save.c:    ch->pcdata->birth_date		= 1516; //rs starts in 1515
save.c:    ch->pcdata->death_time		= 500;
save.c:    ch->pcdata->style			= 0;
save.c:    zero_vector(ch->pcdata->styles);
save.c:	ch->perm_stat[stat]		= 13;
save.c:	ch->pcdata->sect_time[stat] = 0;
save.c:	ch->pcdata->deposited_items[stat] = 0;
save.c:    ch->pcdata->condition[COND_THIRST]	= 0;
save.c:    ch->pcdata->condition[COND_FULL]	= 0;
save.c:    ch->pcdata->condition[COND_HUNGER]	= 0;
save.c:    ch->pcdata->condition[COND_STARVING] = 0;
save.c:    ch->pcdata->condition[COND_DEHYDRATED] = 0;
save.c:	ch->pcdata->security      = 0;    /* OLC */
save.c:	ch->pcdata->bounty	    = 0;
save.c:    ch->pcdata->bounty_credits = 0;
save.c:	ch->bounty_timer		=	0;
save.c:    ch->pcdata->end_fun		= NULL;
save.c:    ch->pcdata->energy_state	= 0;
save.c:    ch->dam_mod = 100;
save.c:    ch->pcdata->shifted	    = -1;
save.c:    ch->defense_mod = 0;
save.c:    ch->pcdata->tribe	= 0;
save.c:    ch->pcdata->save_timer = 0;
save.c:	ch->disrupted = FALSE;
save.c:	ch->stolen_from = FALSE;
save.c:	ch->pcdata->souls = 0;
save.c:	ch->position = 0;
save.c:	ch->pcdata->cabal_level = 0;
save.c:	ch->pcdata->bounty_killed = 0;
save.c:	ch->pcdata->paladin_path = 0;
save.c:	ch->pcdata->editing_item = 0;
save.c:    	ch->pcdata->recentkills[pos] = NULL;
save.c:		ch->pcdata->color_scheme[pos] = color_event[pos].default_color;
save.c:		ch->pcdata->quests[pos] = 0;
save.c:	sprintf(buf,"gzip -dfq %s",strsave);
save.c:	free_pstring(ch->true_name);
save.c:	ch->true_name = palloc_string(name);
save.c:	free_pstring(ch->backup_true_name);
save.c:	ch->backup_true_name = palloc_string(name);
save.c:	/* Morg - Valgrind fix */
save.c:	zero_vector(ch->imm_flags);
save.c:	zero_vector(ch->res_flags);
save.c:	zero_vector(ch->vuln_flags);
save.c:		if (ch->race == 0)
save.c:	    	ch->race = race_lookup("human");
save.c:		ch->size = pc_race_table[ch->race].size;
save.c:		ch->dam_type = 17; /*punch */
save.c:	    	if (pc_race_table[ch->race].skills[i] == NULL)
save.c:	    	group_add(ch,pc_race_table[ch->race].skills[i],FALSE);
save.c:		BITWISE_OR(ch->affected_by, race_data_lookup(ch->race)->aff);
save.c:		BITWISE_OR(ch->imm_flags, race_data_lookup(ch->race)->imm);
save.c:		BITWISE_OR(ch->res_flags, race_data_lookup(ch->race)->res);
save.c:		BITWISE_OR(ch->vuln_flags, race_data_lookup(ch->race)->vuln);
save.c:		copy_vector(ch->form, race_data_lookup(ch->race)->form);
save.c:		copy_vector(ch->parts, race_data_lookup(ch->race)->parts);
save.c:	BITWISE_OR(ch->imm_flags, limmune_flags);
save.c:	BITWISE_OR(ch->res_flags, lres_flags);
save.c:	BITWISE_OR(ch->vuln_flags, lvuln_flags);
save.c:    if (found && ch->version < 2)  /* need to add the new skills */
save.c:		group_add(ch,ch->Class()->base_group,FALSE);
save.c:		group_add(ch,ch->Class()->default_group,TRUE);
save.c:		ch->pcdata->learned[gsn_recall] = 50;
save.c:    sprintf(buf,"Loading %s.",ch->name);
save.c:    ch->pcdata->newbie = FALSE;
save.c:	    KEYV( "Act",		ch->act);
save.c:	    KEYV( "AffectedBy",	ch->affected_by);
save.c:	    KEY( "Agemod",	ch->pcdata->age_mod,	fread_number( fp ));
save.c:	    KEYV( "AfBy",	ch->affected_by);
save.c:	    KEY( "Alignment",	ch->alignment,		fread_number( fp ) );
save.c:	    KEY( "Alig",	ch->alignment,		fread_number( fp ) );
save.c:		ch->pcdata->alias[count] 	= fread_word(fp);
save.c:		ch->pcdata->alias_sub[count]	= fread_string(fp);
save.c:			ch->pcdata->alias[count]        = fread_word(fp);
save.c:			ch->pcdata->alias_sub[count]    = fread_string(fp);
save.c:		    ch->armor[i] = fread_number(fp);
save.c:                    paf->type = sn;
save.c:                paf->where  	= fread_number(fp);
save.c:                paf->level      = fread_number( fp );
save.c:                paf->duration   = fread_number( fp );
save.c:                paf->modifier   = fread_number( fp );
save.c:                paf->location   = fread_number( fp );
save.c:		fread_flag_new(paf->bitvector, fp);
save.c:                paf->aftype  	= fread_number( fp );
save.c:		for (wch = char_list; wch; wch = wch->next) {
save.c:			if (!str_cmp(wch->name,owner)) {
save.c:				paf->owner = wch;
save.c:		if (!str_cmp(ch->name,owner))
save.c:			paf->owner = ch;
save.c:			paf->name = palloc_string(afname);
save.c:                paf->next       = ch->affected;
save.c:                ch->affected    = paf;
save.c:				ch->pcdata->devildata[i] = fread_number( fp);
save.c:		   ch->mod_stat[stat] = fread_number(fp);
save.c:		    ch->perm_stat[stat] = fread_number(fp);
save.c:	    KEY( "Bgold",	ch->gold_bank,		fread_number( fp ) );
save.c:	    KEY( "Bamfin",	ch->pcdata->bamfin,	fread_string( fp ) );
save.c:	    KEY( "Bamfout",	ch->pcdata->bamfout,	fread_string( fp ) );
save.c:	    KEY( "Bin",		ch->pcdata->bamfin,	fread_string( fp ) );
save.c:	    KEY( "Bout",	ch->pcdata->bamfout,	fread_string( fp ) );
save.c:	    KEY( "Bounty",	ch->pcdata->bounty,	fread_number( fp ) );
save.c:	    KEY( "BCredits",	ch->pcdata->bounty_credits, fread_number( fp ));
save.c:	    KEY( "Born",	ch->pcdata->birth_date,	fread_number( fp ) );
save.c:		KEY( "Beauty",	ch->pcdata->beauty, fread_number( fp ) );
save.c:		KEY( "BountyKilled", ch->pcdata->bounty_killed, fread_number( fp));
save.c:			ch->SetClass(CClass::Lookup(fread_string(fp)));
save.c:        KEY( "Cabal",        ch->cabal, cabal_lookup(fread_string(fp)));
save.c:		KEY( "CabalLevel",	ch->pcdata->cabal_level,	fread_number( fp ) );
save.c:		ch->pcdata->condition[0] = fread_number( fp );
save.c:		ch->pcdata->condition[1] = fread_number( fp );
save.c:		ch->pcdata->condition[2] = fread_number( fp );
save.c:		ch->pcdata->condition[3] = fread_number( fp );
save.c:		if (ch->version > 5)
save.c:		ch->pcdata->condition[4] = fread_number( fp );
save.c:		ch->pcdata->condition[5] = fread_number( fp );
save.c:		ch->pcdata->condition[0] = fread_number( fp );
save.c:		ch->pcdata->condition[1] = fread_number( fp );
save.c:		ch->pcdata->condition[2] = fread_number( fp );
save.c:		ch->pcdata->condition[3] = fread_number( fp );
save.c:		if (ch->version > 5)
save.c:		ch->pcdata->condition[4] = fread_number( fp );
save.c:		ch->pcdata->condition[5] = fread_number( fp );
save.c:		ch->pcdata->condition[4] = 0;
save.c:		ch->pcdata->condition[5] = 0;
save.c:			ch->pcdata->color_scheme[get_event_number(fread_word(fp))] = get_color_name(fread_word(fp));
save.c:	    KEYV("Comm",		ch->comm);
save.c:   	KEY( "Deaths",	ch->pcdata->death_count,	fread_number( fp ) );
save.c:  	KEY( "Died",	ch->pcdata->death_status,	fread_number( fp ) );
save.c:	KEY( "Dtime",	ch->pcdata->death_timer,	fread_number( fp ) );
save.c:	KEY( "Damroll",	ch->damroll,		fread_number( fp ) );
save.c:	KEY( "Dam",		ch->damroll,		fread_number( fp ) );
save.c:    KEY( "Description",	ch->description,	fread_string( fp ) );
save.c:	KEY( "Desc",	ch->description,	fread_string( fp ) );
save.c:	KEY( "DeathTime", ch->pcdata->death_time,	fread_number( fp ) );
save.c:	KEY( "Dmsg",	ch->pcdata->imm_death,		fread_string( fp ) );
save.c:			ch->pcdata->deposited_items[i] = fread_number(fp);
save.c:		KEY ( "EleMaj",	ch->pcdata->ele_major,	fread_number( fp ) );
save.c:		KEY ( "ElePar",	ch->pcdata->ele_para,	fread_number( fp ) );
save.c:                ch->pcdata->extitle = fread_string( fp );
save.c:                if (ch->pcdata->extitle[0] != '.' && ch->pcdata->extitle[0] != ','
save.c:                &&  ch->pcdata->extitle[0] != '!' && ch->pcdata->extitle[0] != '?')
save.c:                    sprintf( buf, " %s", ch->pcdata->extitle );
save.c:                    free_pstring( ch->pcdata->extitle );
save.c:                    ch->pcdata->extitle = palloc_string( buf );
save.c:				if(ch->pcdata->extitle[0]=='\0')
save.c:					free_pstring(ch->pcdata->extitle);
save.c:    		/* adjust hp mana move up  -- here for speed's sake */
save.c:    		percent = (current_time - lastlogoff) * 25 / ( 2 * 60 * 60);
save.c:        	    ch->hit	+= (ch->max_hit - ch->hit) * percent / 100;
save.c:        	    ch->mana    += (ch->max_mana - ch->mana) * percent / 100;
save.c:        	    ch->move    += (ch->max_move - ch->move)* percent / 100;
save.c:            KEY( "Etho",        ch->pcdata->ethos,      fread_number( fp ) );
save.c:            KEY( "Exp",         ch->exp,                fread_number( fp ) );
save.c:			/*if((form = form_lookup(fread_string(fp)))>-1)
save.c:				ch->pcdata->forms[form] = fread_number(fp);*/
save.c:			ch->pcdata->frags[PK_KILLS] = (float)((float)fread_number(fp) / (float)1000000);
save.c:			ch->pcdata->frags[PK_GOOD] = (float)((float)fread_number(fp) / (float)1000000);
save.c:			ch->pcdata->frags[PK_NEUTRAL] = (float)((float)fread_number(fp) / (float)1000000);
save.c:			ch->pcdata->frags[PK_EVIL] = (float)((float)fread_number(fp) / (float)1000000);
save.c:			ch->pcdata->fragged = (float)(fread_number(fp) / 1000000);
save.c:	    KEY( "Gold",	ch->gold,		fread_number( fp ) );
save.c:				ch->pcdata->greaterdata[i] = fread_number( fp );
save.c:            KEY( "History",	ch->pcdata->history_buffer,	fread_string( fp ) );
save.c:	    KEY( "Hitroll",	ch->hitroll,		fread_number( fp ) );
save.c:	    KEY( "Hit",		ch->hitroll,		fread_number( fp ) );
save.c:	    KEY( "HomeTown",	ch->hometown,		fread_number( fp ) );
save.c:		ch->pcdata->temp_history_buffer = NULL;
save.c:		ch->hit		= fread_number( fp );
save.c:		ch->max_hit	= fread_number( fp );
save.c:		ch->mana	= fread_number( fp );
save.c:		ch->max_mana	= fread_number( fp );
save.c:		ch->move	= fread_number( fp );
save.c:		ch->max_move	= fread_number( fp );
save.c:                ch->pcdata->perm_hit	= fread_number( fp );
save.c:                ch->pcdata->perm_mana   = fread_number( fp );
save.c:                ch->pcdata->perm_move   = fread_number( fp );
save.c:	    KEY( "Id",		ch->id,			fread_number( fp ) );
save.c:            KEY( "Indu",        ch->pcdata->induct,     fread_number( fp ) );
save.c:	    KEY( "InvisLevel",	ch->invis_level,	fread_number( fp ) );
save.c:	    KEY( "Inco",	ch->incog_level,	fread_number( fp ) );
save.c:	    KEY( "Invi",	ch->invis_level,	fread_number( fp ) );
save.c:	    KEY( "Instyle",	ch->pcdata->style,	fread_number( fp ) );
save.c:		ch->pcdata->kills[PK_KILLS] = fread_number( fp );
save.c:		ch->pcdata->kills[PK_GOOD] = fread_number( fp );
save.c:		ch->pcdata->kills[PK_NEUTRAL] = fread_number( fp );
save.c:		ch->pcdata->kills[PK_EVIL] = fread_number( fp );
save.c:		ch->pcdata->killed[PK_KILLED] = fread_number( fp );
save.c:		ch->pcdata->killed[MOB_KILLED] = fread_number( fp );
save.c:	    KEY( "LastLevel",	ch->pcdata->last_level, fread_number( fp ) );
save.c:	    KEY( "LLev",	ch->pcdata->last_level, fread_number( fp ) );
save.c:	    KEY( "Level",	ch->level,		fread_number( fp ) );
save.c:	    KEY( "Lev",		ch->level,		fread_number( fp ) );
save.c:	    KEY( "Levl",	ch->level,		fread_number( fp ) );
save.c:	    KEY( "LongDescr",	ch->long_descr,		fread_string( fp ) );
save.c:	    KEY( "LnD",		ch->long_descr,		fread_string( fp ) );
save.c:				ch->pcdata->lesserdata[i] = fread_number( fp );
save.c:	    KEY( "Name",	ch->name,		fread_string( fp ) );
save.c:	    KEY( "Note",	ch->pcdata->last_note,	fread_number( fp ) );
save.c:		ch->pcdata->last_note			= fread_number(fp);
save.c:		ch->pcdata->last_idea			= fread_number(fp);
save.c:		ch->pcdata->last_penalty		= fread_number(fp);
save.c:		ch->pcdata->last_news			= fread_number(fp);
save.c:		ch->pcdata->last_changes		= fread_number(fp);
save.c:	    KEY( "Newbie",	ch->pcdata->newbie,	fread_number( fp ) );
save.c:            KEY( "OAli",        ch->pcdata->oalign,     fread_number( fp ) );
save.c:            KEY( "OEth",        ch->pcdata->oethos,     fread_number( fp ) );
save.c:		KEY( "Paladin_path",	ch->pcdata->paladin_path,	fread_number( fp ));
save.c:	    KEY( "Password",	ch->pcdata->pwd,	fread_string( fp ) );
save.c:	    KEY( "Pass",	ch->pcdata->pwd,	fread_string( fp ) );
save.c:	    KEY( "Played",	ch->played,		fread_number( fp ) );
save.c:	    KEY( "Plyd",	ch->played,		fread_number( fp ) );
save.c:	    KEY( "Position",	ch->position,		fread_number( fp ) );
save.c:	    KEY( "Pos",		ch->position,		fread_number( fp ) );
save.c:	    KEY( "Practice",	ch->practice,		fread_number( fp ) );
save.c:	    KEY( "Prac",	ch->practice,		fread_number( fp ) );
save.c:        KEY( "Prompt",      ch->prompt,             fread_string( fp ) );
save.c: 	    KEY( "Prom",	ch->prompt,		fread_string( fp ) );
save.c:			ch->pcdata->quests[fread_number(fp)] = fread_number(fp);
save.c:	    KEY( "Race",        ch->race,	
save.c:		KEY( "Rep", 		ch->pcdata->reputation,	fread_number(fp));
save.c:        KEY( "Role",     	ch->pcdata->role,     	fread_string( fp ) );
save.c:	    KEY( "RollTime",	ch->pcdata->roll_time,	fread_number(fp));
save.c:		ch->in_room = get_room_index( fread_number( fp ) );
save.c:		if ( ch->in_room == NULL )
save.c:		    ch->in_room = get_room_index( ROOM_VNUM_LIMBO );
save.c:				ch->pcdata->recentkills[i] = palloc_string(word);
save.c:	    KEY( "SavingThrow",	ch->saving_throw,	fread_number( fp ) );
save.c:	    KEY( "Save",	ch->saving_throw,	fread_number( fp ) );
save.c:	    KEY( "Scro",	ch->lines,		fread_number( fp ) );
save.c:	    KEY( "Sex",		ch->sex,		fread_number( fp ) );
save.c:	    KEY( "ShortDescr",	ch->short_descr,	fread_string( fp ) );
save.c:	    KEY( "ShD",		ch->short_descr,	fread_string( fp ) );
save.c:		KEY( "Sec",         ch->pcdata->security,   fread_number( fp ) );   /* OLC */
save.c:		KEY( "Sp",		ch->pcdata->sp,		fread_number( fp ) );
save.c:	    KEYV( "Styles",	ch->pcdata->styles);
save.c:	    KEY( "Special",	ch->pcdata->special,	fread_number( fp ) );
save.c:		KEY( "Souls",	ch->pcdata->souls, 	fread_number( fp ) );
save.c:	    KEY( "StartWeap",	ch->pcdata->start_weapon,fread_number(fp ) );
save.c:		    	ch->pcdata->learned[sn] = value;
save.c:			while((i=fread_number(fp))!=-1)
save.c:				ch->pcdata->sect_time[x] = i;
save.c:            KEY( "TrueSex",     ch->pcdata->true_sex,  	fread_number( fp ) );
save.c:	    KEY( "TSex",	ch->pcdata->true_sex,   fread_number( fp ) );
save.c:	    KEY( "Trai",	ch->train,		fread_number( fp ) );
save.c:	    KEY( "Trust",	ch->trust,		fread_number( fp ) );
save.c:	    KEYV( "TrSet",	ch->pcdata->trust);
save.c:	    KEY( "Tru",		ch->trust,		fread_number( fp ) );
save.c:	    KEY( "Tribe",	ch->pcdata->tribe,	fread_number( fp ) );
save.c:		ch->pcdata->title = fread_string( fp );
save.c:    		if (ch->pcdata->title[0] != '.' && ch->pcdata->title[0] != ','
save.c:		&&  ch->pcdata->title[0] != '!' && ch->pcdata->title[0] != '?')
save.c:		    sprintf( buf, " %s", ch->pcdata->title );
save.c:		    free_pstring( ch->pcdata->title );
save.c:		    ch->pcdata->title = palloc_string( buf );
save.c:			ch->pcdata->trophy = new_trophy_data (fread_word(fp));
save.c:			placeholder = ch->pcdata->trophy;
save.c:				ch->pcdata->trophy = ch->pcdata->trophy->next = new_trophy_data (fread_word(fp));
save.c:				if(!str_cmp(ch->pcdata->trophy->victname,"XYZ")) {	
save.c:					free_pstring(ch->pcdata->trophy->victname);
save.c:			ch->pcdata->trophy = placeholder;
save.c:	    KEY( "Version",     ch->version,		fread_number ( fp ) );
save.c:	    KEY( "Vers",	ch->version,		fread_number ( fp ) );
save.c:		ch->pIndexData = get_mob_index( fread_number( fp ) );
save.c:	    KEY( "Wimpy",	ch->wimpy,		fread_number( fp ) );
save.c:	    KEY( "Wimp",	ch->wimpy,		fread_number( fp ) );
save.c:	    KEYV( "Wizn",	ch->wiznet);
save.c:    	    KEYV( "Act",		pet->act);
save.c:    	    KEYV( "AfBy",	pet->affected_by);
save.c:    	    KEY( "Alig",	pet->alignment,		fread_number(fp));
save.c:    	    	    pet->armor[i] = fread_number(fp);
save.c:                   paf->type = sn;
save.c:		paf->where	= fread_number(fp);
save.c:                paf->level      = fread_number(fp);
save.c:                paf->duration   = fread_number(fp);
save.c:                paf->modifier   = fread_number(fp);
save.c:                paf->location   = fread_number(fp);
save.c:		fread_flag_new(paf->bitvector, fp);
save.c:                paf->aftype  	= fread_number(fp);
save.c:			paf->owner = ch;
save.c:		for (wch = char_list; wch; wch = wch->next)
save.c:			if (!str_cmp(wch->name,owner)) {
save.c:				paf->owner = wch;
save.c:		if (str_cmp(afname,"none")) paf->name = palloc_string(afname);
save.c:		paf->next       = pet->affected;
save.c:                pet->affected   = paf;
save.c:    	     	    pet->mod_stat[stat] = fread_number(fp);
save.c:    	             pet->perm_stat[stat] = fread_number(fp);
save.c:    	     KEYV( "Comm",	pet->comm);
save.c:             KEY( "Cabal",       pet->cabal, cabal_lookup(fread_string(fp)));
save.c:    	     KEY( "Dam",	pet->damroll,		fread_number(fp));
save.c:    	     KEY( "Desc",	pet->description,	fread_string(fp));
save.c:		pet->leader = ch;
save.c:		pet->master = ch;
save.c:		ch->pet = pet;
save.c:    		/* adjust hp mana move up  -- here for speed's sake */
save.c:    		percent = (current_time - lastlogoff) * 25 / ( 2 * 60 * 60);
save.c:    		    pet->hit	+= (pet->max_hit - pet->hit) * percent / 100;
save.c:        	    pet->mana   += (pet->max_mana - pet->mana) * percent / 100;
save.c:        	    pet->move   += (pet->max_move - pet->move)* percent / 100;
save.c:    	     KEY( "Exp",	pet->exp,		fread_number(fp));
save.c:    	     KEY( "Gold",	pet->gold,		fread_number(fp));
save.c:    	     KEY( "Hit",	pet->hitroll,		fread_number(fp));
save.c:    	     	pet->hit	= fread_number(fp);
save.c:    	     	pet->max_hit	= fread_number(fp);
save.c:    	     	pet->mana	= fread_number(fp);
save.c:    	     	pet->max_mana	= fread_number(fp);
save.c:    	     	pet->move	= fread_number(fp);
save.c:    	     	pet->max_move	= fread_number(fp);
save.c:    	     KEY( "Levl",	pet->level,		fread_number(fp));
save.c:    	     KEY( "LnD",	pet->long_descr,	fread_string(fp));
save.c:    	     KEY( "Name",	pet->name,		fread_string(fp));
save.c:    	     KEY( "Pos",	pet->position,		fread_number(fp));
save.c:    	    KEY( "Race",	pet->race, race_lookup(fread_string(fp)));
save.c:    	    KEY( "Save",	pet->saving_throw,	fread_number(fp));
save.c:    	    KEY( "Sex",		pet->sex,		fread_number(fp));
save.c:    	    KEY( "ShD",		pet->short_descr,	fread_string(fp));
save.c:	    obj = create_object(get_obj_index(vnum),-1);
save.c:	    obj->pIndexData->limcount -= 1;
save.c:    	obj->name		= palloc_string( "" );
save.c:    	obj->short_descr	= palloc_string( "" );
save.c:    	obj->description	= palloc_string( "" );
save.c:                    paf->type = sn;
save.c:		paf->where	= fread_number( fp );
save.c:                paf->level      = fread_number( fp );
save.c:                paf->duration   = fread_number( fp );
save.c:                paf->modifier   = fread_number( fp );
save.c:                paf->location   = fread_number( fp );
save.c:		fread_flag_new(paf->bitvector, fp);
save.c:                paf->aftype  	= fread_number( fp );
save.c:		for (wch = char_list; wch; wch = wch->next) {
save.c:			if (!str_cmp(wch->name,owner)) {
save.c:				paf->owner = wch;
save.c:		if (!str_cmp(ch->name,owner))
save.c:			paf->owner = ch;
save.c:                paf->next       = obj->affected;
save.c:                obj->affected   = paf;
save.c:	    KEY( "Cond",	obj->condition,		fread_number( fp ) );
save.c:	    KEY( "Cost",	obj->cost,		fread_number( fp ) );
save.c:	    KEY( "Description",	obj->description,	fread_string( fp ) );
save.c:	    KEY( "Desc",	obj->description,	fread_string( fp ) );
save.c:	    KEYV( "ExtraFlags",	obj->extra_flags);
save.c:			zero_vector(obj->extra_flags);
save.c:			KEYV( "ExtF",	obj->extra_flags);
save.c:			ed->keyword			= fread_string( fp );
save.c:			if ((obj->extra_descr != NULL)
save.c:				&& !str_cmp(ed->keyword,obj->extra_descr->keyword)) {
save.c:				ed->description		= fread_string( fp );
save.c:				ed->next			= obj->extra_descr;
save.c:				obj->extra_descr	= ed;
save.c:		if ( !fNest || ( fVnum && obj->pIndexData == NULL ) )
save.c:		    free_pstring( obj->name        );
save.c:		    free_pstring( obj->description );
save.c:		    free_pstring( obj->short_descr );
save.c:		    obj->next = obj_free;
save.c:		        free_pstring( obj->name        );
save.c:		        free_pstring( obj->description );
save.c:			free_pstring( obj->short_descr );
save.c:			obj->next = obj_free;
save.c:		    	obj->next	= object_list;
save.c:		    	obj->pIndexData->count++;
save.c:		    if (!obj->pIndexData->new_format
save.c:		    && obj->item_type == ITEM_ARMOR
save.c:		    &&  obj->value[1] == 0)
save.c:			obj->value[1] = obj->value[0];
save.c:			obj->value[2] = obj->value[0];
save.c:			wear = obj->wear_loc;
save.c:			obj->pIndexData->limcount += 1;		
save.c:			obj = create_object(obj->pIndexData,0);
save.c:			obj->pIndexData->limcount -= 1;
save.c:			obj->wear_loc = wear;
save.c:			obj_to_obj( obj, rgObjNest[iNest-1] );
save.c:	    KEY( "ItemType",	obj->item_type,		fread_number( fp ) );
save.c:	    KEY( "Ityp",	obj->item_type,		fread_number( fp ) );
save.c:	    KEY( "Level",	obj->level,		fread_number( fp ) );
save.c:	    KEY( "Lev",		obj->level,		fread_number( fp ) );
save.c:		KEY( "Mat",		obj->material,	fread_string ( fp ) );
save.c:	    KEY( "Name",	obj->name,		fread_string( fp ) );
save.c:	    KEY( "Owner",	obj->owner,		fread_string( fp));
save.c:		if (obj->pIndexData != NULL && obj->pIndexData->new_format)
save.c:	    //KEY( "ResF",        obj->restrict_flags,    fread_number( fp ) );
save.c:	    KEY( "ShortDescr",	obj->short_descr,	fread_string( fp ) );
save.c:	    KEY( "ShD",		obj->short_descr,	fread_string( fp ) );
save.c:		    obj->value[iValue] = sn;
save.c:	    KEY( "Timer",	obj->timer,		fread_number( fp ) );
save.c:	    KEY( "Time",	obj->timer,		fread_number( fp ) );
save.c:		obj->value[0]	= fread_number( fp );
save.c:		obj->value[1]	= fread_number( fp );
save.c:		obj->value[2]	= fread_number( fp );
save.c:		obj->value[3]	= fread_number( fp );
save.c:		if (obj->item_type == ITEM_WEAPON && obj->value[0] == 0)
save.c:		   obj->value[0] = obj->pIndexData->value[0];
save.c:		obj->value[0] 	= fread_number( fp );
save.c:	 	obj->value[1]	= fread_number( fp );
save.c:	 	obj->value[2] 	= fread_number( fp );
save.c:		obj->value[3]	= fread_number( fp );
save.c:		obj->value[4]	= fread_number( fp );
save.c:		if ( ( obj->pIndexData = get_obj_index( vnum ) ) == NULL )
save.c:	    KEYV( "WearFlags",	obj->wear_flags);
save.c:	    KEYV( "WeaF",	obj->wear_flags);
save.c:		KEY( "WLName",	obj->wear_loc_name,	fread_string(fp) );
save.c:	    KEY( "WearLoc",	obj->wear_loc,		fread_number( fp ) );
save.c:	    KEY( "Wear",	obj->wear_loc,		fread_number( fp ) );
save.c:	    KEY( "Weight",	obj->weight,		fread_number( fp ) );
save.c:	    KEY( "Wt",		obj->weight,		fread_number( fp ) );
scan.c:   else if (!str_cmp(arg1, "a") || !str_cmp(arg1, "all"))   door = -1;
scan.c:   if(door==-1)
scan.c:   if(is_affected_area(ch->in_room->area, gsn_cyclone))
scan.c:	if(is_affected_room(ch->in_room, gsn_smokescreen))
scan.c:   scan_room = ch->in_room;
scan.c:	   depth--;
scan.c:   if (ch->in_room->area->sky == SKY_DRIZZLE ||
scan.c:	   ch->in_room->area->sky == SKY_FLURRY ||
scan.c:	   ch->in_room->area->sky == SKY_HAIL) {
scan.c:	   depth--;
scan.c:   if (ch->in_room->area->sky == SKY_DOWNPOUR ||
scan.c:	   ch->in_room->area->sky == SKY_TSTORM ||
scan.c:	   ch->in_room->area->sky == SKY_BLIZZARD) {
scan.c:	   depth -= 2;
scan.c:   if (ch->in_room->area->wind > 2) 	
scan.c:	   depth--;
scan.c:		   && obj->pIndexData->vnum == OBJ_VNUM_CRYSTAL) {
scan.c:		   af = affect_find_obj(obj->affected,gsn_fashion_crystal);
scan.c:			   depth += af->modifier/100;
scan.c:	   if ((pExit = scan_room->exit[door]) != NULL) {
scan.c:		   if (!IS_SET(pExit->exit_info, EX_CLOSED) || IS_SET(pExit->exit_info,EX_TRANSLUCENT)) {
scan.c:			   scan_room = pExit->u1.to_room;
scan.c:			   if(IS_SET(pExit->exit_info,EX_NONOBVIOUS))
scan.c:			   scan_list(pExit->u1.to_room, ch, i, door);
scan.c:   sprintf(buf2, distance[(depth-1)], dir_name[door]);
scan.c:   for (rch=scan_room->people; rch != NULL; rch=rch->next_in_room) {
scan.c:	   if (!IS_NPC(rch) && rch->invis_level > get_trust(ch)) continue;
skills.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
skills.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
skills.c:    for ( trainer = ch->in_room->people;
skills.c:	  trainer = trainer->next_in_room)
skills.c:	if (IS_NPC(trainer) && (IS_SET(trainer->act,ACT_GAIN)
skills.c: || IS_SET(trainer->act,ACT_TRAIN)) )
skills.c:	if (ch->practice < 10)
skills.c:	ch->practice -= 10;
skills.c:	ch->train +=1 ;
skills.c:	if (ch->train < 1)
skills.c:	ch->practice += 10;
skills.c:	ch->train -= 1 ;
skills.c:    if(ch->Class()->ctype!=CLASS_CASTER)
skills.c:	if ((level = skill_table[sn].skill_level[ch->Class()->GetIndex()]) < LEVEL_HERO + 1
skills.c:	&&  ch->pcdata->learned[sn] > 0
skills.c:	    level = skill_table[sn].skill_level[ch->Class()->GetIndex()];
skills.c:	    if (ch->level < level)
skills.c:	    	sprintf(buf,"%-18s n/a      ", skill_table[sn].name);
skills.c:		    100/(2 + ch->level - level));
skills.c:            sprintf(buf,"%-18s  %3d mana  ",skill_table[sn].name,mana);
skills.c:		if (ch->pcdata->learned[sn] == 0 ||
skills.c:		   (ch->level < skill_table[sn].skill_level[ch->Class()->GetIndex()]) ||
skills.c:		     sn == gsn_tactician_skill) && ch->level < AVATAR)) {
skills.c:			skill_table[sn].name, ch->pcdata->learned[sn]);
skills.c:        /*if ((level = skill_table[sn].skill_level[ch->Class()->GetIndex()]) < LEVEL_HERO + 1
skills.c:	&&  (fAll || level <= ch->level)
skills.c:        &&  ch->pcdata->learned[sn] > 0)*/
skills.c:	if ((level = skill_table[sn].skill_level[ch->Class()->GetIndex()]) < LEVEL_HERO + 1
skills.c:	&&  ch->pcdata->learned[sn] > 0)
skills.c:        			if(ch->pcdata->learned[style_skill] < style_percent[p].percent)
skills.c:	    level = skill_table[sn].skill_level[ch->Class()->GetIndex()];
skills.c:			if (ch->level < level)
skills.c:	    		sprintf(buf,"%-18s n/a      ", skill_table[sn].name);
skills.c:	    		sprintf(buf,"%-18s %3d%%      ",skill_table[sn].name,
skills.c:		    			ch->pcdata->learned[sn]);
skills.c:    epl = pc_race_table[ch->race].xpadd + 1500;
skills.c:    epl += ((float)ch->level -1) * epl * .08;
skills.c:	if (gn != -1)
skills.c:	    if (ch->gen_data->group_chosen[gn]
skills.c:	    ||  ch->pcdata->group_known[gn])
skills.c:	    ch->gen_data->group_chosen[gn] = TRUE;
skills.c:	if (sn != -1)
skills.c:	    if (ch->gen_data->skill_chosen[sn]
skills.c:	    ||  ch->pcdata->learned[sn] > 0)
skills.c:	    ch->gen_data->skill_chosen[sn] = TRUE;
skills.c:	    ch->gen_data->points_chosen += skill_table[sn].rating[ch->Class()->GetIndex()];
skills.c:	    ch->pcdata->learned[sn] = 1;
skills.c:	if (gn != -1 && ch->gen_data->group_chosen[gn])
skills.c:	    ch->gen_data->group_chosen[gn] = FALSE;
skills.c:	    ch->gen_data->points_chosen -= group_table[gn].rating[ch->Class()->GetIndex()];
skills.c:		if (ch->gen_data->group_chosen[gn])
skills.c:	if (sn != -1 && ch->gen_data->skill_chosen[sn])
skills.c:	    ch->gen_data->skill_chosen[sn] = FALSE;
skills.c:	    ch->gen_data->points_chosen -= skill_table[sn].rating[ch->Class()->GetIndex()];
skills.c:	    ch->pcdata->learned[sn] = 0;
skills.c:/* shows all groups, or the sub-members of a group */
skills.c:	chance += ch->level * 2;
skills.c:	ch->pcdata->learned[sn]++;
skills.c:	if(ch->pcdata->learned[sn] > 100)
skills.c:		ch->pcdata->learned[sn] = 100;
skills.c:					if(ch->pcdata->learned[sn] == style_percent[i].percent)
skills.c:    if (ch->level < skill_table[sn].skill_level[ch->Class()->GetIndex()]
skills.c:    ||  ch->pcdata->learned[sn] <= 10
skills.c:    ||  ch->pcdata->learned[sn] >= 100)
skills.c:    chance += ch->level * 2;
skills.c:	if (IS_SET(ch->act,PLR_MORON))
skills.c:	chance = URANGE(5,100 - ch->pcdata->learned[sn], 95);
skills.c:	if (IS_SET(ch->comm,COMM_ANSI) && ch->pcdata->learned[sn]<99) {
skills.c:	} else if (!IS_SET(ch->comm,COMM_ANSI) && ch->pcdata->learned[sn]<99) {
skills.c:	} else if (IS_SET(ch->comm,COMM_ANSI) && ch->pcdata->learned[sn]==99) {
skills.c:	} else if (!IS_SET(ch->comm,COMM_ANSI) && ch->pcdata->learned[sn]==99) {
skills.c:	    ch->pcdata->learned[sn]++;
skills.c:	chance = URANGE(5,ch->pcdata->learned[sn]/2,30);
skills.c:	if (IS_SET(ch->comm,COMM_ANSI) && (ch->pcdata->learned[sn]+inum)<100) {
skills.c:	} else if (!IS_SET(ch->comm,COMM_ANSI) && (ch->pcdata->learned[sn]+inum)<100) {
skills.c:	} else if (IS_SET(ch->comm,COMM_ANSI) && ch->pcdata->learned[sn]+inum==100) {
skills.c:	} else if (!IS_SET(ch->comm,COMM_ANSI) && ch->pcdata->learned[sn]+inum==100) {
skills.c:	    ch->pcdata->learned[sn] += inum;
skills.c:	    ch->pcdata->learned[sn] = UMIN(ch->pcdata->learned[sn],100);
skills.c:    return -1;
skills.c:	return -1;
skills.c:/* recursively adds a group given its number -- uses group_add */
skills.c:    ch->pcdata->group_known[gn] = TRUE;
skills.c:/* recusively removes a group given its number -- uses group_remove */
skills.c:    ch->pcdata->group_known[gn] = FALSE;
skills.c:    if (sn != -1 && sn != gsn_gladiator_skill && sn != gsn_duelist_skill &&
skills.c:		if (ch->pcdata->learned[sn] == 0)
skills.c:	    	ch->pcdata->learned[sn] = 1;
skills.c:	if (gn != -1)
skills.c:		if (ch->pcdata->group_known[gn] == FALSE)
skills.c:	    	ch->pcdata->group_known[gn] = TRUE;
skills.c:/* used for processing a skill or group for deletion -- no points back! */
skills.c:    if (sn != -1)
skills.c:	ch->pcdata->learned[sn] = 0;
skills.c:    if (gn != -1 && ch->pcdata->group_known[gn] == TRUE)
skills.c:	ch->pcdata->group_known[gn] = FALSE;
sorcerer.c:			return -1;
sorcerer.c:			return -1;
sorcerer.c:			return -1;
sorcerer.c:			return -1;
sorcerer.c:			return -1;
sorcerer.c:			return -1;
sorcerer.c:			return -1;
sorcerer.c:	return -1;
sorcerer.c:	OBJ_DATA *well = get_obj_list(ch, target_name, ch->in_room->contents), *gwell;
sorcerer.c:	if(!IS_SET(well->wear_flags,ITEM_TAKE))
sorcerer.c:	if(well->weight<10)
sorcerer.c:    if (well->item_type == ITEM_CORPSE_PC && well->contains!=NULL)
sorcerer.c:	if (is_affected_area(ch->in_room->area, gsn_gravity_well))
sorcerer.c:	gwell->weight	= well->weight;
sorcerer.c:	obj_to_room(gwell, ch->in_room);
sorcerer.c:	new_affect_to_room(ch->in_room,&raf);
sorcerer.c:	aaf.duration=	-1;
sorcerer.c:	affect_to_area(ch->in_room->area,&aaf);
sorcerer.c:	CHAR_DATA *victim, *v_next, *ch = af->owner;
sorcerer.c:	affect_strip_area (room->area, gsn_gravity_well);
sorcerer.c:	for(well = object_list; well!=NULL; well = well->next)
sorcerer.c:		if(well->item_type == ITEM_GRAVITYWELL && well->in_room && well->in_room == room)
sorcerer.c:	if(well->in_room->people)
sorcerer.c:			well->in_room->people, 0, 0, TO_ALL);
sorcerer.c:	for(victim = room->people; victim!=NULL; victim = v_next)
sorcerer.c:		v_next = victim->next_in_room;
sorcerer.c:		if (!ch->in_room) {	
sorcerer.c:		damage_new(ch,victim,dam,af->type,DAM_ENERGY,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the violent explosion*");
sorcerer.c:	if(ch->in_room->sector_type == SECT_UNDERWATER ||
sorcerer.c:		ch->in_room->sector_type == SECT_INSIDE	   ||
sorcerer.c:		ch->in_room->sector_type == SECT_CITY 	   ||
sorcerer.c:		IS_SET(ch->in_room->room_flags,ROOM_LAW))
sorcerer.c:	if (is_affected_area(ch->in_room->area,gsn_cyclone) ||
sorcerer.c:		is_affected_area(ch->in_room->area,gsn_cyclone_forming) ||
sorcerer.c:		is_affected_area(ch->in_room->area,gsn_whiteout))
sorcerer.c:	affect_to_area(ch->in_room->area, &aaf);
sorcerer.c:   	aaf.level       = af->level;
sorcerer.c:   	aaf.owner       = af->owner;
sorcerer.c:		af.modifier = -2;
sorcerer.c:    if (obj->pIndexData->material_index < 0 || material_table[obj->pIndexData->material_index].mat_conductivity <= 0)
sorcerer.c:    oaf.modifier     = 30 - obj->value[3];
sorcerer.c:	if (is_affected_room(ch->in_room,sn))
sorcerer.c: 	if ((ch->in_room->sector_type) && ((ch->in_room->sector_type == SECT_WATER)
sorcerer.c:		|| (ch->in_room->sector_type == SECT_AIR)
sorcerer.c:		|| (ch->in_room->sector_type == SECT_DESERT)
sorcerer.c:		|| (ch->in_room->sector_type == SECT_INSIDE)
sorcerer.c:		|| (ch->in_room->sector_type == SECT_CITY)))
sorcerer.c:		if(ch->in_room->exit[i])
sorcerer.c:	raf.modifier	= SECT_CONFLAGRATION - ch->in_room->sector_type;
sorcerer.c:	new_affect_to_room(ch->in_room,&raf);
sorcerer.c:	zone_echo(ch->in_room->area,"The crackling roar of fire reaches your ears.\n\r");
sorcerer.c:                if(room->exit[i])
sorcerer.c: 	if (((room->sector_type) && (room->sector_type == SECT_WATER))
sorcerer.c:		|| (room->sector_type == SECT_AIR)
sorcerer.c:		|| (room->sector_type == SECT_DESERT)
sorcerer.c:		|| (room->sector_type == SECT_INSIDE)
sorcerer.c:		|| (room->sector_type == SECT_CONFLAGRATION)
sorcerer.c:		|| (room->sector_type == SECT_CITY))
sorcerer.c:	raf.type	= oldaf->type;
sorcerer.c:	raf.aftype	= oldaf->aftype;
sorcerer.c:	raf.level	= oldaf->level;
sorcerer.c:	raf.modifier	= SECT_CONFLAGRATION - room->sector_type;
sorcerer.c:	raf.owner	= oldaf->owner;
sorcerer.c:	raf.end_fun	= oldaf->end_fun;
sorcerer.c:	for (rch = room->people; rch != NULL; rch = rch->next_in_room )
sorcerer.c:	zone_echo(room->area,"The crackling roar of fire reaches your ears.\n\r");
sorcerer.c:	if (room->sector_type != SECT_CONFLAGRATION)
sorcerer.c:	if (room->people) {
sorcerer.c:		for (vch = room->people; vch; vch = vch_next) {
sorcerer.c:			vch_next = vch->next_in_room;
sorcerer.c:			dam = dice(vch->level/2,3) + 5;
sorcerer.c:			if (IS_NPC(vch) && (vch->max_hit) > 0
sorcerer.c:				&& ((vch->hit*100)/vch->max_hit < 50)) {
sorcerer.c:				dam -= (int)((float)dam * 0.05) * (50 - (vch->hit*100)/vch->max_hit);
sorcerer.c:			damage_new(af->owner,vch,dam,TYPE_UNDEFINED,DAM_FIRE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the raging wildfire*");
sorcerer.c:	while(!room->exit[(exit = number_range(0,5))]);
sorcerer.c:	if (room->exit[exit] && (room_next = room->exit[exit]->u1.to_room)
sorcerer.c:		&& room_next->area == room->area && number_percent () <= 8)
sorcerer.c:	raf.aftype	= af->aftype;
sorcerer.c:	raf.level	= af->level;
sorcerer.c:	raf.modifier	= SECT_DESERT - (room->sector_type - af->modifier);
sorcerer.c:	raf.owner	= af->owner;
sorcerer.c:	for (rch = room->people; rch != NULL; rch = rch->next_in_room )
sorcerer.c:	switch(af->duration) {
sorcerer.c:	for (paf = ch->affected; paf != NULL; paf = paf->next)
sorcerer.c:		if (paf->type == gsn_ultradiffusion)
sorcerer.c:	if (paf->duration == 0)
sorcerer.c:	if (af->duration == -1) {
sorcerer.c:	} else if (af->duration == 0) {
sorcerer.c:	for(rpaf = ch->affected; rpaf; rpaf = rpaf->next)
sorcerer.c:		if(rpaf->type == gsn_ultradiffusion && rpaf->end_fun)
sorcerer.c:			rpaf->end_fun = NULL;
sorcerer.c:	switch (af->duration) {
sorcerer.c:			af->duration = -1;
sorcerer.c:		if (af && af->duration <= 3)
sorcerer.c:			paf.level	= ch->level;
sorcerer.c:			paf.duration	= -1;
sorcerer.c:			paf.modifier	= modifier * number_range(-6,-5);
sorcerer.c:		if (af && af->duration <= 2)
sorcerer.c:			paf.modifier	= modifier * number_range(-6,-5);
sorcerer.c:		if (af && af->duration <= 1)
sorcerer.c:			paf.modifier	= modifier * number_range(-6,-5);
sorcerer.c:	if (obj->pIndexData->material_index < 0 || material_table[obj->pIndexData->material_index].mat_conductivity <= 0)
sorcerer.c:	if (number_range(0,10) > material_table[obj->pIndexData->material_index].mat_conductivity)
sorcerer.c:		obj_to_room(obj, victim->in_room);
sorcerer.c:		if (IS_NPC(victim) && victim->wait == 0 && can_see_obj(victim,obj))
sorcerer.c:		pexit = ch->in_room->exit[door];
sorcerer.c:		if (!IS_SET(pexit->exit_info,EX_CLOSED))
sorcerer.c:		if (!IS_SET(pexit->exit_info,EX_LOCKED))
sorcerer.c:		if (IS_SET(pexit->exit_info,EX_NOPASS)) {
sorcerer.c:		REMOVE_BIT(pexit->exit_info,EX_LOCKED);
sorcerer.c:		REMOVE_BIT(pexit->exit_info,EX_CLOSED);
sorcerer.c:		REMOVE_BIT(pexit->exit_info, EX_ISDOOR);
sorcerer.c:		if ((to_room = pexit->u1.to_room) != NULL
sorcerer.c:			&& (pexit_opp = to_room->exit[reverse_d(door)]) != NULL
sorcerer.c:			&& pexit_opp->u1.to_room == ch->in_room) {
sorcerer.c:			REMOVE_BIT(pexit_opp->exit_info,EX_LOCKED);
sorcerer.c:			REMOVE_BIT(pexit_opp->exit_info,EX_CLOSED);
sorcerer.c:			REMOVE_BIT(pexit_opp->exit_info, EX_ISDOOR);
sorcerer.c:		for (fch = to_room->people; fch != NULL; fch = fch->next_in_room) {
sorcerer.c:	if (is_affected_room(ch->in_room,sn))
sorcerer.c:		if(ch->in_room->exit[i])
sorcerer.c:	raf.duration	= -1;
sorcerer.c:	new_affect_to_room(ch->in_room,&raf);
sorcerer.c:	for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
sorcerer.c:		vch_next = vch->next_in_room;
sorcerer.c:		if((pexit = ch->in_room->exit[i]))
sorcerer.c:			if ((to_room = pexit->u1.to_room))
sorcerer.c:				if (to_room->people) {
sorcerer.c:					act("A sudden blast of air rushes in from the $T!",to_room->people,0,direction,TO_ALL);
sorcerer.c:	if (room->people)
sorcerer.c:		act("Air rushes back into the area in a fierce torrent!",room->people,0,0,TO_ALL);
sorcerer.c:		if((pexit = room->exit[i]))
sorcerer.c:			if (!IS_SET(pexit->exit_info,EX_CLOSED))
sorcerer.c:			if ((to_room = pexit->u1.to_room))
sorcerer.c:				if (to_room->people) {
sorcerer.c:					act("Air rushes back $Tward!",to_room->people,0,direction,TO_ALL);
sorcerer.c:	for (vch = room->people; vch != NULL; vch = vch_next)
sorcerer.c:		vch_next = vch->next_in_room;
sorcerer.c:		if (is_safe(af->owner,vch)) continue;
sorcerer.c:		damage_new(af->owner,vch,(3*af->level)/roomcount,TYPE_HIT + attack_lookup("asphyxiation"),DAM_ENERGY,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the vacuum*");
sorcerer.c:		if((pexit = room->exit[i]))
sorcerer.c:			if (IS_SET(pexit->exit_info,EX_CLOSED))
sorcerer.c:			if ((to_room = pexit->u1.to_room))
sorcerer.c:				for (obj = to_room->contents; obj != NULL; obj = obj_next )
sorcerer.c:					obj_next = obj->next_content;
sorcerer.c:					if (get_true_weight(obj) < 5 && IS_SET(obj->wear_flags, ITEM_TAKE))
sorcerer.c:						if (to_room->people)
sorcerer.c:							act("$p is sucked out of the room!",to_room->people,obj,0,TO_ALL);
sorcerer.c:						while (!smacked && room->people)
sorcerer.c:						for (vch = room->people; vch != NULL; vch = vch_next)
sorcerer.c:						vch_next = vch->next_in_room;
sorcerer.c:						if (j == randperson && !is_safe_new(af->owner,vch,FALSE))
sorcerer.c:						damage_new(af->owner,smacked,dice(get_true_weight(obj)+1,9),TYPE_UNDEFINED,DAM_BASH,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the flying debris*");
sorcerer.c:	if (af->modifier > 3)
sorcerer.c:		if((pexit = room->exit[i]))
sorcerer.c:			if (IS_SET(pexit->exit_info,EX_CLOSED))
sorcerer.c:			if ((to_room = pexit->u1.to_room))
sorcerer.c:				for (vch = to_room->people; vch != NULL; vch = vch_next )
sorcerer.c:					vch_next = vch->next_in_room;
sorcerer.c:					if(IS_NPC(vch) && IS_SET(vch->act,ACT_SENTINEL))
sorcerer.c:					if(!IS_NPC(vch) && is_safe_new(af->owner,vch,FALSE))
sorcerer.c:    af.modifier  = (int)(-1 * (average_ac(victim) * (float)((float) level/ (float) 400)));
sorcerer.c:	af = affect_find(victim->affected, gsn_bleeding);
sorcerer.c:		for(af = victim->affected; af!=NULL; af = af->next)
sorcerer.c:			if(af->type == gsn_bleeding && af->level<150)
sorcerer.c:				af->level = (int)((float)af->level * 1.33);
sorcerer.c:        victim->hit = UMIN( victim->hit + heal, victim->max_hit );
sorcerer.c:	for(obj=victim->carrying; obj!=NULL; obj=obj->next_content)
sorcerer.c:		if (!is_worn(obj) || obj->wear_loc == WEAR_BRAND)
sorcerer.c:		if(obj->pIndexData->material_index>0 &&
sorcerer.c:			number_percent() < 30 * material_table[obj->pIndexData->material_index].mat_flammability &&
sorcerer.c:			oaf.duration	=	(short)(2 * pow(material_table[obj->pIndexData->material_index].mat_flammability,2));
sorcerer.c:    if (obj->carried_by)
sorcerer.c:		act("$p stops burning.",obj->carried_by,obj,0,TO_CHAR);
sorcerer.c:	if (obj->in_room && obj->in_room->people)
sorcerer.c:		act("$p stops burning.",obj->in_room->people,obj,0,TO_ALL);
sorcerer.c:	af.modifier	= -4;
sorcerer.c:	for(vch = ch->in_room->people; vch!=NULL; vch=vch_next)
sorcerer.c:		vch_next = vch->next_in_room;
sorcerer.c:        	if (!IS_NPC(ch) && !IS_NPC(vch) && (ch->fighting == NULL || vch->fighting == NULL))
sorcerer.c:			!(IS_SET(vch->act,ACT_UNDEAD)
sorcerer.c:			|| IS_SET(vch->form,FORM_UNDEAD)))
sorcerer.c:	if (is_affected_room(ch->in_room,sn))
sorcerer.c: 	if (((ch->in_room->sector_type) && (ch->in_room->sector_type == SECT_WATER)) || (ch->in_room->sector_type == SECT_AIR))
sorcerer.c:	for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
sorcerer.c:		vch_next = vch->next_in_room;
sorcerer.c:	switch (ch->in_room->sector_type) {
sorcerer.c:			if(ch->in_room->sector_type != SECT_HILLS)
sorcerer.c:			for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
sorcerer.c:				vch_next = vch->next_in_room;
sorcerer.c:			for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
sorcerer.c:				vch_next = vch->next_in_room;
sorcerer.c:			for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
sorcerer.c:				vch_next = vch->next_in_room;
sorcerer.c:			new_affect_to_room(ch->in_room,&raf);
sorcerer.c:			for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
sorcerer.c:				vch_next = vch->next_in_room;
sorcerer.c:	for (obj = victim->carrying; obj != NULL; obj = obj->next_content)
sorcerer.c:		if (obj->pIndexData->material_index < 0)
sorcerer.c:		tconduct += material_table[obj->pIndexData->material_index].mat_conductivity;
sorcerer.c:	if (get_curr_stat(victim,STAT_INT) > 10 && number_range(0,200) < (pow(get_curr_stat(victim,STAT_INT)-10,2)) )
sorcerer.c:		|| IS_SET(victim->act,ACT_UNDEAD) || IS_SET(victim->form,FORM_UNDEAD))
sorcerer.c:	send_to_char("You create an electrically-charged sphere around you.\n\r",ch);
sorcerer.c:		if (victim->mana <= 1)
sorcerer.c:		if ((victim->mana/2) < drain)
sorcerer.c:			drain = victim->mana/2;
sorcerer.c:		victim->mana -= drain;
sorcerer.c:		ch->mana += drain/2;
sorcerer.c:	area = ch->in_room->area;
sorcerer.c:		ch->in_room->sector_type == SECT_UNDERWATER ? "water" : "air");
sorcerer.c:	rarea_echo(ch->in_room,buf);
sorcerer.c:	if (!IS_NPC(victim) && victim->pcdata->condition[COND_THIRST] > COND_HUNGRY)
sorcerer.c:	damage_new(ch,victim,dice(COND_HUNGRY - victim->pcdata->condition[COND_THIRST],level / 5),sn,DAM_INTERNAL,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,NULL);
sorcerer.c:		if (victim->pcdata->condition[COND_THIRST] >= 0) {
sorcerer.c:			victim->pcdata->condition[COND_THIRST] = COND_HUNGRY;
sorcerer.c:	if (ch->in_room->sector_type == SECT_WATER || ch->in_room->sector_type == SECT_UNDERWATER)
sorcerer.c:	for (obj = ch->in_room->contents; obj; obj = obj->next_content)
sorcerer.c:		if (obj->item_type == ITEM_FOUNTAIN)
sorcerer.c:	switch (ch->in_room->sector_type) {
sorcerer.c:	if (ch->in_room->area->sky == SKY_DRIZZLE && ch->in_room->sector_type != SECT_WATER && ch->in_room->sector_type != SECT_INSIDE && ch->in_room->sector_type != SECT_UNDERWATER)
sorcerer.c:		act("You feel your wounds mending rapidly as the life-giving water fills you with vigor!",victim,0,0,TO_CHAR);
sorcerer.c:	victim->hit = UMIN(victim->hit+heal,victim->max_hit);
sorcerer.c:	if (ch->in_room->sector_type != SECT_WATER && ch->in_room->sector_type != SECT_UNDERWATER) {
sorcerer.c:	pexit = ch->in_room->exit[door];
sorcerer.c:	if (pexit != NULL && ((to_room = pexit->u1.to_room) != NULL)) {
sorcerer.c:		if (to_room->sector_type == SECT_CITY) {
sorcerer.c:		} else if (to_room->sector_type == SECT_WATER) {
sorcerer.c:		} else if (to_room->sector_type == SECT_UNDERWATER) {
sorcerer.c:		} else if (to_room->sector_type == SECT_AIR) {
sorcerer.c:		if (to_room->people) {
sorcerer.c:			act("A torrent of water rushes in from the $T, flooding the room!",to_room->people,0,direction,TO_ALL);
sorcerer.c:		if (is_affected_room(ch->in_room,sn)) {
sorcerer.c:			for (oaf = ch->in_room->affected; oaf != NULL; oaf = oaf->next )
sorcerer.c:				if (oaf->type == sn)
sorcerer.c:			duration = UMAX(oaf->duration - 1,0);
sorcerer.c:		raf.modifier	= SECT_WATER - to_room->sector_type;
sorcerer.c:	if (room->people)
sorcerer.c:		act("The flood begins to recede, and before long no trace of the water remains.",room->people,NULL,NULL,TO_ALL);
sorcerer.c:	if (ch->in_room->sector_type != SECT_WATER) {
sorcerer.c:        if((door = direction_lookup(target_name)) == -1)
sorcerer.c:	to_room = ch->in_room;
sorcerer.c:	pexit = ch->in_room->exit[door];
sorcerer.c:	to_room = pexit->u1.to_room;
sorcerer.c:			if (to_room->sector_type == SECT_WATER) {
sorcerer.c:				raf.duration	= -1;
sorcerer.c:				raf.modifier	= UMAX((i * 2) - 1,2);
sorcerer.c:			} else if (to_room->sector_type == SECT_FIELD
sorcerer.c:					|| to_room->sector_type == SECT_FOREST
sorcerer.c:					|| to_room->sector_type == SECT_HILLS
sorcerer.c:					|| to_room->sector_type == SECT_MOUNTAIN
sorcerer.c:					|| to_room->sector_type == SECT_INSIDE
sorcerer.c:					|| to_room->sector_type == SECT_DESERT
sorcerer.c:					|| to_room->sector_type == SECT_ROAD) {
sorcerer.c:				raf.duration	= -1;
sorcerer.c:				raf.modifier	= UMAX((i * 2) - 1,2);
sorcerer.c:		pexit = to_room->exit[door];
sorcerer.c:		to_room = pexit->u1.to_room;
sorcerer.c:	for (vch = ch->in_room->people; vch != NULL; vch = v_next)
sorcerer.c:		v_next = vch->next_in_room;
sorcerer.c:	if (is_affected_room(ch->in_room,sn))
sorcerer.c:	for (room = top_affected_room; room ; room = room->aff_next )
sorcerer.c:			for (raf = room->affected; raf != NULL; raf = raf->next)
sorcerer.c:				if (raf->type == sn && raf->owner == ch && raf->location == APPLY_ROOM_NONE && raf->modifier == 1)
sorcerer.c:				else if (raf->type == sn && raf->owner == ch && raf->location == APPLY_ROOM_NONE && raf->modifier == 2)
sorcerer.c:		if (ch->in_room->sector_type != SECT_WATER && ch->in_room->sector_type != SECT_UNDERWATER) {
sorcerer.c:		if (first_room->area != ch->in_room->area)
sorcerer.c:		if (first_room == ch->in_room)
sorcerer.c:		new_affect_to_room(ch->in_room,&nraf);
sorcerer.c:		fraf->duration = 24;
sorcerer.c:		if (ch->in_room->sector_type != SECT_WATER) {
sorcerer.c:		new_affect_to_room(ch->in_room,&nraf);
sorcerer.c:	act("Your control over your riptide's water currents wanes.",af->owner,NULL,NULL,TO_CHAR);
sorcerer.c:	if (room->people)
sorcerer.c:		act("The ripples in the water cease.",room->people,NULL,NULL,TO_ALL);
sorcerer.c:	if (room->people)
sorcerer.c:		act("The ripples in the water cease.",room->people,NULL,NULL,TO_ALL);
sorcerer.c:	avg+=ch->armor[i];
sorcerer.c:		if (ch->in_room->sector_type != SECT_WATER && ch->in_room->sector_type != SECT_UNDERWATER)
sorcerer.c:	for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room)
sorcerer.c:	if (ch->in_room->sector_type == SECT_INSIDE
sorcerer.c:		|| ch->in_room->sector_type == SECT_UNDERWATER
sorcerer.c:		|| IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL))
sorcerer.c:		wch_next = wch->next;
sorcerer.c:		if (IS_NPC(wch) && wch->pIndexData->vnum == MOB_VNUM_ANCHOR && wch->master == ch)
sorcerer.c:	char_to_room(anchor,ch->in_room);
sorcerer.c:	anchor->level = level;
sorcerer.c:	anchor->hunting = ch;
sorcerer.c:	if (IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL) ||
sorcerer.c:		ch->in_room->sector_type == SECT_INSIDE ||
sorcerer.c:		ch->in_room->sector_type == SECT_UNDERWATER)
sorcerer.c:		wch_next = wch->next;
sorcerer.c:		if (IS_NPC(wch) && wch->pIndexData->vnum == MOB_VNUM_ANCHOR && wch->hunting == ch)
sorcerer.c:		char_to_room(ch, anchor->in_room);
sorcerer.c:		check_plasma_thread(ch,-1);
sorcerer.c:			if (pRoomIndex->sector_type == SECT_CITY || pRoomIndex->sector_type == SECT_INSIDE || pRoomIndex->sector_type == SECT_WATER || pRoomIndex->sector_type == SECT_UNDERWATER)
sorcerer.c:			if (!IS_SET(pRoomIndex->room_flags, ROOM_NO_RECALL) && !IS_EXPLORE(pRoomIndex) && !pRoomIndex->cabal)
sorcerer.c:		check_plasma_thread(ch,-1);
sorcerer.c:	if (ch->in_room->sector_type == SECT_UNDERWATER)
sorcerer.c:  if(!(ch->hit < ch->max_hit*.75)) {
sorcerer.c:		af.duration	= 18 - level/5;
sorcerer.c:		act("$n concentrates, and $s skin hardens into a diamond-like carapace.", ch, 0, 0, TO_ROOM);
sorcerer.c:	if (victim->position <= POS_RESTING)
sorcerer.c:		victim->position = POS_RESTING;
sorcerer.c:	if(is_affected(victim,gsn_reduce) || victim->size<=SIZE_TINY) {
sorcerer.c:        af.modifier     = -1;
sorcerer.c:        af.modifier     = -20;
sorcerer.c:        act("$n rapidly shrinks to two-thirds of $s original size!",victim,0,0,TO_ROOM);
sorcerer.c:		if (ch->fighting != NULL) {
sorcerer.c:			victim = ch->fighting;
sorcerer.c:    ||   (IS_NPC(victim) && IS_SET(victim->act,ACT_UNDEAD))
sorcerer.c:    ||   saves_spell(level-1, victim,DAM_COLD)
sorcerer.c:    ||   IS_SET(victim->imm_flags,IMM_SLEEP))
sorcerer.c:        victim->position = POS_SLEEPING;
sorcerer.c:        if (saves_spell(level-1,victim, DAM_COLD))
sorcerer.c:	es = victim->pcdata->energy_state + iDir;
sorcerer.c:	if (!trusts(ch,victim) || abs(es) > 1 || !((victim->pcdata->energy_state < -1 && iDir > 0) || (victim->pcdata->energy_state > 1 && iDir < 0)))
sorcerer.c:	if ((iDir > 0) && (victim->pcdata->energy_state>4))
sorcerer.c:	else if ((iDir < 0) && (victim->pcdata->energy_state<-4))
sorcerer.c:			case -1:
sorcerer.c:			case -2:
sorcerer.c:			case -3:
sorcerer.c:			case -4:
sorcerer.c:			case -5:
sorcerer.c:	victim->pcdata->energy_state = 0;
sorcerer.c:	    if(victim->pcdata->energy_state==1)
sorcerer.c:	if (es < -1) {
sorcerer.c:	    af.modifier	= -4 + (es+2)*2;
sorcerer.c:        if (ch->fighting == victim)
sorcerer.c:        if (victim->fighting == ch)
sorcerer.c:    spell_enervate_agitate_helper(sn, level, ch, vo, target, -1);
sorcerer.c:	if (ch->pcdata->energy_state > 4) {
sorcerer.c:		if (af->owner)
sorcerer.c:			raw_kill(af->owner,ch);
sorcerer.c:	if (ch->pcdata->energy_state > 1) {
sorcerer.c:		if (!af->owner)
sorcerer.c:			af->owner = ch;
sorcerer.c:		dam = ch->pcdata->energy_state;
sorcerer.c:		damage_new(af->owner,ch,dam,gsn_agitate,DAM_FIRE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"agitation");
sorcerer.c:	if (obj->pIndexData->material_index > 0)
sorcerer.c:	    highchance = material_table[obj->pIndexData->material_index].mat_conductivity * 20;
sorcerer.c:	if (obj->pIndexData->material_index > 0)
sorcerer.c:	    highchance = material_table[obj->pIndexData->material_index].mat_conductivity * 4;
sorcerer.c:		if (is_affected(victim,sn) && victim->arms < 2)
sorcerer.c:		for (paf = victim->affected; paf != NULL; paf = paf->next)
sorcerer.c:			if (paf->type == sn && paf->location == APPLY_STR)
sorcerer.c:		af.modifier = -(level/5);
sorcerer.c:		if(!saves_spell(level-2,victim,DAM_COLD))
sorcerer.c:			act("$N's screams in pain as $S arm, now a pale bluish-white color, dangles uselessly at $S side!",ch,0,victim,TO_CHAR);
sorcerer.c:			act("$N's screams in pain as $S arm, now a pale bluish-white color, dangles uselessly at $S side!",ch,0,victim,TO_NOTVICT);
sorcerer.c:			af.modifier = -1;
sorcerer.c:		if (is_affected(victim,sn) && victim->legs < 2)
sorcerer.c:		for (paf = victim->affected; paf != NULL; paf = paf->next)
sorcerer.c:			if (paf->type == sn && paf->location == APPLY_DEX)
sorcerer.c:		af.modifier = -(level/5);
sorcerer.c:		if(!saves_spell(level-2,victim,DAM_COLD))
sorcerer.c:			af.modifier = -1;
sorcerer.c:		if (skill_table[gsn].name == NULL || skill_table[gsn].skill_level[ch->Class()->GetIndex()] > 52
sorcerer.c:		|| ch->level < skill_table[gsn].skill_level[ch->Class()->GetIndex()] || ch->pcdata->learned[gsn] < 1
sorcerer.c:	return snarray[number_range(0,found-1)];
sorcerer.c:	if (((diceroll = number_percent()) <= 20) && IS_SET(victim->parts,PART_ARMS))
sorcerer.c:	else if ((diceroll <= 40 && IS_SET(victim->parts,PART_LEGS)))
sorcerer.c:	else if ((diceroll <= 60 && IS_SET(victim->parts,PART_HEAD)))
sorcerer.c:		hardness = material_table[armor->pIndexData->material_index].mat_hardness;
sorcerer.c:			sprintf(tovict2,"The sizzling acid seeps through your %s armor!",material_table[armor->pIndexData->material_index].mat_name);
sorcerer.c:			sprintf(tochar2,"The sizzling acid seeps through $N's %s armor!",material_table[armor->pIndexData->material_index].mat_name);
sorcerer.c:			sprintf(toroom2,"The sizzling acid seeps through $N's %s armor!",material_table[armor->pIndexData->material_index].mat_name);
sorcerer.c:			sprintf(tovict2,"The sizzling acid drips off your %s armor!",material_table[armor->pIndexData->material_index].mat_name);
sorcerer.c:			sprintf(tochar2,"The sizzling acid drips off $N's %s armor!",material_table[armor->pIndexData->material_index].mat_name);
sorcerer.c:			sprintf(toroom2,"The sizzling acid drips off $N's %s armor!",material_table[armor->pIndexData->material_index].mat_name);
sorcerer.c:			af.modifier = -level/10;
sorcerer.c:			af.modifier = -level/10;
sorcerer.c:			af.modifier = -4;
sorcerer.c:	if(weapon->item_type != ITEM_WEAPON)
sorcerer.c:	oaf.modifier = 31 - weapon->value[3];
sorcerer.c:	if (obj->carried_by)
sorcerer.c:		act("$p is dissolved by the acid coating it.",obj->carried_by,obj,0,TO_CHAR);
sorcerer.c:	if (obj->in_room && obj->in_room->people)
sorcerer.c:		act("$p is dissolved by the acid coating it.",obj->in_room->people,obj,0,TO_ALL);
sorcerer.c:	if (obj->in_obj && obj->in_obj->carried_by)
sorcerer.c:		act("You hear a faint hissing sound coming from $p.",obj->in_obj->carried_by,obj->in_obj,0,TO_CHAR);
sorcerer.c:	    	if (obj->item_type == ITEM_PORTAL)
sorcerer.c:				if (!IS_SET_OLD(obj->value[1],EX_ISDOOR))
sorcerer.c:		    	if (!IS_SET_OLD(obj->value[1],EX_CLOSED))
sorcerer.c:		    	if (obj->value[4] < 0)
sorcerer.c:		    	if (IS_SET_OLD(obj->value[1],EX_PICKPROOF))
sorcerer.c:		    	REMOVE_BIT_OLD(obj->value[1],EX_LOCKED);
sorcerer.c:    			if ( obj->item_type != ITEM_CONTAINER )
sorcerer.c:    			if ( !IS_SET_OLD(obj->value[1], CONT_CLOSED) )
sorcerer.c:    			if ( obj->value[2] < 0 )
sorcerer.c:    			if ( !IS_SET_OLD(obj->value[1], CONT_LOCKED) )
sorcerer.c:    			if ( IS_SET_OLD(obj->value[1], CONT_PICKPROOF) )
sorcerer.c:    			REMOVE_BIT_OLD(obj->value[1], CONT_LOCKED);
sorcerer.c:    			pexit = ch->in_room->exit[door];
sorcerer.c:    			if ( !IS_SET(pexit->exit_info, EX_CLOSED) && !IS_IMMORTAL(ch))
sorcerer.c:    			if ( pexit->key < 0 && !IS_IMMORTAL(ch))
sorcerer.c:    			if ( !IS_SET(pexit->exit_info, EX_LOCKED) )
sorcerer.c:    			if ( IS_SET(pexit->exit_info, EX_PICKPROOF) && !IS_IMMORTAL(ch))
sorcerer.c:    			REMOVE_BIT(pexit->exit_info, EX_LOCKED);
sorcerer.c:    			act( "$n corrodes the lock on $T.", ch, NULL, pexit->keyword, TO_ROOM );
sorcerer.c:    			if ( ( to_room   = pexit->u1.to_room            ) != NULL
sorcerer.c:    			&&   ( pexit_rev = to_room->exit[rev_dir[door]] ) != NULL
sorcerer.c:    			&&   pexit_rev->u1.to_room == ch->in_room )
sorcerer.c:        			REMOVE_BIT( pexit_rev->exit_info, EX_LOCKED );
sorcerer.c:    if (ch->in_room->area->sky < SKY_OVERCAST
sorcerer.c:		|| IS_SET(ch->in_room->room_flags,ROOM_INDOORS))
sorcerer.c:	if (!af->owner)
sorcerer.c:		af->owner = ch;
sorcerer.c:	damage_new(af->owner,ch,dice(af->level,4),gsn_attract,DAM_LIGHTNING,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the lightning strike*");
sorcerer.c:		ch->position = POS_STANDING;
sorcerer.c:		|| (ch->in_room->area != victim->in_room->area
sorcerer.c:	if (ch->in_room->area->sky < SKY_DRIZZLE)
sorcerer.c:	if (IS_SET(victim->in_room->room_flags,ROOM_INDOORS) ||
sorcerer.c:		victim->in_room->sector_type == SECT_INSIDE)
sorcerer.c:	if (ch->in_room->sector_type == SECT_AIR ||
sorcerer.c:		ch->in_room->sector_type == SECT_WATER ||
sorcerer.c:		ch->in_room->sector_type == SECT_UNDERWATER ||
sorcerer.c:		ch->in_room->sector_type == SECT_VERTICAL)
sorcerer.c:		REMOVE_BIT (victim->affected_by, AFF_FLYING);
sorcerer.c:	if ((!str_cmp(race_table[ch->race].name,"imp")) ||
sorcerer.c:		(!str_cmp(race_table[ch->race].name,"sidhe"))) {
sorcerer.c:		SET_BIT (ch->affected_by, AFF_FLYING);
sorcerer.c:		SET_BIT (ch->affected_by, AFF_FLYING);
sorcerer.c:	for(vch = ch->in_room->people; vch!=NULL; vch=vch_next)
sorcerer.c:		vch_next = vch->next_in_room;
sorcerer.c:        	if (!IS_NPC(ch) && !IS_NPC(vch) && (ch->fighting == NULL || vch->fighting == NULL)) {
sorcerer.c:    if (is_affected_room(ch->in_room,sn))
sorcerer.c:    if (((ch->in_room->sector_type) && (ch->in_room->sector_type == SECT_WATER))
sorcerer.c:        || (ch->in_room->sector_type == SECT_AIR)
sorcerer.c:		|| (ch->in_room->sector_type == SECT_UNDERWATER)
sorcerer.c:		|| (ch->in_room->sector_type == SECT_VERTICAL))
sorcerer.c:    new_affect_to_room(ch->in_room,&raf);
sorcerer.c:    zone_echo(ch->in_room->area,"You hear a massive hissing sound.");
sorcerer.c:    for (rch = room->people; rch != NULL; rch = rch->next_in_room )
sorcerer.c:	if (is_affected_room(ch->in_room,sn))
sorcerer.c:	new_affect_to_room(ch->in_room,&raf);
sorcerer.c:	if (room->people)
sorcerer.c:		act("The thick smoke in the room clears.",room->people,NULL,NULL,TO_ALL);
sorcerer.c:	if (number_percent() > 6 * (get_curr_stat(victim,STAT_CON) - 12))
sorcerer.c:	if (ch->in_room->sector_type && ch->in_room->sector_type == SECT_UNDERWATER)
sorcerer.c:	for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
sorcerer.c:		vch_next = vch->next_in_room;
sorcerer.c:		if (IS_NPC(vch) && !IS_SET(vch->form,FORM_BIPED))
sorcerer.c:		if (number_percent() > 10 * (get_curr_stat(vch,STAT_CON) - 15))
sorcerer.c:	if (ch->in_room->sector_type && ch->in_room->sector_type == SECT_UNDERWATER)
sorcerer.c:	if (ch->in_room->sector_type && ch->in_room->sector_type == SECT_UNDERWATER)
sorcerer.c:	free_pstring(ch->name);
sorcerer.c:	ch->name = palloc_string("Someone");
sorcerer.c:	free_pstring(ch->name);
sorcerer.c:	ch->name = palloc_string(ch->true_name);
sorcerer.c:	if((ch->in_room->sector_type == SECT_WATER) || (ch->in_room->sector_type == SECT_UNDERWATER) || (ch->in_room->sector_type == SECT_AIR))
sorcerer.c:	if (!IS_GROUND(ch->in_room))
sorcerer.c:	for(vch = ch->in_room->people; vch; vch = vch_next) {
sorcerer.c:		vch_next = vch->next_in_room;
sorcerer.c:		if (!IS_NPC(ch) && !IS_NPC(vch) && (!ch->fighting || !vch->fighting)) {
sorcerer.c:	if ((ch->in_room->sector_type) && ((ch->in_room->sector_type == SECT_AIR)
sorcerer.c:		|| (ch->in_room->sector_type == SECT_WATER)
sorcerer.c:		|| (ch->in_room->sector_type == SECT_UNDERWATER)
sorcerer.c:		|| (ch->in_room->sector_type == SECT_VERTICAL)))
sorcerer.c:	if ((ch->in_room->sector_type)
sorcerer.c:		&& ((ch->in_room->sector_type == SECT_BURNING)
sorcerer.c:		|| (ch->in_room->sector_type == SECT_DESERT)))
sorcerer.c:	if (ch->in_room->area->temp == TEMP_HOT)
sorcerer.c:	raf.modifier=	SECT_SNOW - ch->in_room->sector_type;
sorcerer.c:	new_affect_to_room(ch->in_room,&raf);
sorcerer.c:	clear_tracks(ch->in_room);
sorcerer.c:	for (rch = room->people; rch != NULL; rch = rch->next_in_room)
sorcerer.c:	if (ch->in_room->sector_type == SECT_UNDERWATER)
sorcerer.c:	switch (ch->in_room->area->temp) {
sorcerer.c:	pexit = ch->in_room->exit[dir];
sorcerer.c:	if (pexit == NULL || pexit->u1.to_room == NULL
sorcerer.c:	   || (IS_SET(pexit->exit_info,EX_CLOSED) && !IS_AFFECTED(ch,AFF_PASS_DOOR))
sorcerer.c:	   || (IS_SET(pexit->exit_info,EX_CLOSED)
sorcerer.c:	   && IS_SET(pexit->exit_info,EX_NOPASS))) {
sorcerer.c:	ch->disrupted = FALSE;
sorcerer.c:	RS.Queue.AddToQueue(6, 3, concave_shell_move, ch, dirptr, ch->in_room);
sorcerer.c:	if (ch->in_room->vnum != oldroom->vnum)
sorcerer.c:	if (ch->disrupted) {
sorcerer.c:	range = ch->level / 3;
sorcerer.c:	if(!IS_SET(ch->comm,COMM_BRIEF)) {
sorcerer.c:		SET_BIT(ch->comm,COMM_BRIEF);
sorcerer.c:	pexit = ch->in_room->exit[dir];
sorcerer.c:	if (pexit == NULL || pexit->u1.to_room == NULL ||
sorcerer.c:		(IS_SET(pexit->exit_info,EX_CLOSED) &&
sorcerer.c:		(IS_SET(pexit->exit_info,EX_CLOSED) &&
sorcerer.c:		IS_SET(pexit->exit_info,EX_NOPASS))) {
sorcerer.c:		pexit = ch->in_room->exit[dir];	
sorcerer.c:		if (pexit == NULL || pexit->u1.to_room == NULL ||
sorcerer.c:			(IS_SET(pexit->exit_info,EX_CLOSED) &&
sorcerer.c:			(IS_SET(pexit->exit_info,EX_CLOSED) &&
sorcerer.c:			IS_SET(pexit->exit_info,EX_NOPASS))) {
sorcerer.c:			damage_new(ch,ch,dice(10,10),gsn_bash,DAM_BASH,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"bone-jarring collision");
sorcerer.c:			ch->position = POS_RESTING;
sorcerer.c:		for (wch = ch->in_room->people; wch != NULL; wch = wch_next) {
sorcerer.c:			wch_next = wch->next_in_room;
sorcerer.c:			&& ((IS_SET(wch->act, ACT_AGGRESSIVE) && wch->level >= ch->level+5)
sorcerer.c:			|| IS_SET(wch->off_flags,SPAM_MURDER))
sorcerer.c:			&& wch->fighting != NULL
sorcerer.c:			&& !IS_SET(ch->in_room->room_flags,ROOM_SAFE)) {
sorcerer.c:				ch->position = POS_RESTING;
sorcerer.c:		REMOVE_BIT(ch->comm,COMM_BRIEF);
sorcerer.c:	switch (ch->in_room->area->temp) {
sorcerer.c:	if (!IS_GROUND(ch->in_room)) {
sorcerer.c:	area = ch->in_room->area;
sorcerer.c:	if (area->temp == TEMP_HOT || area->sky == SKY_CLEAR)
sorcerer.c:	outdoors_echo(area,"{WAn unnaturally-cold wind whips up, and in an instant, torrents of snow\n\rreduce visibility to absolutely nil!{x");
sorcerer.c:	aaf.modifier=	TEMP_COLD - area->temp;
sorcerer.c:	aaf.modifier=	WIND_GALE - area->wind;
sorcerer.c:	aaf.modifier=	SKY_BLIZZARD - area->sky;
sorcerer.c:	if (ch->in_room->sector_type && ch->in_room->sector_type == SECT_UNDERWATER)
sorcerer.c:	for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
sorcerer.c:		vch_next = vch->next_in_room;
sorcerer.c:		if (IS_NPC(vch) && !IS_SET(vch->form,FORM_BIPED))
sorcerer.c:		switch (ch->in_room->area->temp) {
sorcerer.c:	if (ch->in_room->sector_type && ch->in_room->sector_type == SECT_UNDERWATER)
sorcerer.c:	if (ch->in_room->area->temp <= TEMP_WARM)
sorcerer.c:	for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room) {
sorcerer.c:		for(laf = ch->affected; laf != NULL; laf = laf->next )
sorcerer.c:			if (skill_table[laf->type].dispel & CAN_PURIFY)
sorcerer.c:				affect_strip(vch,laf->type);
sorcerer.c:		for(raf = ch->in_room->affected; raf != NULL; raf = raf->next)
sorcerer.c:			if (skill_table[raf->type].dispel & CAN_PURIFY)
sorcerer.c:				affect_strip_room(ch->in_room, raf->type);
sorcerer.c:	if (!IS_GROUND(ch->in_room))
sorcerer.c:	if ((door = find_door(ch,target_name)) == -1)
sorcerer.c:	pexit = ch->in_room->exit[door];
sorcerer.c:	if (!IS_SET(pexit->exit_info,EX_CLOSED))
sorcerer.c:	SET_BIT(pexit->exit_info,EX_JAMMED);
sorcerer.c:	new_affect_to_room(ch->in_room,&raf);
sorcerer.c:	if ((to_room = pexit->u1.to_room) != NULL
sorcerer.c:		&& (pexit_opp = to_room->exit[reverse_d(door)]) != NULL
sorcerer.c:		&& pexit_opp->u1.to_room == ch->in_room) {
sorcerer.c:		SET_BIT(pexit_opp->exit_info,EX_JAMMED);
sorcerer.c:	pexit = room->exit[af->modifier];
sorcerer.c:	if(room->people) {
sorcerer.c:		direction = (char*)flag_name_lookup(af->modifier,direction_table);
sorcerer.c:		act("The frost covering the door $T thaws.",room->people,0,direction,TO_ALL);
sorcerer.c:	REMOVE_BIT(pexit->exit_info,EX_JAMMED);
sorcerer.c:	if (!IS_GROUND(ch->in_room))
sorcerer.c:	act("As you gesture, a barely-visible slick frost covers the ground beneath you.",ch,0,0,TO_CHAR);
sorcerer.c:	act("As $n gestures, a barely-visible slick frost covers the ground beneath you.",ch,0,0,TO_ROOM);
sorcerer.c:	new_affect_to_room(ch->in_room,&raf);
sorcerer.c:	if (room->people)
sorcerer.c:		act("The fine layer of frost coating the ground melts away.",room->people,0,0,TO_ALL);
sorcerer.c:	if (!IS_GROUND(ch->in_room))
sorcerer.c:	ROOM_INDEX_DATA *room = ch->in_room;
sorcerer.c:	if (room->sector_type != SECT_WATER)
sorcerer.c:	if (room->area->temp == TEMP_HOT)
sorcerer.c:	raf.modifier=	SECT_ICE - ch->in_room->sector_type;
sorcerer.c:	if (room->people)
sorcerer.c:		act("The ice beneath you melts into water as the magic dissipates.",room->people,0,0, TO_ALL);
sorcerer.c:	for(vch = ch->in_room->people; vch; vch = vch_next) {
sorcerer.c:		vch_next = vch->next_in_room;
sorcerer.c:		if (!IS_NPC(ch) && !IS_NPC(vch) && (!ch->fighting || !vch->fighting)) {
sorcerer.c:	if (is_affected_room(ch->in_room, gsn_stalactites))
sorcerer.c:	act("You cause razor-sharp stalactites to sprout from the ceiling above.",ch,0,0,TO_CHAR);
sorcerer.c:	new_affect_to_room(ch->in_room,&raf);
sorcerer.c:	for (obj = victim->carrying; obj; obj = obj_next) {
sorcerer.c:		obj_next = obj->next_content;
sorcerer.c:		switch (obj->item_type) {
sorcerer.c:	if (obj->carried_by)
sorcerer.c:		return act("The ice sealing $p melts.",obj->carried_by,obj,0,TO_CHAR);
sorcerer.c:	if (ch->in_room->sector_type != SECT_WATER && ch->in_room->sector_type != SECT_UNDERWATER)
sorcerer.c:		for (obj = ch->in_room->contents; obj; obj = obj->next)
sorcerer.c:			if (obj->item_type == ITEM_FOUNTAIN)
sorcerer.c:			if (obj->pIndexData->vnum == OBJ_VNUM_PUDDLE)
sorcerer.c:	af.modifier	=	-3;
sorcerer.c:	if (ch->in_room->area->temp == TEMP_HOT)
sorcerer.c:	oaf.modifier=	wield->weight * (level / 50);
sorcerer.c:	if (obj->carried_by)
sorcerer.c:		act("The ice surrounding $p melts.",obj->carried_by,obj,0,TO_CHAR);
sorcerer.c:	number = number_range(level/10 - 1, level/10 + 1);
sorcerer.c:	act("You wave your $p in a broad arc, sending a hail of razor-sharp metal at $N!",ch,weapon,victim,TO_CHAR);
sorcerer.c:	act("$n waves $p in a broad arc, sending a hail of razor-sharp metal at you!",ch,weapon,victim,TO_VICT);
sorcerer.c:	act("$n waves $p in a broad arc, sending a hail of razor-sharp metal at $N!",ch,weapon,victim,TO_NOTVICT);
sorcerer.c:		if ( (!str_cmp(weapon->material,"iron")
sorcerer.c:			&& !str_cmp(race_table[victim->race].name,"elf"))
sorcerer.c:			|| (!str_cmp(weapon->material,"mithril")
sorcerer.c:			&& !str_cmp(race_table[victim->race].name,"drow")))
sorcerer.c:		if (ch->in_room != victim->in_room)
sorcerer.c:	af.modifier	=	(level * victim->carry_weight) / 50;
sorcerer.c:	if (weapon->item_type != ITEM_WEAPON)
sorcerer.c:	chance += (4 * (level - ((1 + weapon->value[2]) * weapon->value[1])));
sorcerer.c:	if (weapon->pIndexData->limtotal == 0)
sorcerer.c:	if (weapon->pIndexData->limtotal == 1 || weapon->pIndexData->limtotal == 2)
sorcerer.c:		chance -= 50;
sorcerer.c:	if (weapon->pIndexData->limtotal >= 3 && weapon->pIndexData->limtotal <= 20)
sorcerer.c:		chance -= (int)(50 - (2.5 * (float)weapon->pIndexData->limtotal));
sorcerer.c:	diff = chance - number_percent();
sorcerer.c:	} else if (diff > -25) {
sorcerer.c:		damage_new(ch,ch,dice(weapon->level,5),TYPE_UNDEFINED,DAM_ENERGY,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the explosion*");
sorcerer.c:		for (hitapp = weapon->apply; hitapp; hitapp = hitapp->next)
sorcerer.c:			if (hitapp->location == APPLY_HITROLL) {
sorcerer.c:				oldhit			= 	hitapp->modifier;
sorcerer.c:			hitapp->location 	= 	APPLY_HITROLL;
sorcerer.c:			hitapp->modifier	=	0;
sorcerer.c:			hitapp->next 		= 	weapon->apply;
sorcerer.c:			weapon->apply 		= 	hitapp;
sorcerer.c:		for (damapp = weapon->apply; damapp; damapp = damapp->next)
sorcerer.c:			if (damapp->location == APPLY_DAMROLL) {
sorcerer.c:				olddam 			= 	damapp->modifier;
sorcerer.c:			damapp->location 	= 	APPLY_DAMROLL;
sorcerer.c:			damapp->modifier	=	0;
sorcerer.c:			damapp->next 		= 	weapon->apply;
sorcerer.c:			weapon->apply 		= 	damapp;
sorcerer.c:	chance -= (int) (7.5 * (olddam + oldhit));
sorcerer.c:	chance += 4 * (level - ((weapon->value[2]) * weapon->value[1]));
sorcerer.c:			hitapp->modifier += 1;
sorcerer.c:				damage_new(ch,ch,dice(weapon->level,5),TYPE_UNDEFINED,DAM_ENERGY,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the explosion*");
sorcerer.c:				hitapp->modifier -= 1;
sorcerer.c:			damapp->modifier += 1;
sorcerer.c:				damage_new(ch,ch,dice(weapon->level,5),TYPE_UNDEFINED,DAM_ENERGY,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the explosion*");
sorcerer.c:				damapp->modifier -= 1;
sorcerer.c:	if (armor->item_type != ITEM_ARMOR)
sorcerer.c:		avg_ac += armor->value[i];
sorcerer.c:	chance -= 10 * (avg_ac - 5);
sorcerer.c:		chance -= 20;
sorcerer.c:		chance -= 50;
sorcerer.c:	if (armor->pIndexData->limtotal > 0)
sorcerer.c:		chance -= 20;
sorcerer.c:	if (armor->pIndexData->limtotal == 1 || armor->pIndexData->limtotal == 2)
sorcerer.c:		chance -= 30;
sorcerer.c:				armor->value[i]++;
sorcerer.c:			if (armor->weight > 5) {
sorcerer.c:				armor->weight = (int)((float)armor->weight * 1.2);
sorcerer.c:				armor->weight++;
sorcerer.c:				armor->value[i]--;
sorcerer.c:		damage_new(ch,ch,dice(armor->level,5),TYPE_UNDEFINED,DAM_ENERGY,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the explosion*");
sorcerer.c:	if (!str_cmp(obj->material,arg2))
sorcerer.c:	chance += 5 * (ch->level - obj->level);
sorcerer.c:	if (obj->pIndexData->limtotal > 0 && obj->pIndexData->limtotal < 4)
sorcerer.c:	if (obj->pIndexData->limtotal >= 4)
sorcerer.c:		chance -= 20;
sorcerer.c:		free_pstring(obj->material);
sorcerer.c:		obj->material = palloc_string(arg2);
sorcerer.c:		damage_new(ch,ch,dice(obj->level,5),TYPE_UNDEFINED,DAM_ENERGY,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the explosion*");
sorcerer.c:	if (ch->in_room->sector_type == SECT_UNDERWATER)
sorcerer.c:	if (ch->in_room->area->temp == TEMP_HOT
sorcerer.c:		|| ch->in_room->area->temp == TEMP_COLD)
sorcerer.c:	for (vch = ch->in_room->people; vch; vch = vch->next_in_room) {
sorcerer.c:		vch->move = UMIN(vch->move + refresh, vch->max_move);
sorcerer.c:	if(!IS_GROUND(ch->in_room))
sorcerer.c:	if(saves_spell(level - 5, victim, DAM_OTHER))
sorcerer.c:	af.modifier		=	-level/11;
sorcerer.c:	switch(af->duration) {
sorcerer.c:			af->modifier--;
sorcerer.c:		case(-1):
sorcerer.c:			af->modifier--;
sorcerer.c:	if (!IS_GROUND(ch->in_room))
sorcerer.c:	new_affect_to_room(ch->in_room,&raf);
sorcerer.c:	if (room->people)
sorcerer.c:		act("The ground beneath you solidifies.",room->people,0,0,TO_ALL);
sorcerer.c:	if(!IS_GROUND(ch->in_room) || !is_affected_room(ch->in_room,gsn_quicksand)){
sorcerer.c:	if (number_percent() > ch->carry_weight / 5)
sorcerer.c:	af->modifier++;
sorcerer.c:	if(!IS_GROUND(ch->in_room))
sorcerer.c:	victim->move = UMAX(0,victim->move - number_range((int)((float)level*.9),(int)((float)level*1.1)));
sorcerer.c:	for (eq = victim->carrying; eq; eq = eq->next_content) {
sorcerer.c:		if (eq->wear_loc == WEAR_NONE
sorcerer.c:			|| eq->wear_loc == WEAR_WIELD
sorcerer.c:			|| eq->wear_loc == WEAR_DUAL_WIELD
sorcerer.c:			|| eq->wear_loc == WEAR_SHIELD
sorcerer.c:			|| eq->wear_loc == WEAR_LIGHT
sorcerer.c:			|| eq->wear_loc == WEAR_HOLD
sorcerer.c:			|| eq->wear_loc == WEAR_BRAND)
sorcerer.c:		switch (eq->wear_loc) {
sorcerer.c:				oaf.modifier = -1;
sorcerer.c:				oaf.modifier = -2;
sorcerer.c:				oaf.modifier = -3;
sorcerer.c:				oaf.modifier = -4;
sorcerer.c:	ROOM_INDEX_DATA *room = ch->in_room;
sorcerer.c:	if (room->sector_type != SECT_UNDERWATER)
sorcerer.c:		af.modifier		=	-5;
sorcerer.c:		af.modifier		=	-4;
sorcerer.c:		if (victim->level < ch->level - 9) {
sorcerer.c:	if (!IS_GROUND(ch->in_room))
sorcerer.c:	if (ch->pause > 2)
sorcerer.c:	act("You conjure a super-bright arc of plasma at $N!",ch,NULL,victim,TO_CHAR);
sorcerer.c:	act("$n conjures a super-bright arc of plasma at you!",ch,NULL,victim,TO_VICT);
sorcerer.c:	act("$n conjures a super-bright arc of plasma at $N!",ch,NULL,victim,TO_NOTVICT);
sorcerer.c:		if ((pRoomIndex->area == ch->in_room->area
sorcerer.c:			&& !IS_SET(pRoomIndex->room_flags, ROOM_NO_RECALL)
sorcerer.c:			&&  !pRoomIndex->cabal) || pRoomIndex == ch->in_room)
sorcerer.c:	for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
sorcerer.c:		vch_next = vch->next_in_room;
sorcerer.c:	check_plasma_thread(ch,-1);
sorcerer.c:	for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
sorcerer.c:		vch_next = vch->next_in_room;
sorcerer.c:	if (paf->aftype == AFT_TIMER)
sorcerer.c:	af.level	= ch->level;
sorcerer.c:	af.duration	= ch->level/5;
sorcerer.c:	if (!ch->fighting)
sorcerer.c:	act("A tendril of plasma from the sphere encircling you lashes out at $N!",ch,0,ch->fighting,TO_CHAR);
sorcerer.c:	damage_new(ch,ch->fighting,af->level,gsn_sphere_of_plasma,DAM_TRUESTRIKE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,NULL);
sorcerer.c:	if (--af->modifier <= 0)
sorcerer.c:	if (is_affected_room(ch->in_room,sn))
sorcerer.c:	affect_to_room(ch->in_room,&raf);
sorcerer.c:	room = ch->in_room;
sorcerer.c:	if (!room->people)
sorcerer.c:	for(victim = room->people; victim; victim = victim->next_in_room)
sorcerer.c:		if (!is_safe_new(af->owner,victim,FALSE))
sorcerer.c:		for (victim = room->people; victim; victim = victim->next_in_room) {
sorcerer.c:			if (is_safe_new(af->owner,victim,FALSE))
sorcerer.c:	if (victim->fighting)
sorcerer.c:	if (af->modifier == 0)
sorcerer.c:		af->modifier = 1;
sorcerer.c:	dam = dice(af->level,10) / af->modifier;
sorcerer.c:	damage_new(af->owner,victim,dam,gsn_essence_of_plasma,DAM_ENERGY,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the essence of plasma*");
sorcerer.c:	af->modifier++;
sorcerer.c:	if (af->modifier >= 25)
sorcerer.c:	if (!room->people)
sorcerer.c:	act("The writhing mass of plasma flickers one last time and then dissipates.",room->people,0,0,TO_ALL);
sorcerer.c:	if (paf->owner)
sorcerer.c:		act("The thread of plasma no longer connects you to $N.",ch,NULL,paf->owner,TO_CHAR);
sorcerer.c:	af = affect_find(ch->affected, gsn_plasma_thread);
sorcerer.c:		victim = af->owner;
sorcerer.c:	if (ch->in_room == victim->in_room)
sorcerer.c:	if (direction == -1)
sorcerer.c:		char_to_room(victim,ch->in_room);
sorcerer.c:	if (ch->in_room != victim->in_room)
sorcerer.c:		char_to_room(ch,victim->in_room);
sorcerer.c:    if (!IS_GROUND(ch->in_room)) {
sorcerer.c:    	if (number_range(0, 100) > (40 + (ch->level / 2)))
sorcerer.c:    	dam = dice(obj->level,2)/2;
sorcerer.c:		if(check_dispel(ch->level+3,victim,skill_lookup("stoneskin")))
sorcerer.c:			damage_new(ch,victim,dice(ch->level,10),sn,DAM_BASH,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"The molten rock*");
sorcerer.c:	int where, count=0, mcount=(ch->level/15)+2;
sorcerer.c:	old_room = ch->in_room;
sorcerer.c:		   	((pexit = old_room->exit[where]) == NULL))
sorcerer.c:		to_room = pexit->u1.to_room;
sorcerer.c:    	if(	to_room->sector_type == SECT_UNDERWATER ||
sorcerer.c:	   		to_room->sector_type == SECT_AIR ||
sorcerer.c:	   		to_room->sector_type == SECT_VERTICAL ||
sorcerer.c:			to_room == ch->in_room)
sorcerer.c:	if (mana > ch->mana + 100)
sorcerer.c:		ch->mana -= mana;
sorcerer.c:		ch->mana += 100;
sorcerer.c:	oaf.duration	=	-1;
sorcerer.c:	af->modifier = (int)((float)af->modifier * 0.96);
sorcerer.c:	if (af->modifier <= 0) {
sorcerer.c:		if (obj->carried_by)
sorcerer.c:			act("$p crumbles to dust as the energy contained within dissipates.",obj->carried_by,obj,0,TO_CHAR);
sorcerer.c:	af = affect_find_obj(obj->affected,gsn_fashion_crystal);
sorcerer.c:	dam = number_range(35,45) * af->modifier;
sorcerer.c:	af->modifier = (int)((float)af->modifier * 0.9);
sorcerer.c:	if (af->modifier == 0) {
sorcerer.c:	af = affect_find_obj(obj->affected,gsn_fashion_crystal);
sorcerer.c:	act("$p suddenly explodes in mid-air, unleashing a torrent of raw energy!",ch,obj,0,TO_ROOM);
sorcerer.c:	for (vch = ch->in_room->people; vch; vch = vch_next) {
sorcerer.c:		vch_next = vch->next_in_room;
sorcerer.c:		dam = number_range(45,60) * af->modifier;
sorcerer.c:	oaf = affect_find_obj(obj->affected,gsn_fashion_crystal);
sorcerer.c:	charges = UMAX(1,oaf->modifier / 100);
sorcerer.c:		for (paf = ch->affected; paf; paf = paf->next)
sorcerer.c:			if (paf->type == gsn_rotating_ward)
sorcerer.c:	if (count >= (ch->level / 25))
sorcerer.c:		af->modifier--;
sorcerer.c:	if (af->modifier <= 0) {
sorcerer.c:	af = affect_find_obj(crystal->affected, gsn_fashion_crystal);
sorcerer.c:	af->tick_fun	= 	NULL;
sorcerer.c:	af->modifier /= 2;
sorcerer.c:	if(ch->level < 10)
sorcerer.c:	else if(10 > ch->level < 15)
sorcerer.c:	if(ch->level > 40 && number_percent() > 50 && !is_affected(victim,gsn_mana_sickness) && victim->hit > level + 30)
sorcerer.c:	damage_new(af->owner ? af->owner : ch,ch,af->owner ? af->owner->level/2 : ch->level/2,gsn_mana_sickness,TRUE,DAM_OTHER,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the escaping mana*");
special.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
special.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
special.c:    if (ch->position != POS_FIGHTING) {
special.c:       for ( victim = ch->in_room->people; victim != NULL; victim = v_next)
special.c:          v_next = victim->next_in_room;
special.c:             && (victim->level > ch->level)
special.c:             && (victim->level < ch->level + 10))
special.c:	     do_backstab(ch,victim->name);
special.c:             if (ch->position != POS_FIGHTING)
special.c:                 do_murder(ch,victim->name);
special.c:    if ( (victim = ch->fighting) == NULL)
special.c:                 gold = victim->gold / 10;  /* steal 10% of his gold */
special.c:                 victim->gold -= gold;
special.c:                 ch->gold     += gold;
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	v_next = victim->next_in_room;
special.c:	if ( victim->fighting == ch && number_bits( 3 ) == 0 )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim, TARGET_CHAR);
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    if ( ch->position != POS_FIGHTING || number_percent() > 20)
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, NULL,TARGET_CHAR);
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	v_next = victim->next_in_room;
special.c:	     && !IS_NPC(victim) && victim->level < 11)
special.c:	spell_armor( skill_lookup( "armor" ), ch->level,ch,victim,TARGET_CHAR);
special.c:	spell_bless( skill_lookup( "bless" ), ch->level,ch,victim,TARGET_CHAR);
special.c:	    ch->level, ch, victim,TARGET_CHAR);
special.c:	    ch->level, ch, victim,TARGET_CHAR);
special.c:	    ch->level, ch, victim,TARGET_CHAR);
special.c:	spell_refresh( skill_lookup("refresh"),ch->level,ch,victim,TARGET_CHAR);
special.c:	    ch->level,ch,victim,TARGET_CHAR);
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	v_next = victim->next_in_room;
special.c:	if ( victim->fighting == ch && number_bits( 2 ) == 0 )
special.c:	if ( ch->level >= min_level )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim,TARGET_CHAR);
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:        v_next = victim->next_in_room;
special.c:        if ( victim->fighting == ch && number_bits( 2 ) == 0 )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim,TARGET_CHAR);
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	v_next = victim->next_in_room;
special.c:	if ( victim->fighting == ch && number_bits( 2 ) == 0 )
special.c:	if ( ch->level >= min_level )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim,TARGET_CHAR);
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	v_next = victim->next_in_room;
special.c:	if ( victim->fighting == ch && number_bits( 2 ) == 0 )
special.c:	if ( ch->level >= min_level )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim,TARGET_CHAR);
special.c:    if ( !IS_AWAKE(ch) || ch->fighting != NULL )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	v_next = victim->next_in_room;
special.c:	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_CRIMINAL)
special.c:	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_CRIMINAL)
special.c:	victim->name);
special.c:    REMOVE_BIT(ch->comm,COMM_NOSHOUT);
special.c:    for ( corpse = ch->in_room->contents; corpse != NULL; corpse = c_next )
special.c:	c_next = corpse->next_content;
special.c:	if ( corpse->item_type != ITEM_CORPSE_NPC )
special.c:	for ( obj = corpse->contains; obj; obj = obj_next )
special.c:	    obj_next = obj->next_content;
special.c:	    obj_to_room( obj, ch->in_room );
special.c:    if ( !IS_AWAKE(ch) || ch->fighting != NULL )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	v_next = victim->next_in_room;
special.c:	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_CRIMINAL)
special.c:	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_CRIMINAL)
special.c:	if ( victim->fighting != NULL
special.c:	&&   victim->fighting != ch
special.c:	&&   victim->alignment < max_evil )
special.c:	    max_evil = victim->alignment;
special.c:	    victim->name);
special.c: 	REMOVE_BIT(ch->comm,COMM_NOSHOUT);
special.c:    for ( trash = ch->in_room->contents; trash != NULL; trash = trash_next )
special.c:	trash_next = trash->next_content;
special.c:	if ( !IS_SET( trash->wear_flags, ITEM_TAKE ) || !can_loot(ch,trash) || trash->item_type == ITEM_CORPSE_PC)
special.c:	if ( trash->item_type == ITEM_DRINK_CON
special.c:	||   trash->item_type == ITEM_TRASH
special.c:	||   trash->cost < 10 )
special.c:    if ( ch->fighting != NULL )
special.c:    if ( !move || ch->position < POS_SLEEPING )
special.c:	move_char( ch, path[pos] - '0', FALSE, TRUE );
special.c:	ch->position = POS_STANDING;
special.c:	ch->position = POS_SLEEPING;
special.c:    if ( ch->position != POS_FIGHTING
special.c:    || ( victim = ch->fighting ) == NULL
special.c:    ||   number_percent( ) > 2 * ch->level )
special.c:    spell_poison( gsn_poison, ch->level, ch, victim,TARGET_CHAR);
special.c:    if ( ch->position != POS_STANDING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	v_next = victim->next_in_room;
special.c:	||   victim->level >= LEVEL_IMMORTAL
special.c:	if ( IS_AWAKE(victim) && number_range( 0, ch->level ) == 0 )
special.c:	    gold = victim->gold * UMIN(number_range(1,20),ch->level / 2) / 100;
special.c:	    gold = UMIN(gold, ch->level * ch->level * 10 );
special.c:	    ch->gold     += gold;
special.c:	    victim->gold -= gold;
special.c:    if ( !IS_AWAKE(ch) || ch->fighting != NULL )
special.c:    if (ch->leader != NULL && IS_SET(ch->leader->act,PLR_CRIMINAL))
special.c:	send_to_char("Guards will not follow a CRIMINAL!\n\r",ch->leader);
special.c:	REMOVE_BIT(ch->affected_by,AFF_CHARM);
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	v_next = victim->next_in_room;
special.c:	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_CRIMINAL)
special.c:	    victim->name);
special.c: 	REMOVE_BIT(ch->comm,COMM_NOSHOUT);
special.c:    if (ch->position != POS_FIGHTING)
special.c:    for (victim = ch->in_room->people; victim != NULL; victim = v_next)
special.c:	v_next = victim->next_in_room;
special.c:	if (victim->fighting == ch && number_bits(2) == 0)
special.c:    if (ch->fighting == NULL)
special.c:        for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
special.c:            vch_next = vch->next_in_room;
special.c:            if (vch->fighting == ch && number_bits(2) == 0)
special.c:    if (IS_SET(vch->act,PLR_CRIMINAL))
special.c:        (*skill_table[sn_hand].spell_fun) (sn_hand,ch->level,ch,vch,TARGET_CHAR);
special.c:    if (ch->fighting == NULL)
special.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
special.c:        vch_next = vch->next_in_room;
special.c:    if (ch->fighting != NULL)
special.c:        for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
special.c:            vch_next = vch->next_in_room;
special.c:            if (vch->fighting == ch && number_bits(2) == 0)
special.c:        (*skill_table[gsn_acid_spit].spell_fun) (gsn_acid_spit,ch->level,ch,vch,TARGET_CHAR);
special.c:    af.modifier = -2;
special.c:    if ( (vch = ch->fighting) == NULL)
special.c:    if (ch->fighting == NULL)
special.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
special.c:        vch_next = vch->next_in_room;
special.c:        if (vch->fighting == ch && number_bits(2) == 0)
special.c:		vch = ch->fighting;
special.c:        do_ram(ch,vch->name);
special.c:        (*skill_table[sn].spell_fun) (sn,ch->level,ch,vch,TARGET_CHAR);
special.c:        do_tail(ch,vch->name);
special.c:    chance = 50 + ((ch->level - victim->level) * 2);
special.c:    chance -= get_curr_stat(victim,STAT_DEX)/2;
special.c:		vch = ch->fighting;
special.c:            dam = dice(ch->level,4);
special.c:    if (ch->position != POS_FIGHTING)
special.c:        if (ch->last_fought == NULL)
special.c:        if (ch->last_fought->in_room->area != ch->in_room->area)
special.c:            victim = ch->last_fought;
special.c:	if (victim->fighting != NULL)
special.c:	if (victim->position == POS_FIGHTING)
special.c:	if (saves_spell(ch->level,victim,DAM_OTHER))
special.c:        char_to_room(victim,ch->in_room);
special.c:        sprintf(buf,"Help! I'm being summoned by %s!",ch->short_descr);
special.c:        multi_hit(ch,victim,-1);
special.c:    for (victim = ch->in_room->people; victim != NULL; victim = v_next)
special.c:        v_next = victim->next_in_room;
special.c:        if (victim->fighting == ch && number_bits(2)  == 0)
special.c:        (*skill_table[sn_elemental].spell_fun) (sn_elemental,ch->level,ch,NULL,TARGET_CHAR);
special.c:    (*skill_table[sn].spell_fun) (sn,ch->level,ch,victim,TARGET_CHAR);
special.c:        if (ch->fighting == NULL)
special.c:        if (sceptre != NULL && sceptre->pIndexData->vnum == OBJ_VNUM_HEAVENLY_SCEPTRE
special.c:    sn = -1;
special.c:    if (ch->fighting == NULL && ch->last_fought == NULL)
special.c:    for (vch = char_list;vch != NULL; vch = vch->next)
special.c:	if (vch->in_room ==NULL)
special.c:        if (vch->in_room->area != ch->in_room->area
special.c:    if (ch->position == POS_SLEEPING)
special.c:    if (ch->fighting == NULL)
special.c:	vch_next = vch->next_in_room;
special.c:	if (vch->in_room != ch->in_room)
special.c:	sprintf(buf,"Help! %s is attacking me!",ch->short_descr);
special.c:    if (ch->fighting == NULL && ch->last_fought != NULL)
special.c:            vch_next = vch->next;
special.c:            if (vch->in_room->area != ch->in_room->area)
special.c:            if (is_same_group(vch,ch->last_fought)
special.c:            && !saves_spell(ch->level,vch,DAM_OTHER) )
special.c:char_to_room(vch,ch->in_room);
special.c:        sn = -1;
special.c:    if (sn == -1)
special.c:        for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
special.c:            if (IS_NPC(vch) && vch->pIndexData->vnum == MOB_VNUM_SLAYER)
special.c:char_to_room(mob,ch->in_room);
special.c:mob->leader = ch;
special.c:mob->master = ch;
special.c:SET_BIT(mob->affected_by, AFF_CHARM);
special.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
special.c:        vch_next = vch->next_in_room;
special.c:        if (vch->fighting == ch && number_bits(2) == 0)
special.c:    (*skill_table[sn].spell_fun) (sn,ch->level,ch,vch,skill_table[sn].target);
special.c:    if (ch->position != POS_FIGHTING)
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	v_next = victim->next_in_room;
special.c:	if ( victim->fighting == ch && number_bits( 2 ) == 0 )
special.c:    if (ch->position != POS_FIGHTING)
special.c:    sn = -1;
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	v_next = victim->next_in_room;
special.c:	if ( victim->fighting == ch && number_bits( 2 ) == 0 )
special.c:    lvl = ch->level;
special.c:    if (ch->position != POS_FIGHTING)
special.c:    sn = -1;
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	v_next = victim->next_in_room;
special.c:	if ( victim->fighting == ch && number_bits( 2 ) == 0 )
special.c:    lvl = ch->level;
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    sn1 = -1;    sn2 = -1;    sn3 = -1;
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	v_next = victim->next_in_room;
special.c:    if ( victim->fighting == ch && number_percent() < 30 )
special.c:        (*skill_table[sn1].spell_fun) ( sn1, ch->level, ch, victim1,TARGET_CHAR );
special.c:        (*skill_table[sn2].spell_fun) ( sn1, ch->level, ch,victim2,skill_table[sn2].target );
special.c:        (*skill_table[sn3].spell_fun) ( sn3, ch->level, ch,victim3,skill_table[sn3].target );
special.c:    sn = -1;
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	v_next = victim->next_in_room;
special.c:	if ( victim->fighting == ch && number_bits( 2 ) == 0 )
special.c:    lvl = ch->level;
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	v_next = victim->next_in_room;
special.c:	if ( victim->fighting == ch && number_bits( 2 ) == 0 )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim, TAR_CHAR_OFFENSIVE );
special.c:    if (ch->position != POS_FIGHTING)
special.c:    victim = ch->fighting;
special.c:    level = ch->level + 3;
special.c:    chance = (ch->level - victim->level)*3;
special.c:    chance -= get_curr_stat(victim,STAT_DEX)/2;
special.c:    chance -= get_curr_stat(victim,STAT_STR)/3;
special.c:        chance -= 30;
special.c:        chance -= 30;
special.c:    chance += (ch->size - victim->size)*10;
special.c:    was_in = victim->in_room;
special.c:	if ( ( pexit = was_in->exit[door] ) == 0
special.c:	||   pexit->u1.to_room == NULL
special.c:        ||  ( IS_SET(pexit->exit_info, EX_CLOSED) )
special.c:	&&   IS_SET(pexit->u1.to_room->room_flags, ROOM_NO_MOB) ) )
special.c:        if ( ( was_in->sector_type == SECT_AIR)
special.c:        ||  ( (pexit->u1.to_room->sector_type == SECT_AIR )
special.c:        if (IS_SET(pexit->exit_info,EX_CLOSED))
special.c:        char_to_room(victim, pexit->u1.to_room);
special.c:if (IS_SET(pexit->exit_info,EX_CLOSED))
special.c:        REMOVE_BIT(pexit->exit_info,EX_CLOSED);
special.c:	if (victim->in_room->exit[rev_door] != NULL)
special.c:	REMOVE_BIT(victim->in_room->exit[rev_door]->exit_info,EX_CLOSED);
special.c:        if (saves_spell(ch->level - 3,victim,DAM_BASH))
special.c:        if (saves_spell(ch->level - 3,victim,DAM_BASH))
special.c:    if ( ch->position != POS_FIGHTING  && ch->last_fought != NULL)
special.c:    if (ch->position != POS_FIGHTING)
special.c:    level = ch->level;
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	v_next = victim->next_in_room;
special.c:    if ( victim->fighting == ch && number_percent() < 30 )
special.c:        (*skill_table[sn1].spell_fun) ( sn1, ch->level, ch, victim1,skill_table[sn1].target );
special.c:    if ( ( sn2 >= 0 ) && victim2->in_room == ch->in_room)
special.c:    if (victim3 != NULL && victim3->in_room == ch->in_room)
special.c:    act("$n strafes the room in a crossfire of searing blue-green fire!",ch,0,0,TO_ROOM);
special.c:    dam = dice(ch->level, 12);
special.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
special.c:        vch_next = vch->next_in_room;
special.c:        if (IS_NPC(vch) && vch->pIndexData->vnum == MOB_VNUM_BONES)
special.c:            tmp_dam  -= 50;
special.c:    if (ch->position != POS_FIGHTING)
special.c:    bane = ch->fighting;
special.c:    if (bane->pIndexData->vnum == 13718)
special.c:    (*skill_table[sn].spell_fun) (sn,ch->level,ch,bane,skill_table[sn].target);
special.c:    (*skill_table[sn].spell_fun) (sn,ch->level,ch,bane,skill_table[sn].target);
special.c:    if (ch->position == POS_FIGHTING)
special.c:    if (ch->position != POS_FIGHTING
special.c:    && ch->last_fought == NULL
special.c:    if ( ch->position != POS_FIGHTING )
special.c:        if (ch->level < 45)
special.c:        if (ch->pIndexData->vnum != 29723
special.c:        && ch->pIndexData->vnum != 29731)
special.c:        for (victim = ch->in_room->people; victim != NULL; victim = v_next)
special.c:            v_next = victim->next_in_room;
special.c:            if (victim != ch && victim->leader != ch
special.c:            && victim->master != ch && can_see(victim,ch)
special.c:	sprintf(buf1,"Help! %s is casting on me!",ch->short_descr);
special.c:    (*skill_table[sn].spell_fun) ( sn,IS_NPC(victim) ?  60 : ch->level - 2, ch, victim , TAR_CHAR_OFFENSIVE);
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	v_next = victim->next_in_room;
special.c:	if ( victim->fighting == ch && number_bits( 2 ) == 0 )
special.c:	if ( ch->level >= min_level )
special.c:    for (search = char_list; search != NULL; search = search->next)
special.c:    if (IS_NPC(search) && (search->master == ch)
special.c:    && search->pIndexData->vnum == MOB_VNUM_ZOMBIE)
special.c:    if ((ch->level < 30 && count > 1) || (ch->level < 35 && count > 2)
special.c:    || (ch->level < 40 && count > 3) || (ch->level < 51 && count > 4)
special.c:    if ((corpse->item_type != ITEM_CORPSE_NPC) && (corpse->item_type != ITEM_CORPSE_PC) )
special.c:   if (IS_SET(corpse->extra_flags,CORPSE_NO_ANIMATE))
special.c:    name = corpse->short_descr;
special.c:    for (obj = corpse->contains; obj != NULL; obj = obj_next)
special.c:    obj_next = obj->next_content;
special.c:    obj_to_room(obj,ch->in_room);
special.c:    af.level = ch->level;
special.c:    char_to_room(zombie,ch->in_room);
special.c:    z_level = UMAX(1,corpse->level - 5);
special.c:    zombie->level = z_level;
special.c:    zombie->max_hit = (dice(z_level, 15));
special.c:    zombie->max_hit += (z_level * 18);
special.c:    zombie->hit = zombie->max_hit;
special.c:    zombie->damroll += z_level*2/3;
special.c:    zombie->alignment = -1000;
special.c:    last_name = one_argument(corpse->short_descr, name);
special.c:    free_pstring(zombie->short_descr);
special.c:    free_pstring(zombie->long_descr);
special.c:    zombie->short_descr = palloc_string(buf1);
special.c:    zombie->long_descr = palloc_string(buf2);
special.c:    zombie->leader = ch;
special.c:    af.duration = -1;
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim , TAR_CHAR_OFFENSIVE);
special.c:    if ( ch->position != POS_FIGHTING )
special.c:        if (ch->level < 51)
special.c:        if ( ch->pIndexData->vnum != 29732)
special.c:        for (victim = ch->in_room->people; victim != NULL; victim = v_next)
special.c:            v_next = victim->next_in_room;
special.c:            if (victim != ch && victim->leader != ch
special.c:            && victim->master != ch && can_see(victim,ch)
special.c:    for (victim = ch->in_room->people; victim != NULL; victim = v_next)
special.c:            v_next = victim->next_in_room;
special.c:            if (victim != ch && victim->leader != ch
special.c:            && victim->master != ch)
special.c:	sprintf(buf1,"Help! %s is casting on me!",ch->short_descr);
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim + 4 , TAR_CHAR_OFFENSIVE);
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	v_next = victim->next_in_room;
special.c:	if ( victim->fighting == ch && number_bits( 2 ) == 0 )
special.c:        case 7: case 8: min_level = 45; sn = -1; break;
special.c:	if ( ch->level >= min_level )
special.c:    if (sn == -1)
special.c:        for (victim = ch->in_room->people; victim != NULL; victim = victim->next_in_room)
special.c:            if (IS_NPC(victim) && victim->pIndexData->vnum == MOB_VNUM_SLAYER)
special.c:char_to_room(mob,ch->in_room);
special.c:mob->leader = ch;
special.c:mob->master = ch;
special.c:mob->level = ch->level;
special.c:SET_BIT(mob->affected_by, AFF_CHARM);
special.c:    lvl = ch->level;
special.c:    if (ch->fighting == NULL)
special.c:        if (ch->last_fought != NULL)
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	v_next = victim->next_in_room;
special.c:	if ( victim->fighting == ch && number_bits( 2 ) == 0 )
special.c:        case 4: sn = -1;    break;
special.c:        default: sn = -1; break;
special.c:    if (sn == -1)
special.c:        chance = 50 + (ch->level - victim->level) * 3;
special.c:        dam = dice(ch->level,8);
special.c:        if (saves_spell(ch->level,victim,DAM_BASH))
special.c:        (*skill_table[sn].spell_fun) ( sn,ch->level, ch, victim , TAR_CHAR_OFFENSIVE);
special.c:    level = ch->level;
special.c:    if (ch->position == POS_SLEEPING) /* stops blackjack/strangle */
special.c:        ch->position = POS_STANDING;
special.c:    if (ch->position != POS_FIGHTING)
special.c:        for (victim = ch->in_room->people; victim != NULL; victim = v_next)
special.c:	v_next = victim->next_in_room;
special.c:            || ( IS_NPC(victim) && victim->pIndexData->vnum == 29782) )
special.c:    dam = 400 + dice(ch->level,5);
special.c:    if (saves_spell(ch->level,victim,DAM_NEGATIVE))
special.c:	ach_next = ach->next;
special.c:        if (ach->in_room == NULL)
special.c:        if (ach->in_room->area != ch->in_room->area)
special.c:        if (ach->in_room->sector_type >= min_sect
special.c:        && ach->in_room->sector_type < max_sect)
special.c:	ach_next = ach->next;
special.c:        if (ach->in_room == NULL)
special.c:        if (ach->in_room->area != ch->in_room->area)
special.c:        if (ach->in_room->sector_type >= min_sect
special.c:        && ach->in_room->sector_type < max_sect
special.c:        char_to_room(mob,ach->in_room);
special.c:	ach_next = ach->next;
special.c:        if (ach->in_room == NULL)
special.c:        if (ach->in_room->area != ch->in_room->area)
special.c:        if (ach->in_room->sector_type >= min_sect
special.c:        && ach->in_room->sector_type < max_sect
special.c:    dam = dice(ch->level,6);
special.c:    for (victim = ch->in_room->people; victim != NULL; victim = v_next)
special.c:        v_next = victim->next_in_room;
special.c:damage_old(ch,victim,(saves_spell(ch->level,victim,DAM_OTHER) ? dam/2 : dam),sn, DAM_BASH,TRUE);
special.c:    if (ch->position != POS_FIGHTING)
special.c:    level = ch->level;
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	v_next = victim->next_in_room;
special.c:    level -= 3;   /* decrement damage */
special.c:	for (tmp_vict = ch->in_room->people; tmp_vict != NULL;  tmp_vict = next_vict)
special.c:	  next_vict = tmp_vict->next_in_room;
special.c:	     if (number_percent()>=ch->level)
special.c:        level -= 3;  /* decrement damage */
special.c:	  level -= 4;  /* decrement damage */
special.c:    if (ch->position != POS_FIGHTING)
special.c:    level = ch->level;
special.c:        for (victim = ch->in_room->people; victim != NULL; victim = v_next)
special.c:            v_next = victim->next_in_room;
special.c:    if (ch->position != POS_FIGHTING)
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:    v_next = victim->next_in_room;
special.c:        dam = dice(ch->level,13);
special.c:            damage_old(ch,victim,saves_spell(ch->level,victim,DAM_LIGHT) ? dam/2 : dam, sn, DAM_LIGHT,TRUE);
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next)
special.c:	v_next = victim->next_in_room;
special.c:	if(victim->fighting==ch) {
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim, TAR_CHAR_OFFENSIVE );
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next)
special.c:	v_next = victim->next_in_room;
special.c:	if(victim->fighting==ch) {
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim, TAR_CHAR_OFFENSIVE );
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next)
special.c:	v_next = victim->next_in_room;
special.c:	if(victim->fighting==ch) {
special.c:	for ( victim = ch->in_room->people; victim != NULL; victim = v_next)
special.c:		v_next = victim->next_in_room;
special.c:		if(victim->fighting==ch) {
special.c:       if (ch->position != POS_FIGHTING || victim == NULL)
special.c:	if (victim->alignment == 1000) {
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next)
special.c:        v_next = victim->next_in_room;
special.c:        if(victim->fighting==ch) {
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level+1, ch, victim, TAR_CHAR_OFFENSIVE );
special.c:	CHAR_DATA *master = ch->master, *mob;
special.c:        if(!master || master->in_room!=mob->in_room)
special.c:		if((!str_cmp(spell,"heal") || !str_cmp(spell,"cure critical")) && master->hit>(master->max_hit*.60))
special.c:                (*skill_table[sn].spell_fun) ( sn, mob->level, mob, master, TAR_CHAR_DEFENSIVE);
special.c:	if(!ch->fighting)
special.c:		for(vch=ch->in_room->people;vch!=NULL;vch=vch->next_in_room)
special.c:		if(IS_NPC(vch) || vch->pcdata->bounty>=500 || !vch->fighting || vch->fighting!=ch)
special.c:		vch->pcdata->bounty=500;
special.c:		(*skill_table[sn].spell_fun) ( sn, ch->level, ch, ch->fighting, TAR_CHAR_OFFENSIVE);
special.c:        CHAR_DATA *victim = ch->fighting;
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level+1, ch, victim, TARGET_CHAR );
special.c:	CHAR_DATA *victim = ch->fighting;
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level+1, ch, victim, TARGET_CHAR);
special.c:	CHAR_DATA *victim = ch->fighting;
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level+1, ch, victim, TARGET_CHAR );
special.c:	CHAR_DATA *victim = ch->fighting;
special.c:	if(victim==NULL || victim->in_room != ch->in_room)
special.c:		af.duration = ch->level/6;
special.c:		af.modifier = -ch->level/9;
special.c:		af.level = ch->level;
special.c:		af.duration = ch->level/6;
special.c:		af.modifier = -ch->level/6;
special.c:		af.level = ch->level;
special.c:	CHAR_DATA *victim = ch->fighting;
special.c:	if(victim==NULL ||  victim->in_room != ch->in_room)
special.c:	CHAR_DATA *master = ch->leader;
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level+1, ch, master, TAR_CHAR_DEFENSIVE );
special.c:	CHAR_DATA *victim=ch->fighting;
special.c:	if((victim!=NULL && victim->in_room == ch->in_room) && (number_percent() > 90) && !is_affected(ch,gsn_trophy) && !is_affected(victim,gsn_impale)) {
special.c:	af.modifier = -ch->level/5;
special.c:	af.duration = ch->level/4;
special.c:	af.level = ch->level;
special.c:	af.owner = ch->leader;
special.c:	caf.level = ch->level;
special.c:	caf.owner = ch->leader;
sql.c:	return this->row[rowindex];
sql.c:	return atoi(this->row[rowindex]);
sql.c:	return atof(this->row[rowindex]);
string.c: *  and has been used here for OLC - OLC would not be what it is without   *
string.c:    send_to_char( "-========- Entering EDIT Mode -=========-\n\r", ch );
string.c:    send_to_char( "-=======================================-\n\r", ch );
string.c:    ch->desc->pString = pString;
string.c:    send_to_char( "-=======- Entering APPEND Mode -========-\n\r", ch );
string.c:    send_to_char( "-=======================================-\n\r", ch );
string.c:    if ( *(*pString + strlen( *pString ) - 1) != '\r' )
string.c:    ch->desc->pString = pString;
string.c:        i = strlen( orig ) - strlen( strstr( orig, old ) );
string.c:            **ch->desc->pString = '\0';
string.c:            send_to_char( *ch->desc->pString, ch );
string.c:	    	smash_tilde( arg3 );   /* Just to be sure -- Hugin */
string.c:            *ch->desc->pString = string_replace( *ch->desc->pString, arg2, arg3 );
string.c:            *ch->desc->pString = format_string( *ch->desc->pString );
string.c:			if(**ch->desc->pString == '\0')
string.c:			strcpy(obuf, *ch->desc->pString);
string.c:			for (len = strlen(obuf); len > 0; len--)
string.c:							len--;
string.c:						free_pstring(*ch->desc->pString);
string.c:						*ch->desc->pString = palloc_string(obuf);
string.c:			free_pstring(*ch->desc->pString);
string.c:			*ch->desc->pString = palloc_string(obuf);
string.c:            send_to_char( ".r 'old' 'new'   - replace a substring \n\r", ch );
string.c:            send_to_char( ".h               - get help (this info)\n\r", ch );
string.c:            send_to_char( ".s               - show string so far  \n\r", ch );
string.c:            send_to_char( ".f               - (word wrap) string  \n\r", ch );
string.c:            send_to_char( ".c               - clear string so far \n\r", ch );
string.c:			send_to_char( ".d               - delete the last line\n\r", ch );
string.c:			send_to_char( "@                - end string          \n\r", ch );
string.c:        ch->desc->pString = NULL;
string.c:    strcpy( buf, *ch->desc->pString );
string.c:     * --------------------------------------
string.c:    if ( strlen( buf ) + strlen( argument ) >= ( MAX_STRING_LENGTH - 4 ) )
string.c:        ch->desc->pString = NULL;
string.c:     * --------------------------------
string.c:    free_pstring( *ch->desc->pString );
string.c:    *ch->desc->pString = palloc_string( buf );
string.c: Purpose:	Special string formating and word-wrapping.
string.c:      if (xbuf[i-1] != ' ')
string.c:      if (xbuf[i-1] != ' ')
string.c:      if (xbuf[i-1]==' ' && xbuf[i-2]==' ' &&
string.c:          (xbuf[i-3]=='.' || xbuf[i-3]=='?' || xbuf[i-3]=='!'))
string.c:        xbuf[i-2]=*rdesc;
string.c:        xbuf[i-1]=' ';
string.c:    else if ((*rdesc=='.' && *(rdesc+1)!='.' && *(rdesc-1)!='.') || *rdesc=='?' || *rdesc=='!') {
string.c:      if (xbuf[i-1]==' ' && xbuf[i-2]==' ' &&
string.c:          (xbuf[i-3]=='.' || xbuf[i-3]=='?' || xbuf[i-3]=='!')) {
string.c:        xbuf[i-2]=*rdesc;
string.c:          xbuf[i-1]=' ';
string.c:          xbuf[i-1]='\"';
string.c:    for (i=(xbuf[0]?76:73) ; i ; i--)
string.c:      strcat(xbuf,"-\n\r");
string.c:    i--;
string.c:  if (xbuf[strlen(xbuf)-2] != '\n')
string.c:        s--;
string.c:            s--;
strings.c:#define UPCHAR(c)       ((c) >= 'a' && (c) <= 'z' ? (c) + 'A' - 'a' : (c))
strings.c:	return (int)*(myString-1);
strings.c:	*(myString - 1) = nRef;
strings.c:	return (int)(i-myString);
strings.c:	return (int)(i-myString);
strings.c:		return -1;
strings.c:	return (cptr - myString);
strings.c:		return -1;
strings.c:	return (cptr - myString);
strings.c:		return -1;
strings.c:	return (cptr - myString);
strings.c:		return -1;
strings.c:	return (cptr - myString);
strings.c:	return (Find(substr, 0, fIgnoreCase) > -1);
strings.c:	return (Find(substr, 0, fIgnoreCase) > -1);
strings.c:			*(myString + i) += 'A' - 'a';
strings.c:			*(myString + i) += 'A' - 'a';
strings.c:			*(myString + i) += 'a' - 'A';
strings.c:			*(myString + i) += 'a' - 'A';
strings.c:		*myString += 'A' - 'a';
strings.c:			*(myString + i) += 'a' - 'A';
strings.c:		*myString += 'A' - 'a';
strings.c:			*(myString + i) += 'a' - 'A';
strings.c:	SetRefCount(RefCount()-1);
strings.c:		SetRefCount(RefCount() - 1);
strings.c:	myString--;
strings.c:	*this->Format(arglist, msg);
strings.c:	*this->Format(arglist, msg);
tables.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
tables.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
tables.c:        //Yes, this means you Zethus.						-Cal
tables.c:        {"anti_paladin_only",	O,	RESTRICT_CLASS,	"anti-paladin"	},
tables.c: * 0 - Clear
tables.c: * 1 - Partly Cloudy
tables.c: * 2 - Overcast
tables.c: * 3 - Drizzle
tables.c: * 4 - Downpour
tables.c: * 5 - Thunderstorm
tables.c: * 6 - Snow Flurry
tables.c: * 7 - Blizzard
tables.c: * 8 - Hail
tables.c: * 0 - Hot
tables.c: * 1 - Warm
tables.c: * 2 - Cool
tables.c: * 3 - Cold
tables.c: * and the regional climate.  It randomizes a number from 1-100, and starts
tables.c: *                                                    --Eladrian
tables.c:        { "pleasant-looking",		"pleasant-looking"		},
tables.c:                 ROM - specific tables:
tattoo.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
tattoo.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
tattoo.c:    if (ch->level < 53 || IS_NPC(ch))
tattoo.c:	objj = create_object(obj->pIndexData, 0);
tattoo.c:    if (ch->level < 53 || IS_NPC(ch))
tattoo.c:	if (IS_SET(obj->progtypes,IPROG_INVOKE))
tattoo.c:		(obj->pIndexData->iprogs->invoke_prog) (obj,ch,argument);
tattoo.c:	ch->hit /= 2;
tattoo.c:        ch->hit += (ch->level*2) * 10;
tattoo.c:        ch->hit = UMIN(ch->hit,ch->max_hit);
tattoo.c:	if (check_dispel(ch->level+3,ch,skill_lookup("blindness")))
tattoo.c:	if (check_dispel(ch->level+3,ch,skill_lookup("poison")))
tattoo.c:	if (check_dispel(ch->level+3,ch,skill_lookup("plague")))
tattoo.c:      af.level        = ch->level;
tattoo.c:        if(ch->position==POS_FIGHTING) {
thief.c:    if (ch->fighting != NULL || victim->fighting)
thief.c:    if (obj->value[0] != WEAPON_DAGGER)
thief.c:        if (obj == NULL || obj->value[0] != WEAPON_DAGGER)
thief.c:    if (victim->hit < victim->max_hit*8.5/10)
thief.c:		if (!IS_NPC(ch) && !IS_NPC(victim) && victim->fighting == NULL)
thief.c:		one_hit_new(ch, victim, gsn_backstab, HIT_NOSPECIALS, HIT_UNBLOCKABLE, HIT_NOADD, URANGE(100, (ch->level - 9) * 10, 375), NULL);
thief.c:		if (!IS_NPC(ch) && !IS_NPC(victim) && victim->fighting == NULL)
thief.c:	if (ch->level < skill_table[gsn_dual_backstab].skill_level[ch->Class()->GetIndex()])
thief.c:    if (number_percent() > (get_skill(ch,gsn_dual_backstab) + ch->level - victim->level) )
thief.c:		dam = dice(obj->value[1], obj->value[2]) * get_skill(ch,gsn_dual_backstab)/100;
thief.c:		if (ch->level < 35) 	dam *= number_range(2,4);
thief.c: 		else if (ch->level < 40) 	dam *= number_range(2,5);
thief.c:		else if (ch->level < 45)	dam *= number_range(3,5);
thief.c:		else if (ch->level < 50)	dam *= number_range(4,6);
thief.c:        dam += (ch->damroll * get_skill(ch,gsn_dual_backstab)/100);
thief.c:	victim = ch->fighting;
thief.c:    if (ch->fighting == NULL)
thief.c:    for (v_check = ch->in_room->people; v_check != NULL; v_check = v_next)
thief.c:	v_next = v_check->next_in_room;
thief.c:	if (v_check->fighting == ch)
thief.c:   if (obj == NULL || obj->value[0] != WEAPON_DAGGER)
thief.c:    if (obj->value[0] != 2)
thief.c:    chance += (ch->level - victim->level);
thief.c:	dam = dice(obj->value[1],obj->value[2]);
thief.c:	if (ch->level <= 15)
thief.c:	else if (ch->level <= 20)
thief.c:	else if (ch->level < 25)
thief.c:	else if (ch->level < 30)
thief.c:	else if (ch->level < 40)
thief.c:	else if (ch->level <= 49)
thief.c:	else if (ch->level <= 55)
thief.c:	damage_old(ch,victim,dam,gsn_circle, attack_table[obj->value[3]].damage, TRUE);
thief.c:		|| ( ch->level < skill_table[gsn_blackjack].skill_level[ch->Class()->GetIndex()]) )
thief.c:	size=victim->size-ch->size;
thief.c:	if (victim->position == POS_SLEEPING)
thief.c:	chance += (ch->level - victim->level);
thief.c:		chance -= 15*size;
thief.c:		chance -= 10;
thief.c:	if (victim->position == POS_FIGHTING)
thief.c:		chance -= 30;
thief.c:	af.level = ch->level;
thief.c:	if (ch->level == MAX_LEVEL)
thief.c:		victim->position = POS_SLEEPING;
thief.c:	if (victim->position != POS_SLEEPING)
thief.c:		chance-=30;
thief.c:		chance-=20;
thief.c:		af.level = ch->level;
thief.c:		af.duration = -1;
thief.c:		af.modifier = -5;
thief.c:		af.level = ch->level;
thief.c:		ch->level < skill_table[gsn_plant].skill_level[ch->Class()->GetIndex()])
thief.c:    if (victim->fighting != NULL)
thief.c:    percent += ((victim->level - ch->level)*2);
thief.c:    	percent -= get_curr_stat(ch,STAT_DEX);
thief.c:    if(IS_NPC(victim) && victim->pIndexData->pShop)
thief.c:    	REMOVE_BIT(ch->affected_by,AFF_SNEAK);
thief.c:        		sprintf(buf,"$N tried to plant %s on %s.",obj->name, victim->name);
thief.c:    if ( !can_drop_obj( ch, obj ) || IS_SET(obj->extra_flags, ITEM_INVENTORY))
thief.c:    if ( victim->carry_number + get_obj_number( obj ) > can_carry_n( victim ) )
thief.c:    if ( victim->carry_weight + get_obj_weight( obj ) > can_carry_w( victim ) )
thief.c:	if ((chance = get_skill(ch,gsn_gag)) == 0 || ( ch->level < skill_table[gsn_gag].skill_level[ch->Class()->GetIndex()]) )
thief.c:		paf = affect_find(ch->affected,gsn_gag);
thief.c:		if (paf && paf->aftype == AFT_SKILL)
thief.c:	af.level = ch->level;
thief.c:		af.duration = -1;
thief.c:	if(IS_NPC(victim) && IS_SET(victim->act,ACT_SENTINEL))
thief.c:	if(victim->size > (ch->size + 1))
thief.c:	if(ch->fighting)
thief.c:    if((where = direction_lookup(dir)) == -1)
thief.c:    if ((pexit = ch->in_room->exit[where]) == NULL)
thief.c:	if(IS_NPC(victim) && victim->pIndexData->barred_entry)
thief.c:        && (ch->fighting == NULL || victim->fighting == NULL))
thief.c:	skill -= (victim->size - ch->size) * 15;
thief.c:        to_room = pexit->u1.to_room;
thief.c:		if(victim->in_room != ch->in_room)
thief.c:	if(ch->in_room->sector_type != SECT_CITY && ch->in_room->sector_type != SECT_INSIDE && !IS_IMMORTAL(ch))
thief.c:	pexit = ch->in_room->exit[door];
thief.c:	to_room = pexit->u1.to_room;
thief.c:	if(is_affected_room(ch->in_room, gsn_tripwire) && is_affected_room(to_room, gsn_tripwire))
thief.c:		for (victim = ch->in_room->people; victim != NULL; victim = victim->next_in_room)
thief.c:		raf.level   =   ch->level;
thief.c:		new_affect_to_room(ch->in_room,&raf);
thief.c:			&& (pexit_opp = to_room->exit[reverse_d(door)]) != NULL
thief.c:			&& pexit_opp->u1.to_room == ch->in_room)
thief.c:		af.level 	= ch->level;
thief.c:		af.duration	= ch->level / 2;
thief.c:	for (victim = ch->in_room->people; victim != NULL; victim = victim->next_in_room)
thief.c:	if (victim->fighting != NULL)
thief.c:        if (obj->item_type != ITEM_CONTAINER )
thief.c:        if (material_table[obj->pIndexData->material_index].mat_hardness > 2)
thief.c:		percent -= get_curr_stat(ch,STAT_DEX)*2;
thief.c:		chance -= 75;
thief.c:		REMOVE_BIT(ch->affected_by,AFF_SNEAK);
thief.c:	if (obj->item_type != ITEM_CONTAINER )
thief.c:	if (material_table[obj->pIndexData->material_index].mat_hardness > 2)
thief.c:	for (iobj = obj->contains; iobj != NULL; iobj = iobj_next)
thief.c:		iobj_next = iobj->next_content;
thief.c:		obj_to_room(iobj,ch->in_room);
thief.c:	if(ch->in_room->sector_type != SECT_CITY && ch->in_room->sector_type != SECT_INSIDE && !IS_IMMORTAL(ch))
thief.c:		oaf.level	=	ch->level;
thief.c:		oaf.duration=	-1;
thief.c:	obj_to_room( obj, ch->in_room );
thief.c:	if (corpse->item_type == ITEM_CORPSE_PC)
thief.c:	if (corpse->item_type != ITEM_CORPSE_NPC)
thief.c:	mob = create_mobile(get_mob_index(corpse->mob_vnum));
thief.c:	if(ch->race != mob->race)
thief.c:   	oaf.level   =   ch->level;
thief.c:   	oaf.duration=   -1;
thief.c:		ch->pcdata->old = new_oldchar();
thief.c:		ch->pcdata->old->name = palloc_string(ch->true_name);
thief.c:		ch->pcdata->old->short_descr = palloc_string(ch->short_descr);
thief.c:		ch->pcdata->old->long_descr = palloc_string(ch->long_descr);
thief.c:		ch->pcdata->old->description = palloc_string(ch->description);
thief.c:		free_pstring(ch->name);
thief.c:		ch->name = palloc_string(mob->short_descr);
thief.c:		free_pstring(ch->short_descr);
thief.c:		ch->short_descr = palloc_string("disguised");
thief.c:		free_pstring(ch->long_descr);
thief.c:		ch->long_descr = palloc_string(mob->long_descr);
thief.c:		free_pstring(ch->description);
thief.c:		ch->description = palloc_string(mob->description);
thief.c:		af.level    = ch->level;
thief.c:		af.duration = ch->level;
thief.c:		af.modifier = corpse->mob_vnum;
thief.c:	if (ch->fighting && number_percent() < 25) {
thief.c:		act("$n's garb falls to tatters around $m...  revealing $t beneath the disguise!",ch,ch->pcdata->old->name,0,TO_ROOM);
thief.c:	if (af->modifier < ch->in_room->area->min_vnum
thief.c:		|| af->modifier > ch->in_room->area->max_vnum) {
thief.c:	free_pstring(ch->name);
thief.c:	ch->name = palloc_string(ch->pcdata->old->name);
thief.c:	free_pstring(ch->short_descr);
thief.c:	ch->short_descr = palloc_string(ch->pcdata->old->short_descr);
thief.c:	free_pstring(ch->long_descr);
thief.c:	ch->long_descr = palloc_string(ch->pcdata->old->long_descr);
thief.c:	free_pstring(ch->description);
thief.c:	ch->description = palloc_string(ch->pcdata->old->description);
thief.c:	free_oldchar(ch->pcdata->old);
thief.c:	ch->pcdata->old = NULL;
thief.c:	act("$n suddenly slips out of $s garb...  revealing $t beneath the disguise!", ch, ch->pcdata->old->name, 0, TO_ROOM);
thief.c:	for(obj = ch->in_room->contents; obj != NULL; obj = obj->next_content)
thief.c:			for (oaf = obj->affected; oaf != NULL; oaf = oaf->next) {
thief.c:				if(oaf->type == gsn_stash)
thief.c:				chance += (ch->level - oaf->level);
thief.c:				if(ch->Class()->GetIndex() == CLASS_THIEF)
thief.c:					chance += (ch->level/2);
thief.c:				if(oaf->owner != ch && (number_percent() < chance)) {
thief.c:	if (orig->item_type != copy->item_type)
thief.c:	if (str_cmp(orig->material, copy->material))
thief.c:		free_pstring(copy->short_descr);
thief.c:		copy->short_descr = palloc_string(orig->short_descr);
thief.c:		free_pstring(copy->name);
thief.c:		copy->name = palloc_string(orig->name);
thief.c:		free_pstring(copy->description);
thief.c:		copy->description = palloc_string(orig->description);
thief.c:		free_pstring(copy->short_descr);
thief.c:		sprintf(hold,"a shoddy imitation of %s", orig->short_descr);
thief.c:		copy->short_descr = palloc_string(hold);
thief.c:        free_pstring(copy->name);
thief.c:        copy->name = palloc_string(orig->name);
thief.c:        free_pstring(copy->description);
thief.c:        copy->description = palloc_string(orig->description);
thief.c:    oaf.level   =   ch->level;
thief.c:    oaf.duration=   ch->level;
thief.c:	if(obj->carried_by)
thief.c:		act("You suddenly realize that $p is counterfeit, and really $T!",obj->carried_by,obj,obj->pIndexData->short_descr,TO_CHAR);
thief.c:	if (obj->in_room && obj->in_room->people)
thief.c:		act("You suddenly realize that $p is counterfeit, and really $T!",obj->carried_by,obj,obj->pIndexData->short_descr,TO_ALL);
thief.c:	free_pstring(obj->short_descr);
thief.c:	obj->short_descr = palloc_string(obj->pIndexData->short_descr);
thief.c:	free_pstring(obj->name);
thief.c:	obj->name = palloc_string(obj->pIndexData->name);
thief.c:	free_pstring(obj->description);
thief.c:	obj->description = palloc_string(obj->pIndexData->description);
thief.c:	if((ch->mana - cost) < 0)
thief.c:		af.level    = ch->level;
thief.c:		af.duration = ch->level / 2;
thief.c:	if (mob->last_fought == ch)
thief.c:	if (IS_SET(mob->act,ACT_DETECT_SPECIAL))
thief.c:	skill += (get_curr_stat(ch,STAT_DEX) - 20) * 3;
thief.c:	for(obj = victim->carrying; obj; obj = obj->next_content)
thief.c:		if(obj->wear_loc != WEAR_NONE && is_name(arg1,obj->name))
thief.c:	if (obj->wear_loc == WEAR_BODY ||
thief.c:		obj->wear_loc == WEAR_ARMS ||
thief.c:		obj->wear_loc == WEAR_LEGS ||
thief.c:		obj->wear_loc == WEAR_WAIST ||
thief.c:		obj->wear_loc == WEAR_ABOUT ||
thief.c:		obj->wear_loc == WEAR_BRAND){
thief.c:    chance += 6 * (get_curr_stat(ch,STAT_DEX) - 20);
thief.c:        chance -= 5 * (victim->level - ch->level);
thief.c:        chance -= 2 * (victim->level - ch->level);
thief.c:        chance -= 25;
thief.c:        chance -= 10;
thief.c:        chance -= 2 * (get_curr_stat(victim,STAT_DEX) - 15);
thief.c:    if(IS_NPC(victim) && victim->pIndexData->pShop)
thief.c:	if ( (IS_AWAKE(victim) && (obj->wear_loc == WEAR_FINGER_L || obj->wear_loc == WEAR_FINGER_R)) || (!IS_AWAKE(victim)) )
thief.c:		if(number_percent() < (chance - 30))
thief.c:		victim->position = POS_STANDING;
thief.c:	for (af = ch->affected; af != NULL; af = af->next)
thief.c:		if (af->type == gsn_bind && !str_infix(type,af->name))
thief.c:	if (IS_NPC(victim) && !IS_SET(victim->form,FORM_BIPED))
thief.c:	if (victim->position != POS_SLEEPING)
thief.c:		if (victim->arms > 0)
thief.c:		if (victim->legs > 0)
thief.c:		af.level = ch->level;
thief.c:		af.duration = -1;
thief.c:			af.modifier = -(ch->level/5);
thief.c:			af.modifier = -(ch->level/8);
thief.c:			af.modifier = -(ch->level/5);
thief.c:	|| ch->level < skill_table[gsn_knife].skill_level[ch->Class()->GetIndex()])
thief.c:	if (ch->fighting != NULL)
thief.c:			af.duration = ch->level / 8;
thief.c:			af.level = ch->level;
thief.c:	for (vch = ch->in_room->people; vch; vch = vch->next_in_room)
thief.c:	if(ch->hit == ch->max_hit)
thief.c:		af.duration = ch->level / 8;
thief.c:		af.level = ch->level;
thief.c:			af.modifier = -1;
thief.c:		af.duration = ch->level / 5;
thief.c:		af.level = ch->level;
thief.c:			af.modifier = ch->pcdata->ethos == ETHOS_NEUTRAL ? 1000 : ch->pcdata->ethos < ETHOS_NEUTRAL ? 2000 : 0;
thief.c:			af.modifier = ch->pcdata->ethos == ETHOS_NEUTRAL ? 0 : ch->pcdata->ethos < ETHOS_NEUTRAL ? 1000 : -1000;
thief.c:			af.modifier = ch->pcdata->ethos == ETHOS_NEUTRAL ? -1000 : ch->pcdata->ethos < ETHOS_NEUTRAL ? 0 : -2000;
thief.c:			alignval = ch->alignment == ALIGN_NEUTRAL ? 1000 : ch->alignment < ALIGN_NEUTRAL ? 2000 : 0;
thief.c:			alignval = ch->alignment == ALIGN_NEUTRAL ? 0 : ch->alignment < ALIGN_NEUTRAL ? 1000 : -1000;
thief.c:			alignval = ch->alignment == ALIGN_NEUTRAL ? -1000 : ch->alignment < ALIGN_NEUTRAL ? 0 : -2000;
titles.c:	{ "Pick-Pocket",		"Pick-Pocket"			},
titles.c:	{ "Cut-Purse",			"Cut-Purse"			},
titles.c:	{ "Quick-Blade",		"Quick-Blade"			},
titles.c:	{ "Cut-Throat",			"Cut-Throat"			},
titles.c:        { "Priest-Knight", "Priestess-Knight" },
titles.c:        { "Healer-Knight", "Healer-Lady" },
titles.c:        { "Anti-Paladin", "Anti-Paladin" },
titles.c:        { "Arch-Fiend", "Arch-Fiend" },
titles.c:        { "Anti-Hero",                  "Anti-Heroine"                  },
titles.c:        { "Anti-Hero of Death",              "Anti-Heroine of Death"      },
update.c:*	ROM 2.4 is copyright 1993-1996 Russ Taylor			   *
update.c:*       Tartarus code is copyright (C) 1997-1998 by Daniel Graham          *
update.c:    ch->pcdata->last_level =
update.c:	( ch->played + (int) (current_time - ch->logon) ) / 3600;
update.c:	title_table [ch->Class()->GetIndex()] [ch->level] [ch->sex == SEX_FEMALE ? 1 : 0] );
update.c:    int_mod = get_curr_stat(ch,STAT_INT) - 2;	
update.c:	wis_mod = get_curr_stat(ch,STAT_WIS) - 2;
update.c:	tmp			= -1.3333 + .5333 * get_curr_stat(ch, STAT_CON) + 1.3333 * ch->Class()->gainconst + number_range(-1,2);
update.c:		add_hp += get_curr_stat(ch,STAT_CON) - 23;
update.c:	tmp			= 8.0278 + 0.5667 * get_curr_stat(ch, STAT_INT) - 2.0833 * ch->Class()->gainconst + number_range(-1,2);
update.c:	if(ch->Class()->GetIndex() == CLASS_WARRIOR)
update.c:	if(ch->Class()->GetIndex() == CLASS_NECROMANCER)
update.c:		add_mana -= number_range(2,5);
update.c:	if(ch->Class()->GetIndex() == CLASS_SORCERER)
update.c:		add_mana -= number_range(1,2);
update.c:    ch->max_hit 	+= add_hp;
update.c:    ch->max_mana	+= add_mana;
update.c:    ch->max_move	+= add_move;
update.c:    ch->practice	+= add_prac;
update.c:    if(ch->level % 5 == 0)
update.c:         ch->train		+= 1;
update.c:    if(ch->Class()->GetIndex() == CLASS_WARRIOR && ch->level % 20 == 0)
update.c:		ch->pcdata->special++;
update.c:    ch->pcdata->perm_hit	+= add_hp;
update.c:    ch->pcdata->perm_mana	+= add_mana;
update.c:    ch->pcdata->perm_move	+= add_move;
update.c:		if (ch->pcdata->learned[sn] > 10 && skill_table[sn].ctype != CMD_POWER){
update.c:			ch->pcdata->learned[sn]++;
update.c:			ch->pcdata->learned[sn] = UMIN(ch->pcdata->learned[sn],100);
update.c:		if (ch->pcdata->recentkills[i] && ch->pcdata->recentkills[i][0] != '\0' && strcmp(ch->pcdata->recentkills[i],""))
update.c:			free_pstring(ch->pcdata->recentkills[i]);
update.c:			ch->pcdata->recentkills[i] = NULL;
update.c:		add_hp,ch->max_hit, add_mana, ch->max_mana,
update.c:		add_move, ch->max_move, add_prac,ch->practice,
update.c:    if (ch->level < LEVEL_HERO)
update.c:	ch->exp += gain;
update.c:    while ( ch->level < LEVEL_HERO && ch->exp >=
update.c:        exp_per_level(ch) * (ch->level) )
update.c:	ch->level += 1;
update.c:	sprintf(buf,"%s gained level %d",ch->name,ch->level);
update.c:	sprintf(buf,"$N has attained level %d!",ch->level);
update.c:	//ch->hit = ch->max_hit;
update.c:	//ch->mana = ch->max_mana;
update.c:	//ch->move = ch->max_move;
update.c:    if (ch->in_room == NULL)
update.c:    if (ch->in_room->vnum == ROOM_VNUM_NIGHTWALK || ch->in_room->vnum == 2901)
update.c:	if (ch->pcdata->condition[COND_STARVING] > 6)
update.c:	if (ch->pcdata->condition[COND_DEHYDRATED] > 4)
update.c:		gain =  5 + ch->level;
update.c:		if(is_affected_area(ch->in_room->area,gsn_infidels_fate))
update.c:		switch(ch->position)
update.c:		gain = UMAX(3,(get_curr_stat(ch,STAT_CON) - 3)/2 + ch->level/4);
update.c:		gain += (ch->Class()->gainconst + 3) * 3;
update.c:	    	if (ch->hit < ch->max_hit)
update.c:		switch ( ch->position )
update.c:    if (ch->on != NULL && ch->on->item_type == ITEM_FURNITURE)
update.c:		if (number_percent() < ch->pcdata->learned[gsn_camp])
update.c:	if (!IS_NPC(ch) && IS_SET(ch->act,PLR_MORON))
update.c:    return UMIN(gain, ch->max_hit - ch->hit);
update.c:    if (ch->in_room == NULL)
update.c:	if (ch->pcdata->condition[COND_STARVING] > 6)
update.c:	if (ch->pcdata->condition[COND_DEHYDRATED] > 4)
update.c:	gain = 5 + ch->level/2;
update.c:	switch (ch->position)
update.c:	gain = (get_curr_stat(ch,STAT_WIS)/4 - 4
update.c:	      + get_curr_stat(ch,STAT_INT) + ch->level/2);
update.c:	    if (ch->mana < ch->max_mana)
update.c:	    if (ch->mana < ch->max_mana)
update.c:	switch ( ch->position )
update.c:    if (ch->on != NULL && ch->on->item_type == ITEM_FURNITURE)
update.c:	if (number_percent() < ch->pcdata->learned[gsn_camp])
update.c:    return UMIN(gain, ch->max_mana - ch->mana);
update.c:    if (ch->in_room == NULL)
update.c:	if (ch->pcdata->condition[COND_STARVING] > 6)
update.c:	if (ch->pcdata->condition[COND_DEHYDRATED] > 4)
update.c:	gain = ch->level;
update.c:	gain = UMAX( 15, ch->level/2 );
update.c:	switch ( ch->position )
update.c:    gain *= ch->in_room->heal_rate/100;
update.c:    if (ch->on != NULL && ch->on->item_type == ITEM_FURNITURE)
update.c:	if (number_percent() < ch->pcdata->learned[gsn_camp])
update.c:    return UMIN(gain, ch->max_move - ch->move);
update.c:from function before the if (ch->level > 10) check...(Ceran)
update.c:    if (!ch->desc)
update.c:    condition				= ch->pcdata->condition[iCond];
update.c:    if (condition == -1)
update.c:    ch->pcdata->condition[iCond]	= UMAX(0, condition + value);
update.c:    if (ch->level > 10)
update.c:    if (ch->pcdata->condition[iCond] == 0 && iCond == COND_HUNGER)
update.c:		ch->pcdata->condition[COND_HUNGER]++;
update.c:    if (ch->pcdata->condition[iCond] == 0 && iCond == COND_THIRST
update.c:		ch->pcdata->condition[COND_THIRST]++;
update.c:	else if (ch->pcdata->condition[iCond] == 0 && iCond == COND_THIRST && is_affected(ch,gsn_accumulate_heat))
update.c:		ch->pcdata->condition[COND_THIRST]++;
update.c:		ch->pcdata->condition[COND_DRUNK]--;
update.c:		ch->pcdata->condition[COND_THIRST] = 0;
update.c:		ch->pcdata->condition[COND_HUNGER] = 0;
update.c:	ch->pcdata->condition[COND_THIRST] = UMIN(ch->pcdata->condition[COND_THIRST],75);
update.c:	ch->pcdata->condition[COND_HUNGER] = UMIN(ch->pcdata->condition[COND_HUNGER],75);
update.c:		ch->pcdata->condition[COND_HUNGER] = 0;
update.c:		ch->pcdata->condition[COND_THIRST] = 0;
update.c:	    if (ch->pcdata->condition[COND_HUNGER] > COND_HUNGRY)
update.c:	    if (ch->pcdata->condition[COND_THIRST] > COND_HUNGRY)
update.c:	    if (ch->pcdata->condition[COND_DRUNK] == 10)
update.c:    if (ch->pcdata->condition[COND_HUNGER] > COND_HUNGRY + 5 && iCond == COND_HUNGER)
update.c:		counter = ch->pcdata->condition[COND_HUNGER] - COND_HUNGRY;
update.c:		if (ch->level > 10)
update.c:    if (ch->pcdata->condition[COND_THIRST] > COND_HUNGRY + 5 && iCond == COND_THIRST)
update.c:		counter = ch->pcdata->condition[COND_THIRST] - COND_HUNGRY;
update.c:		if (ch->level > 10)
update.c: * -- Furey
update.c:	ch_next = ch->next;
update.c:	if ( !IS_NPC(ch) || ch->in_room == NULL)
update.c:	if (ch->in_room->area->empty && !IS_SET(ch->act,ACT_UPDATE_ALWAYS) && !IS_SET(ch->act,ACT_WARD_MOB))
update.c:	if(ch->position==POS_FIGHTING && ch->pIndexData->cast_spell[0]!=NULL && number_percent()>50)
update.c:	if ( IS_SET(ch->progtypes,MPROG_PULSE) &&
update.c:		(ch->in_room->area->nplayer > 0
update.c:		|| IS_SET(ch->act,ACT_UPDATE_ALWAYS)
update.c:		|| IS_SET(ch->act,ACT_WARD_MOB)))
update.c:          (ch->pIndexData->mprogs->pulse_prog) (ch);
update.c:        if ( ch->position != POS_STANDING )
update.c:	if ( IS_SET(ch->act, ACT_SCAVENGER)
update.c:	&&   ch->in_room->contents != NULL
update.c:	    for ( obj = ch->in_room->contents; obj; obj = obj->next_content )
update.c:		     && obj->cost > max  && obj->cost > 0)
update.c:		    max         = obj->cost;
update.c:	if(IS_SET(ch->act, ACT_WANDER)
update.c:	&& !ch->pIndexData->pShop
update.c:/*		if(IS_SET(ch->act, ACT_FASTWANDER) && 
update.c:				(ch->in_room->exit[0]  
update.c:				|| ch->in_room->exit[1] 
update.c:				|| ch->in_room->exit[2]
update.c:				|| ch->in_room->exit[3]
update.c:				|| ch->in_room->exit[4]
update.c:				|| ch->in_room->exit[5]))
update.c:			while((pexit = ch->in_room->exit[door]) == NULL || pexit->u1.to_room == NULL)
update.c:		if((pexit = ch->in_room->exit[door]) != NULL
update.c:		&& pexit->u1.to_room != NULL
update.c:		&& !IS_SET(pexit->exit_info, EX_CLOSED)
update.c:		&& !IS_SET(pexit->u1.to_room->room_flags, ROOM_NO_MOB)
update.c:    	&& !( pexit->u1.to_room->vnum < ch->pIndexData->restrict_low
update.c:    	||    pexit->u1.to_room->vnum > ch->pIndexData->restrict_high)
update.c:    	&& ( !IS_SET(ch->act, ACT_STAY_AREA)
update.c:    	||   pexit->u1.to_room->area == ch->in_room->area )
update.c:    	&& !( IS_SET(ch->act, ACT_OUTDOORS)
update.c:    	&&    IS_SET(pexit->u1.to_room->room_flags,ROOM_INDOORS))
update.c:    	&& !( IS_SET(ch->act, ACT_INDOORS)
update.c:		&&   !IS_SET(pexit->u1.to_room->room_flags,ROOM_INDOORS))
update.c:		&& !( pexit->u1.to_room->sector_type == SECT_UNDERWATER 
update.c:		&& !(IS_SET(ch->form, FORM_AQUATIC) 
update.c:		|| IS_SET(ch->form,FORM_AMPHIBIAN)))
update.c:    	&& !( pexit->u1.to_room->sector_type == SECT_WATER 
update.c:		&& !IS_SET(ch->form, FORM_AQUATIC) 
update.c:		&& !IS_SET(ch->form, FORM_FISH) 
update.c:		for (d = descriptor_list;d != NULL; d = d->next) {
update.c:			if (d->connected == CON_PLAYING &&
update.c:				d->character->in_room &&
update.c:				d->character->in_room->sector_type != SECT_UNDERWATER &&
update.c:				IS_OUTSIDE(d->character) &&
update.c:				IS_AWAKE(d->character)  &&
update.c:				!is_editing(d->character) &&
update.c:				!(is_affected_area(d->character->in_room->area,gsn_whiteout)) &&
update.c:				!(is_affected_area(d->character->in_room->area,gsn_cyclone)) &&
update.c:				!(IS_AFFECTED(d->character,AFF_BLIND))) {
update.c:				colorconv(colbuf, buf, d->character);
update.c:				send_to_char(colbuf,d->character);
update.c:				send_to_char("\n\r",d->character);
update.c:		for(area = area_first; area != NULL; area = area->next) {
update.c:			if(IS_SET(area->progtypes, APROG_SUN))
update.c:				(area->aprogs->sun_prog) (area);
update.c:	for (mob = char_list; mob; mob = mob->next) 
update.c:		if (!IS_NPC(mob) || mob->stolen_from)
update.c:		mob_gold = UMAX(total_gold - player_gold, 100000);
update.c:		gold = mob->pIndexData->wealth * (mob_gold / total_wealth);
update.c:		mob->gold = gold;
update.c: * Update the weather -- Eladrian's l33t regional weather system
update.c:	for(area = area_first; area; area = area->next) {
update.c:			if (random <= climate_table[area->climate].skyfreqs[season][i]) {
update.c:				area->sky = i;
update.c:			if (random <= climate_table[area->climate].tempfreqs[season][i]) {
update.c:				area->temp = i;
update.c:		area->wind = number_range(0,2);
update.c:	for (area = area_first; area; area = area->next) {
update.c:			if (!area->adjacent[i])
update.c:			skytot += area->adjacent[i]->sky;
update.c:			temptot += area->adjacent[i]->temp;
update.c:			if (abs(average - area->sky) >= 4)
update.c:				area->sky = (area->sky + average) / 2;
update.c:			if (abs(average - area->temp) >= 2)
update.c:				area->temp = (area->sky + average) / 2;
update.c:		if (area->sky >= SKY_FLURRY && area->temp < TEMP_COOL)
update.c:			area->temp = TEMP_COOL;
update.c:		if (area->sky == SKY_DOWNPOUR || area->sky == SKY_TSTORM ||
update.c:			area->sky == SKY_BLIZZARD) {
update.c:			area->wind++;
update.c:		if (area->climate == CLIMATE_NONE) {
update.c:			area->sky = SKY_PCLOUDY;
update.c:			area->temp = TEMP_WARM;
update.c:			area->wind = WIND_CALM;
update.c:	for (area = area_first; area; area = area->next) {
update.c:		switch(area->sky) {
update.c:				sprintf(buf,"Pebble-sized hailstones begin to fall from the skies.");
update.c:	ch_next = ch->next;
update.c:		ch->in_room &&
update.c:		ch->fighting == NULL)
update.c:		if(IS_SET(ch->act, ACT_DIURNAL))
update.c:				REMOVE_BIT(ch->affected_by, AFF_NOSHOW);
update.c:		else if(IS_SET(ch->act, ACT_NOCTURNAL))
update.c:				SET_BIT(ch->affected_by, AFF_NOSHOW);
update.c:			 ch->in_room &&
update.c:			 ch->fighting == NULL)
update.c:		if(IS_SET(ch->act, ACT_NOCTURNAL))
update.c:				REMOVE_BIT(ch->affected_by, AFF_NOSHOW);
update.c:		else if(IS_SET(ch->act, ACT_DIURNAL))
update.c:				SET_BIT(ch->affected_by, AFF_NOSHOW);
update.c:	if ( ch->pause > 0 )
update.c:	    ch->pause--;
update.c:	if (IS_NPC(ch) && ch->hit < 0 && ch->in_room)
update.c:		sprintf(buf,"%s in %d has HP %d", ch->name, ch->in_room->vnum, ch->hit);
update.c:	if ( ch->ghost > 0 )
update.c:		ch->ghost--;
update.c:		switch(ch->ghost)
update.c:	if (ch->bounty_timer > 0)
update.c:		ch->bounty_timer--;
update.c:	if (ch->ghost > 0)
update.c:	if (!IS_NPC(ch) && ch->level < 20 && (ch->in_room->vnum > 24599 || ch->in_room->vnum < 24500))
update.c:		while(ch->level < 20)
update.c:			ch->level++;
update.c:        	ch->exp = exp_per_level(ch) * (ch->level - 1);
update.c:		if(ch->pet)
update.c:			sprintf(buf1,"Remember, you can ask your familiar questions.  For example, 'say %s, how do I get to my guild?'.\n\r",ch->pet->short_descr);
update.c:	if ( ch->position >= POS_STUNNED )
update.c:	    if ( ch->hit  < ch->max_hit ) /* Some regen stuff */
update.c:			ch->hit  += hgain;
update.c:			ch->hit = ch->max_hit;
update.c:	    if ( ch->mana < ch->max_mana )
update.c:			ch->mana += mana_gain(ch);
update.c:			ch->mana = ch->max_mana;
update.c:	    if ( ch->move < ch->max_move )
update.c:			ch->move += (is_affected(ch, gsn_repose)) ? (move_gain(ch)*2) : (move_gain(ch));
update.c:			ch->move = ch->max_move;
update.c:	if ( ch->position == POS_STUNNED )
update.c:	if (ch->position < POS_STUNNED)
update.c:	ch->talismanic = UMAX(0, ch->talismanic - 0.0625);
update.c:	if(!IS_NPC(ch) && ch->in_room)
update.c:		ch->pcdata->sect_time[0]++;
update.c:		ch->pcdata->sect_time[ch->in_room->sector_type]++;
update.c:	if(!IS_NPC(ch) && ch->pcdata->save_timer)
update.c:		ch->pcdata->save_timer--;
update.c:	    &&   obj->item_type == ITEM_LIGHT
update.c:	    &&   obj->value[2] > 0 )
update.c:		if ( --obj->value[2] == 0 && ch->in_room != NULL )
update.c:			ch->in_room->light = UMAX(0,ch->in_room->light - 3);
update.c:	 	else if ( obj->value[2] <= 5 && ch->in_room != NULL)
update.c:		ch->timer++;
update.c:	    if ( (ch->timer >= 25 && !IS_HEROIMM(ch) && !IS_IMMORTAL(ch)))
update.c:		if ( ch->was_in_room == NULL && ch->in_room != NULL )
update.c:		    ch->was_in_room = ch->in_room;
update.c:		    if ( ch->fighting != NULL )
update.c:		    if (ch->level > 1)
update.c:		    ch->pause = 0;
update.c:	    gain_condition( ch, COND_DRUNK,  -1 );
update.c:	if ( !IS_NPC(ch) && ch->desc == NULL ) {
update.c:		for ( paf = ch->affected; paf != NULL; paf = paf_next ) {
update.c:		    paf_next	= paf->next;
update.c:			if (!ghost && ch->ghost > 0)
update.c:	    	if ( paf->duration > 0 )
update.c:				if (paf->tick_fun)
update.c:					(*paf->tick_fun) (ch, paf);
update.c:				if (!ghost && ch->ghost > 0)
update.c:				paf->duration--;
update.c:				if (number_range(0,4) == 0 && paf->level > 0)
update.c:		 			paf->level--;  /* spell strength fades with time */
update.c:			else if ( paf->duration < 0 ) 
update.c:				if (paf->tick_fun)
update.c:					(*paf->tick_fun) (ch,paf);
update.c:			else if ((paf->type == gsn_entwine) && (paf->owner == NULL
update.c:				|| (paf->owner && ch->in_room != paf->owner->in_room)))
update.c:				if(((paf->owner && paf->owner->Class()->GetIndex() == CLASS_PALADIN) || (!paf->owner && ch->Class()->GetIndex() == CLASS_PALADIN) && trusts(ch, paf->owner ? paf->owner : ch)) && paf->aftype == AFT_COMMUNE)
update.c:					if(number_percent() < (get_skill(paf->owner ? paf->owner : ch,gsn_channeling)*.85) 
update.c:							&& !(skill_table[paf->type].dispel & CAN_CLEANSE))
update.c:						check_improve(paf->owner ? paf->owner : ch, gsn_channeling, TRUE, 1);
update.c:						if(!paf->owner || ch == paf->owner)
update.c:									ch, skill_table[paf->type].name, 0, TO_CHAR);
update.c:									ch, skill_table[paf->type].name, paf->owner, TO_CHAR);
update.c:						paf->duration = paf->init_duration;
update.c:						ch->mana = UMAX(ch->mana - skill_table[paf->type].min_mana, 0);
update.c:					||   paf_next->type != paf->type
update.c:					||   paf_next->duration > 0 ) 
update.c:		    		if ( paf->type > 0 && str_cmp(skill_table[paf->type].msg_off,"") ) 
update.c:						send_to_char( skill_table[paf->type].msg_off, ch );
update.c:					if (paf->type && str_cmp(skill_table[paf->type].room_msg_off,"")
update.c:						act(skill_table[paf->type].room_msg_off,ch,0,0,TO_ROOM);
update.c:	if (!ghost && ch->ghost > 0)
update.c:	if(!IS_NPC(ch) && ch->in_room && ch->in_room->sector_type == SECT_BURNING)
update.c:		damage_new(ch,ch,dice(ch->level/2,2),gsn_bleeding,DAM_FIRE,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the searing heat*");
update.c:        ch_next = ch->next;
update.c:		if (ch->desc != NULL && ch->desc->descriptor % 3 == save_number)
update.c:		obj_next = obj->next;
update.c:		if(obj->moved)
update.c:			obj->moved	= FALSE;
update.c:			&& (obj->carried_by
update.c:			&& (obj->carried_by->in_room->sector_type == SECT_WATER
update.c:			|| obj->carried_by->in_room->sector_type == SECT_UNDERWATER)))
update.c:			|| (obj->in_room && (obj->in_room->sector_type == SECT_WATER
update.c:			|| obj->in_room->sector_type == SECT_UNDERWATER)))
update.c:			act("The water extinguishes $p.",obj->carried_by,obj,0,TO_CHAR);
update.c:        for ( paf = obj->affected; paf != NULL; paf = paf_next )
update.c:        	paf_next    = paf->next;
update.c:			if (paf->duration != 0)
update.c:				if (paf->tick_fun)
update.c:					(*paf->tick_fun) (obj,paf);
update.c:            if ( paf->duration > 0 )
update.c:                paf->duration--;
update.c:                if (number_range(0,4) == 0 && paf->level > 0)
update.c:                  paf->level--;  /* spell strength fades with time */
update.c:            else if ( paf->duration < 0 )
update.c:		if ( obj->timer <= 0 || --obj->timer > 0 )
update.c:		switch ( obj->item_type )
update.c:					if (obj->contains)
update.c:		if (obj && obj->pIndexData->vnum == OBJ_EXPLOSIVES && obj->carried_by)
update.c:			bag_explode(obj->carried_by,obj,1);
update.c:		if(isCabalItem(obj) && IS_NPC(obj->carried_by))
update.c:			obj->timer=0;
update.c:			cguard=get_cabal_guardian(obj->pIndexData->cabal);
update.c:				obj->timer=15;
update.c:			act( message, obj->carried_by, obj, NULL, TO_CHAR );
update.c:			obj->timer=0;
update.c:		if ( obj->carried_by != NULL )
update.c:	    	if (IS_NPC(obj->carried_by) && obj->carried_by->pIndexData->pShop != NULL)
update.c:				obj->carried_by->gold++;
update.c:	    		act( message, obj->carried_by, obj, NULL, TO_CHAR );
update.c:				if ( obj->wear_loc == WEAR_FLOAT)
update.c:		    		act(message,obj->carried_by,obj,NULL,TO_ROOM);
update.c:		else if ( obj->in_room != NULL && ( rch = obj->in_room->people ) != NULL )
update.c:	    	if (! (obj->in_obj && obj->in_obj->pIndexData->vnum == OBJ_VNUM_PIT
update.c:	           	&& !CAN_WEAR(obj->in_obj,ITEM_TAKE)))
update.c:		if (obj->item_type == ITEM_CORPSE_PC && obj->contains)
update.c:	    	if(obj->in_room != NULL && IS_EXPLORE(obj->in_room))
update.c:				for(owner=char_list;owner!=NULL;owner=owner->next)
update.c:					if(!IS_NPC(owner) && !str_cmp(owner->true_name,obj->owner))
update.c:						if(obj->contains)
update.c:            				for (t_obj = obj->contains; t_obj != NULL; t_obj = next_obj)
update.c:               					next_obj = t_obj->next_content;
update.c:								if(t_obj->item_type==ITEM_MONEY)
update.c:				        			owner->gold += t_obj->value[1];
update.c:			if (obj->value[4])
update.c:				pit_obj = get_obj_type(get_obj_index(hometown_table[obj->value[4]].pit));
update.c:	    	for (t_obj = obj->contains; t_obj != NULL; t_obj = next_obj)
update.c:				next_obj = t_obj->next_content;
update.c:/* I have made tracking super-l33t.  (Eladrian) */
update.c:		tch_next = tch->next;
update.c:		if (!IS_SET(tch->act,ACT_FAST_TRACK) && number_range(1,15) != 1)
update.c:		if (!tch->last_fought) {
update.c:			if (tch->position > POS_RESTING
update.c:				&& !tch->fighting
update.c:				&& tch->home_room
update.c:				&& tch->in_room != tch->home_room
update.c:				&& (tch->in_room->vnum < tch->pIndexData->restrict_low
update.c:				|| tch->in_room->vnum > tch->pIndexData->restrict_high))
update.c:				walk_to_room(tch,tch->home_room);
update.c:		if (tch->fighting)
update.c:		if (IS_SET(tch->act,ACT_SMARTTRACK))
update.c:			smart_track(tch->last_fought,tch);
update.c:			track_char(tch->last_fought,tch);
update.c:		if (tch->in_room == tch->last_fought->in_room)
update.c:			if (can_see(tch,tch->last_fought))
update.c:				if(tch->pIndexData->attack_yell)
update.c:					sprintf(buf,"%s", act_msg(tch->pIndexData->attack_yell, tch->last_fought));
update.c:					sprintf(buf,"%s, now you die!", tch->last_fought->name);
update.c:				multi_hit(tch,tch->last_fought,TYPE_UNDEFINED);
update.c:		if (!tch->fighting)
update.c:			tch->tracktimer--;
update.c:		if (tch->tracktimer == 0)
update.c:			tch->last_fought = NULL;
update.c: * -- Furey
update.c:		wch_next = wch->next;
update.c:		if(!wch->name)
update.c:		if(!wch->in_room)
update.c:		if (IS_NPC(wch) && IS_SET(wch->progtypes,MPROG_BEAT))
update.c:			(wch->pIndexData->mprogs->beat_prog) (wch);
update.c:		for (paf = wch->affected; paf; paf = paf->next)
update.c:			if (paf->beat_fun)
update.c:				(*paf->beat_fun)(wch,paf);
update.c:		if((!IS_NPC(wch) && wch->pulseTimer <= pc_race_table[wch->race].racePulse)
update.c:			|| (IS_NPC(wch) && wch->pulseTimer <= 12))
update.c:			wch->pulseTimer++;
update.c:		timer = wch->pulseTimer;
update.c:			timer--;
update.c:		if (wch->fighting && 
update.c:			((!IS_NPC(wch) && timer >= pc_race_table[wch->race].racePulse)
update.c:			update_pc_last_fight(wch,wch->fighting);
update.c:			if ( IS_AWAKE(wch) && wch->in_room == wch->fighting->in_room )
update.c:				multi_hit( wch, wch->fighting, TYPE_UNDEFINED );
update.c:			wch->pulseTimer = 0;
update.c:	if(wch->position==POS_SLEEPING && IS_SET(wch->imm_flags,IMM_SLEEP))
update.c:		wch->position=POS_STANDING;
update.c:	if (IS_AFFECTED(wch,AFF_RAGE) && IS_AWAKE(wch) && !wch->fighting &&
update.c:		!(wch->desc == NULL && !IS_NPC(wch)))
update.c:	for ( vch = wch->in_room->people; vch != NULL; vch = vch_next)
update.c:		vch_next = vch->next_in_room;
update.c:		if (is_same_cabal(wch,vch) && wch->in_room->cabal != CABAL_HORDE)
update.c:		do_murder(wch,vch->name);
update.c:	if (!IS_NPC(wch) && is_affected(wch,gsn_divine_frenzy) && IS_AWAKE(wch) && !wch->fighting)
update.c:		for(vch = wch->in_room->people;vch != NULL; vch = vch_next)
update.c:			vch_next = vch->next_in_room;
update.c:			do_murder(wch,vch->name);
update.c:	if (is_affected(wch,gsn_mark_of_wrath) && IS_AWAKE(wch) && !wch->fighting
update.c:		&& !(wch->desc == NULL && !IS_NPC(wch))) {
update.c:		paf = affect_find(wch->affected,gsn_mark_of_wrath);
update.c:		for (vch = wch->in_room->people; vch; vch = vch_next) {
update.c:			vch_next = vch->next_in_room;
update.c:			if (paf->owner->ghost > 0)
update.c:			if (vch == paf->owner) {
update.c:				sprintf(buf, "%sCatching sight of the mark upon %s's brow, you are consumed with wrath!%s\n\r",get_char_color(wch,"lightred"),vch->name,END_COLOR(wch));
update.c:				do_murder(wch,vch->name);
update.c:	||   wch->level >= LEVEL_IMMORTAL
update.c:	||   wch->in_room == NULL
update.c:	||   wch->in_room->area->empty)
update.c:	for ( ch = wch->in_room->people; ch != NULL; ch = ch_next )
update.c:	    ch_next	= ch->next_in_room;
update.c:	    ||   !IS_SET(ch->act, ACT_AGGRESSIVE)
update.c:	    ||   IS_SET(ch->in_room->room_flags,ROOM_SAFE)
update.c:	    ||   ch->fighting != NULL
update.c:	    ||   ( IS_SET(ch->act, ACT_WIMPY) && IS_AWAKE(wch) )
update.c:	    for ( vch = wch->in_room->people; vch != NULL; vch = vch_next )
update.c:		vch_next = vch->next_in_room;
update.c:		&&   vch->level < LEVEL_IMMORTAL
update.c:		&&   ch->level >= vch->level - 5
update.c:		&&   ( !IS_SET(ch->act, ACT_WIMPY) || !IS_AWAKE(vch) )
update.c:		&&  (!IS_SET(ch->act,ACT_DIURNAL) || sun >= SUN_SET)
update.c:                &&  (!IS_SET(ch->act,ACT_NOCTURNAL) || (sun != SUN_RISE && sun != SUN_LIGHT))
update.c:	//long time = ch->played + (int) (current_time - ch->logon));
update.c:	result  = 20 + (float) (( (float)time_info.month + (float)1) / (float)12) + time_info.year - ch->pcdata->birth_date;
update.c:	result *= pc_race_table[ch->race].agemod;
update.c:	return (ch->played + (int) (current_time - ch->logon)) / 3600;
update.c:		0 - 20:	young
update.c:		21 - 120:	mature
update.c:		121 - 220:	middle aged
update.c:		221 - 300:	old
update.c:		301 - 350:	very old
update.c:		351 - 1000:	ancient
update.c:		1001 -  ~ :	worm-food
update.c:		name = "worm-food";
update.c:	return get_age_name_new((ch->played + (int) (current_time - ch->logon)),ch->race);
update.c:	ch_next = ch->next;
update.c:	if (ch->pcdata->death_status == HAS_DIED)
update.c:		ch->pcdata->death_timer -= 1;
update.c:		if (ch->pcdata->death_timer > 0)
update.c:			ch->pause = 0;
update.c:	    	cname = talloc_string(ch->true_name);
update.c:	if(ch->pcdata->roll_time + CHARACTER_TIME_DEATH < current_time)
update.c:	if (get_hours(ch) < ch->pcdata->death_time && !timedied)
update.c:	ch->pcdata->death_timer = 50;
update.c:	ch->pcdata->death_status = HAS_DIED;
update.c: * Random times to defeat tick-timing clients and players.
update.c:    if ( --pulse_iprog_pulse <= 0) {
update.c:        if(--pepe<=0)
update.c:    if ( --pulse_area     <= 0 ) {
update.c:    if ( --pulse_track <= 0) {
update.c:    if ( --pulse_mobile   <= 0 ) {
update.c:	if ( --pulse_room <= 0 ) {
update.c:	if ( --pulse_weather <= 0) {
update.c:	if ( --pulse_berus <= 0) {
update.c:	if ( --pulse_calabren <= 0) {
update.c:    if ( --pulse_violence <= 0 ) {
update.c:    if ( --pulse_point    <= 0 ) {
update.c:		pulse_point     = number_range( PULSE_TICK - 5, PULSE_TICK + 5);
update.c:/* This re-adjusts current mobs gold they carry.  No good. */
update.c:		ch_next = ch->next;
update.c:        	//Dev's super-fly cheap name hax!
update.c:        	if(!IS_NPC(ch) && strcmp(ch->true_name,ch->backup_true_name))
update.c:                	free_pstring(ch->true_name);
update.c:                	free_pstring(ch->name);
update.c:                	ch->name = palloc_string(ch->backup_true_name);
update.c:                	ch->true_name = palloc_string(ch->backup_true_name);
update.c:			sprintf(buf,"Error: %s has corrupt name.  Repaired.\n\r",ch->true_name);
update.c:		for (paf = ch->affected; paf; paf = paf_next) {
update.c:			paf_next = paf->next;
update.c:			if (paf->pulse_fun)
update.c:				(*paf->pulse_fun)(ch,paf);
update.c:		obj_next = obj->next;
update.c:		for (oaf = obj->affected; oaf; oaf = oaf_next) {
update.c:			oaf_next = oaf->next;
update.c:			if (oaf->pulse_fun)
update.c:				(*oaf->pulse_fun)(obj,oaf);
update.c:	for (room = top_affected_room; room; room = room->aff_next) {
update.c:		for (raf = room->affected; raf; raf = raf_next) {
update.c:			raf_next = raf->next;
update.c:			if (raf->pulse_fun)
update.c:				(*raf->pulse_fun)(room,raf);
update.c:		if (IS_SET(room->progtypes, RPROG_PULSE))
update.c:			(room->rprogs->pulse_prog) (room);
update.c:	for (area = area_first; area; area = area->next) {
update.c:		for (aaf = area->affected; aaf; aaf = aaf_next) {
update.c:			aaf_next = aaf->next;
update.c:			if (aaf->pulse_fun)
update.c:				(*aaf->pulse_fun)(area,aaf);
update.c:		if (IS_SET(area->progtypes, APROG_PULSE))
update.c:			(area->aprogs->pulse_prog) (area);
update.c:	room_next = room->aff_next;
update.c:	for ( paf = room->affected; paf != NULL; paf = paf_next )
update.c:	    paf_next	= paf->next;
update.c:		if ( paf->duration != 0)
update.c:			if (paf->tick_fun)
update.c:				(*paf->tick_fun) (room,paf);
update.c:	    if ( paf->duration > 0 )
update.c:			paf->duration--;
update.c:        else if ( paf->duration < 0 )
update.c:	for (room = top_affected_room; room ; room = room->aff_next ) {
update.c:		for ( af = room->affected; af != NULL; af = af->next )
update.c:			if (af->type == gsn_gravity_well)
update.c:		for(well = object_list; well!=NULL; well = well->next)
update.c:			if(well->item_type == ITEM_GRAVITYWELL && well->in_room && well->in_room == room)
update.c:			if(!room->exit[direction])
update.c:			droom = room->exit[direction]->u1.to_room;
update.c:				if(droom->people)
update.c:					for(victim = droom->people; victim != NULL; victim = v_next)
update.c:						v_next = victim->next_in_room;
update.c:						if(IS_NPC(victim) && IS_SET(victim->act,ACT_SENTINEL))
update.c:						if(!IS_NPC(victim) && is_safe_new(af->owner,victim,FALSE))
update.c:						if(victim->invis_level>LEVEL_HERO)
update.c:							SET_BIT(victim->act, ACT_WANDER);
update.c:                                if(!droom->exit[direction] || !droom->exit[direction]->u1.to_room ||
update.c:					droom->exit[direction]->u1.to_room->area!=droom->area ||
update.c:					IS_SET(droom->exit[direction]->exit_info, EX_CLOSED))
update.c:				droom = droom->exit[direction]->u1.to_room;
update.c:		for ( af = room->affected; af != NULL; af = af->next )
update.c:			if (af->type == gsn_vacuum)
update.c:		af->modifier++;
update.c:		if (af->modifier > 2)
update.c:				if (room->exit[i] && !IS_SET(room->exit[i]->exit_info, EX_CLOSED))
update.c:				for (vch = room->people; vch != NULL; vch = v_next)
update.c:					v_next = vch->next_in_room;
update.c:					if (!IS_NPC(vch) && is_safe_new(af->owner,vch,FALSE))
update.c:		for ( af = room->affected; af != NULL; af = af->next )
update.c:			if (af->type == gsn_earthquake)
update.c:		for (vch = room->people; vch != NULL; vch = v_next)
update.c:			v_next = vch->next_in_room;
update.c:			if (is_safe_new(af->owner,vch,FALSE))
update.c:			damage_new(af->owner,vch,dam,TYPE_UNDEFINED,DAM_BASH,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the falling debris*");
update.c:		for ( af = room->affected; af != NULL; af = af->next )
update.c:			if (af->type == gsn_tidalwave && af->location == APPLY_ROOM_NONE)
update.c:		if (af->modifier == 1)
update.c:			for (vch = room->people; vch != NULL; vch = vch->next_in_room)
update.c:			af->modifier--;
update.c:		else if (af->modifier == 0)
update.c:			for ( af2 = room->affected; af2 != NULL; af2 = af2->next )
update.c:				if (af2->type == gsn_tidalwave && af2->location == APPLY_ROOM_NOPE)
update.c:			for (vch = room->people; vch != NULL; vch = vch->next_in_room)
update.c:			for (vch = room->people; vch != NULL; vch = v_next)
update.c:				v_next = vch->next_in_room;
update.c:				if (vch == af->owner) continue;
update.c:				if (!IS_NPC(vch) && is_safe_new(af->owner,vch,FALSE))
update.c:				if (vch->in_room == af->owner->in_room)
update.c:					sprintf(buf,"Help! I'm being drowned by %s's tidal wave!",PERS(af->owner,vch));
update.c:				damage_new(af->owner,vch,dice(af2->modifier,10),gsn_tidalwave,DAM_DROWNING,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the tidal wave*");
update.c:			if (room->sector_type != SECT_WATER)
update.c:			for (vch = room->people; vch != NULL; vch = vch->next_in_room)
update.c:			for (vch = room->people; vch != NULL; vch = v_next)
update.c:				v_next = vch->next_in_room;
update.c:				if (vch == af->owner) continue;
update.c:				if (!IS_NPC(vch) && is_safe_new(af->owner,vch,FALSE))
update.c:				damage_new(af->owner,vch,dice(af2->modifier,10),gsn_tidalwave,DAM_BASH,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the crashing wave*");
update.c:			af->modifier--;
update.c:		if (room->people) {
update.c:		for (vch = room->people; vch != NULL; vch = v_next) {
update.c:			v_next = vch->next_in_room;
update.c:			for (af = vch->in_room->affected; af != NULL; af = af->next) {
update.c:				if (af->type == gsn_caustic_vapor)	break;
update.c:			if (!is_safe(vch,af->owner) && !is_affected(vch,gsn_neutralize)) {
update.c:					cvaf.level      =   af->level;
update.c:					cvaf.owner		=	af->owner;
update.c:				for (paf = vch->affected; paf != NULL; paf = paf->next) {
update.c:					if (paf->type == gsn_noxious_fumes) break;
update.c:				paf->modifier = URANGE(0,paf->modifier,5);
update.c:				paf->modifier++;
update.c:				cvaf.level      =   af->level;
update.c:				cvaf.owner		=	af->owner;
update.c:				switch(paf->modifier) {
update.c:						dam = dice(af->level/3,2);
update.c:						dam = dice(af->level/3,3);
update.c:						dam = dice(af->level/3,3);
update.c:						dam = dice(af->level/2,2);
update.c:						dam = dice(af->level/2,2);
update.c:						dam = dice(af->level/2,3);
update.c:				if (paf->modifier >= 3)
update.c:				damage_new(af->owner,vch,dam,af->type,DAM_POISON,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the noxious fumes*$");
update.c:	for(room = room_list; room != NULL; room = room->next_room)
update.c:	if(is_affected_area(room->area, gsn_cyclone))	
update.c:		for(aaf = room->area->affected;aaf;aaf = aaf->next) {
update.c:			if (aaf->type == gsn_cyclone)	break;
update.c:		for(obj = room->contents; obj!=NULL; obj = obj->next_content)
update.c:			if(!obj->in_room || obj->in_room != room)
update.c:			if(obj->weight>5 || number_percent()>((obj->weight+1)*3) || !IS_SET(obj->wear_flags,ITEM_TAKE))
update.c:                        if(!to_room || (!room->people && !to_room->people))
update.c:			if(room->people)
update.c:				act("The violent winds blow $p away!",room->people,obj,0,TO_ALL);
update.c:			obj->moved = TRUE;
update.c:			if(!to_room->people)
update.c:			act("The violent winds blow $p in!",to_room->people,obj,0,TO_ALL);
update.c:			victim = (CHAR_DATA*)get_random_ch(aaf->owner, to_room);
update.c:			if(victim == aaf->owner)
update.c:			dam = dice(obj->weight+1,8);
update.c:			damage_new(aaf->owner,victim,dam,skill_lookup("cyclone"),DAM_BASH,TRUE,HIT_UNBLOCKABLE,HIT_NOADD,HIT_NOMULT,"the flying debris*");
update.c:		for(victim = room->people; victim!=NULL; victim = v_next)
update.c:			v_next = victim->next_in_room;
update.c:			if(number_percent()>=chance || (IS_NPC(victim) && IS_SET(victim->act, ACT_SENTINEL)) ||
update.c:			victim->fighting || victim->invis_level>LEVEL_HERO)
update.c:			if ((to_room->sector_type == SECT_AIR && !IS_AFFECTED(victim,AFF_FLYING)) || to_room->area->area_type == ARE_UNOPENED) break;
update.c:	for(ch = char_list; ch!=NULL; ch=ch->next)
update.c:		for(obj = ch->carrying; obj!=NULL; obj=obj->next_content)
update.c:		obj_next = obj->next;
update.c:		/* items drifting/sinking in water -- Dioxide */
update.c:		if (obj->in_room && obj->in_room->sector_type == SECT_WATER && material_table[obj->pIndexData->material_index].mat_density == 0 && IS_SET(obj->wear_flags, ITEM_TAKE) && !IS_OBJ_STAT(obj,ITEM_NOPURGE))
update.c:			if (!((obj->item_type == ITEM_CORPSE_PC || obj->item_type == ITEM_CORPSE_NPC) && obj->contains))
update.c:			pexit = obj->in_room->exit[door];
update.c:			if (pexit != NULL && (to_room = pexit->u1.to_room) != NULL && to_room->sector_type == SECT_WATER)
update.c:				if (obj->in_room->people) {
update.c:					act("$p drifts $Tward.",obj->in_room->people,obj,direction,TO_ALL);
update.c:				if (to_room->people) {
update.c:					act("$p drifts in.",to_room->people,obj,0,TO_ALL);
update.c:		if (obj->in_room && (obj->in_room->sector_type == SECT_WATER || obj->in_room->sector_type == SECT_UNDERWATER) && (material_table[obj->pIndexData->material_index].mat_density > 0 || obj->item_type == ITEM_CORPSE_PC || obj->item_type == ITEM_CORPSE_NPC) && obj->item_type != ITEM_BOAT && IS_SET(obj->wear_flags, ITEM_TAKE) && !IS_OBJ_STAT(obj,ITEM_NOPURGE))
update.c:				if ((obj->item_type == ITEM_CORPSE_PC || obj->item_type == ITEM_CORPSE_NPC) && obj->contains == NULL)
update.c:				pexit = obj->in_room->exit[door];
update.c:				if (pexit != NULL && (to_room = pexit->u1.to_room) != NULL)
update.c:						if (obj->in_room->people && obj->in_room->sector_type == SECT_UNDERWATER) {
update.c:							act("$p floats $Tward.",obj->in_room->people,obj,direction,TO_ALL);
update.c:						if (to_room->sector_type == SECT_WATER && to_room->people)
update.c:							act("$p suddenly bobs up and surfaces.",to_room->people,obj,0,TO_ALL);
update.c:						else if (to_room->people)
update.c:							act("$p floats in from below.",to_room->people,obj,0,TO_ALL);
update.c:						if (obj->in_room->people && obj->in_room->sector_type == SECT_WATER)
update.c:							act("$p sinks beneath the surface.",obj->in_room->people,obj,0,TO_ALL);
update.c:						else if (obj->in_room->people && obj->in_room->sector_type == SECT_UNDERWATER) {
update.c:							act("$p floats $Tward.",obj->in_room->people,obj,direction,TO_ALL);
update.c:						if (to_room->people)
update.c:							act("$p sinks in from above.",to_room->people,obj,0,TO_ALL);
update.c:		if ((obj->in_room != NULL && obj->in_room->area->nplayer > 0) || 
update.c:				(obj->carried_by && obj->carried_by->in_room && obj->carried_by->in_room->area->nplayer > 0))
update.c:			if(IS_SET(obj->progtypes, IPROG_PULSE))
update.c:				(obj->pIndexData->iprogs->pulse_prog) (obj,isTick);
update.c:	if(!IS_NPC(ch) || !ch->fighting || ch->pIndexData->cast_spell[0]==NULL)
update.c:		if(ch->pIndexData->cast_spell[i]!=NULL)
update.c:	sn = skill_lookup(ch->pIndexData->cast_spell[i]);
update.c:	victim = ch->fighting;
update.c:		for(victim = ch->in_room->people; victim != NULL; victim = victim->next_in_room)
update.c:			if(victim && !IS_NPC(victim) && victim->fighting && victim->fighting==ch)
update.c:		for(vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
update.c:			if(!IS_NPC(vch) && vch->fighting == ch)
update.c:		victim = vch != NULL ? vch : ch->fighting;
update.c:	if(IS_SET(ch->act, ACT_CLERIC))
update.c:	else if (!IS_SET(ch->form,FORM_NOSPEECH))
update.c:	(*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim, TAR_CHAR_OFFENSIVE);
update.c:	for(ballot=ballot_first; ballot!=NULL; ballot=ballot->next)
update.c:		fprintf(fp,"#%s~\n",ballot->name);
update.c:		for(vote=ballot_first->first_vote; vote!=NULL; vote=vote->next)
update.c:			fprintf(fp,"%s %s %s~ %s~\n",vote->voter,vote->vote_for,vote->time,vote->ip);
update.c:	if(obj->weight < 10)
update.c:	if(obj->weight < 20)
update.c:	if(obj->weight < 30)
update.c:	if(obj->weight < 40)
update.c:		if(room->exit[(exit=number_range(0,5))])
update.c:			return room->exit[exit]->u1.to_room;
update.c:    for( vch = room->people; vch; vch = vch->next_in_room )
update.c:        if (!IS_NPC(vch) && !is_safe_new(ch,vch,FALSE) && vch->invis_level<LEVEL_HERO+1
update.c:	for( vch = room->people; vch; vch = vch->next_in_room ) {
update.c:		fprintf(fp,"%-12s %-4d %3.0f%%   ",capitalize(pc_race_table[i].name),affected,perc);
update.c:		if(i % 3 == 0 || i==MAX_PC_RACE-1)
update.c:		fprintf(fp,"%-12s %-4d %3.0f%%   ",capitalize(class_table[i].name),affected,perc);
update.c:		if(i>0 && ((i+1) % 3 == 0 || i==MAX_CLASS-1))
update.c:				fprintf(fp,"%-12s %-4d %3.0f%%   ",capitalize(cabal_table[i].name),affected,perc);
update.c:                if(i % 3 == 0 || i==MAX_CABAL-1)
update.c:	perc2 = ((total-affected) * 100)/total;
update.c:	fprintf(fp,"Male         %-4d %3.0f%%   Female       %-4d %3.0f%%\n\r",affected,perc,(total-affected),perc2);
update.c:	perc3 = ((total-affected-affected2) * 100)/total;
update.c:	fprintf(fp,"Good         %-4d %3.0f%%   Neutral      %-4d %3.0f%%   Evil         %-4d %3.0f%%\n\r",
update.c:	affected, perc, (total-affected-affected2), perc3, affected2, perc2);
update.c:		rune_next = rune->next;
update.c:		rune->duration--;
update.c:		if(rune->duration<=0)
update.c:			if(rune->end_fun)
update.c:				(*rune->end_fun) (rune);
warrior.c:	if(ch->Class()->GetIndex() != CLASS_WARRIOR)
warrior.c:			if(!IS_SET(ch->pcdata->styles, style_table[i].bit))
warrior.c:	if(!ch->pcdata->special)
warrior.c:	SET_BIT(ch->pcdata->styles, style_table[style].bit);
warrior.c:	ch->pcdata->special--;
warrior.c:	ch->pcdata->learned[skill_lookup(style_table[style].name)] = 2;
warrior.c:	if (ch->pcdata->style == 0)
warrior.c:		ch->pcdata->style = style;
warrior.c:			if(IS_SET(ch->pcdata->styles, style_table[i].bit)) {
warrior.c:		if(ch->pcdata->style)
warrior.c:			act("You are fighting in the style of the $t.",ch,style_table[ch->pcdata->style].name,0,TO_CHAR);
warrior.c:	if(ch->pcdata->learned[skill_lookup(style_table[style].name)] < 2)
warrior.c:		ch->pcdata->learned[skill_lookup(style_table[style].name)] = 2;
warrior.c:	if(!style || !IS_SET(ch->pcdata->styles, style_table[style].bit))
warrior.c:	if(ch->fighting)
warrior.c:	if (style == ch->pcdata->style)
warrior.c:	ch->pcdata->style = style;
warrior.c:	if ((victim = ch->fighting) == NULL)
warrior.c:			switch(weapon->value[0])
warrior.c:				weapon_name_lookup(weapon->value[0]),weapon_name_lookup(wield->value[0]));
warrior.c:					weapon_name_lookup(weapon->value[0]),weapon_name_lookup(wield->value[0]));
warrior.c:					weapon_name_lookup(weapon->value[0]),weapon_name_lookup(wield->value[0]));
warrior.c:				weapon_name_lookup(weapon->value[0]),weapon_name_lookup(wield->value[0]));
warrior.c:					weapon_name_lookup(weapon->value[0]),weapon_name_lookup(wield->value[0]));
warrior.c:					weapon_name_lookup(weapon->value[0]),weapon_name_lookup(wield->value[0]));
warrior.c:				act("$n attempts to entrap your weapon with $s $t, but fails.",ch,weapon_name_lookup(wield->value[0]),victim,TO_VICT);
warrior.c:				act("$n attempts to entrap $N's weapon with $s $t, but fails.",ch,weapon_name_lookup(wield->value[0]),victim,TO_NOTVICT);
warrior.c:			switch(weapon->value[0])
warrior.c:				act("You catch $N's $t between your own weapons but it won't budge!",ch,weapon_name_lookup(weapon->value[0]),victim,TO_CHAR);
warrior.c:				act("$n catches your $t between $s two weapons but it won't budge!",ch,weapon_name_lookup(weapon->value[0]),victim,TO_VICT);
warrior.c:				act("$n catches $N's $t between $s two weapons but it won't budge!",ch,weapon_name_lookup(weapon->value[0]),victim,TO_NOTVICT);
warrior.c:				act("You catch $N's $t between your own weapons and with a rapid twist, jerk it free!",ch,weapon_name_lookup(weapon->value[0]),victim,TO_CHAR);
warrior.c:				act("$n catches your $t between $s two weapons, and with a sudden twist, sends it flying!",ch,weapon_name_lookup(weapon->value[0]),victim,TO_VICT);
warrior.c:				act("$n catches $N's $t between $s two weapons, and with a sudden twist, sends it flying!",ch,weapon_name_lookup(weapon->value[0]),victim,TO_NOTVICT);
warrior.c:		obj_to_room(weapon, victim->in_room);
warrior.c:		if(IS_NPC(victim) && victim->wait == 0 && can_see_obj(victim,weapon))
warrior.c:	if ((victim = ch->fighting) == NULL)
warrior.c:	if (victim->legs <= 0)
warrior.c:	else if (victim->legs <= 1)
warrior.c:	if (victim->size < ch->size - 1)
warrior.c:		switch(weapon->value[0])
warrior.c:			af.duration = ch->level/8;
warrior.c:			af.level = ch->level;
warrior.c:			switch(weapon->value[0])
warrior.c:					af.modifier = -(ch->level/6);
warrior.c:					victim->move = UMAX(victim->move / 2, 0);
warrior.c:					af.modifier = -(ch->level/8);
warrior.c:					af2.duration = ch->level/15;
warrior.c:					af2.level = ch->level;
warrior.c:					af.modifier = -(ch->level/8);
warrior.c:					af2.duration = ch->level/15;
warrior.c:					af2.level = ch->level;
warrior.c:					af.modifier = -(ch->level/6);
warrior.c:					victim->move = UMAX(victim->move / 2, 0);
warrior.c:					af.modifier = -(ch->level/6);
warrior.c:					victim->move = UMAX(victim->move / 2, 0);
warrior.c:					af.modifier = -(ch->level/7);
warrior.c:					victim->move = UMAX(victim->move - ch->level/2, 0);
warrior.c:					af.modifier = -(ch->level/5);
warrior.c:			af.duration = ch->level/8;
warrior.c:			af.level = ch->level;
warrior.c:			af.modifier = -1;
warrior.c:			af.duration = ch->level/8;
warrior.c:			af.level = ch->level;
warrior.c:			switch(weapon->value[0])
warrior.c:					af.modifier = -(ch->level/10);
warrior.c:					af.modifier = -(ch->level/12);
warrior.c:					af.modifier = -(ch->level/12);
warrior.c:					af.modifier = -(ch->level/10);
warrior.c:					af.modifier = -(ch->level/10);
warrior.c:					af.modifier = -(ch->level/12);
warrior.c:					af.modifier = -(ch->level/8);
warrior.c:	if ((victim = ch->fighting) == NULL)
warrior.c:	if (victim->arms <= 0)
warrior.c:	else if (victim->arms <= 1)
warrior.c:	if (victim->size > ch->size + 1)
warrior.c:		switch(weapon->value[0])
warrior.c:			af.duration = ch->level/8;
warrior.c:			af.level = ch->level;
warrior.c:			switch(weapon->value[0])
warrior.c:					af.modifier = -(ch->level/7);
warrior.c:					af.duration = ch->level/8;
warrior.c:					af.level = ch->level;
warrior.c:					af.modifier = -1;
warrior.c:					af.modifier = -(ch->level/8);
warrior.c:					af2.duration = ch->level/15;
warrior.c:					af2.level = ch->level;
warrior.c:					af.modifier = -(ch->level/8);
warrior.c:					af2.duration = ch->level/10;
warrior.c:					af2.level = ch->level;
warrior.c:					af.modifier = -(ch->level/7);
warrior.c:					af.duration = ch->level/8;
warrior.c:					af.level = ch->level;
warrior.c:					af.modifier = -1;
warrior.c:					af.modifier = -(ch->level/7);
warrior.c:					af.duration = ch->level/8;
warrior.c:					af.level = ch->level;
warrior.c:					af.modifier = -1;
warrior.c:			af.duration = ch->level/8;
warrior.c:			af.level = ch->level;
warrior.c:			switch(weapon->value[0])
warrior.c:					af.modifier = -(ch->level/7);
warrior.c:					af.modifier = -(ch->level/5);
warrior.c:					af.modifier = -(ch->level/6);
warrior.c:					af.modifier = -(ch->level/7);
warrior.c:					af.modifier = -(ch->level/7);
warrior.c:	if ((victim = ch->fighting) == NULL)
warrior.c:	if (victim->size > ch->size + 1)
warrior.c:		switch(weapon->value[0])
warrior.c:			af.level = ch->level;
warrior.c:	if ((victim = ch->fighting) == NULL)
warrior.c:		switch(weapon->value[0])
warrior.c:				affect = ch->level/3;
warrior.c:				affect = ch->level/4;
warrior.c:				affect = ch->level/4;
warrior.c:				affect = ch->level/7;
warrior.c:			af.level = ch->level;
warrior.c:	for (paf = ch->affected; paf != NULL; paf = paf->next)
warrior.c:		if (paf->type == gsn_posture) {
warrior.c:			modifier = paf->modifier;
warrior.c:	af.level     = ch->level;
warrior.c:	af.duration  = -1;
warrior.c:	if (style_table[ch->pcdata->style].bit != STYLE_DUELIST)
warrior.c:	if ((victim = ch->fighting) == NULL)
warrior.c:		if (victim->balance >= 40)
warrior.c:		else if (victim->balance >= 30)
warrior.c:		victim->balance += 10;
warrior.c:		af.level     = ch->level;
warrior.c:		af.duration  = -1;
warrior.c:	int success=0,skill,special=100,duration=ch->level;
warrior.c:	CHAR_DATA *victim = ch->fighting;
warrior.c:	if(weapon && (weapon->weight >= 15)) {
warrior.c:		switch(weapon->value[0]) {
warrior.c:				duration = ch->level/25;
warrior.c:				duration = ch->level/25;
warrior.c:				duration = ch->level/25;
warrior.c:				duration = ch->level/40;
warrior.c:		if(weapon->weight < 15)
warrior.c:		if((success == 1) && number_percent() < (.4*skill*(1 + weapon->weight/200)*(1+(get_curr_stat(ch,STAT_STR) - 20)/10))) {
warrior.c:				af.level = ch->level;
warrior.c:	CHAR_DATA *victim=ch->fighting;
warrior.c:	if(weapon->weight > skirmisher_max_weapweight(ch))
warrior.c:	switch(weapon->value[0])
warrior.c:			af.modifier = -ch->level/12;
warrior.c:			af.duration = ch->level/12;
warrior.c:			af.modifier = -ch->level/10;
warrior.c:			af.duration = ch->level/10;
warrior.c:			af.modifier = -ch->level/12;
warrior.c:			af.duration = ch->level/10;			
warrior.c:		af.level = ch->level;
warrior.c:	if((victim = ch->fighting) == NULL)
warrior.c:	if(weapon->weight < 15)
warrior.c:	switch(weapon->value[0]) {
warrior.c:                (!ch->fighting || !victim->fighting)) {
warrior.c:	if(victim->position <= POS_RESTING)
warrior.c:		if(!is_affected(victim,gsn_impale) && number_percent() < 20 - (material_table[weapon->pIndexData->material_index].mat_hardness * 5)) {
warrior.c:				af.level = ch->level;
warrior.c:				af.duration = ch->level/9;
warrior.c:				af.modifier = -ch->level/8;
warrior.c:			iaf.duration = -1;
warrior.c:			iaf.level = ch->level;
warrior.c:				af.level = ch->level;
warrior.c:				af.duration = ch->level/8;
warrior.c:				af.modifier = -ch->level/8;
warrior.c:	if (weapon->weight > skirmisher_max_weapweight(ch))
warrior.c:		return act("That $t is too heavy to be hurled properly.",ch,(char*)weapon_name_lookup(weapon->value[0]),0,TO_CHAR);
warrior.c:	if ((direction = direction_lookup(arg2)) == -1) {
warrior.c:		pexit = ch->in_room->exit[direction];
warrior.c:		if (IS_SET(pexit->exit_info,EX_CLOSED)) {
warrior.c:		to_room = pexit->u1.to_room;
warrior.c:	victroom = victim->in_room;
warrior.c:			dirname,(char*)weapon_name_lookup(weapon->value[0]));
warrior.c:		sprintf(buf,"$n suddenly hurls $s %s %sward!", (char*)weapon_name_lookup(weapon->value[0]), dirname);
warrior.c:				(char*)weapon_name_lookup(weapon->value[0]),dirname);
warrior.c:		if(!IS_NPC(victim) && victim->fighting == NULL)
warrior.c:		if (number_percent() < (85 - 7*(26 - get_curr_stat(ch,STAT_DEX)))*skill)
warrior.c:			one_hit_new(ch,victim,gsn_hurl,HIT_NOSPECIALS,HIT_UNBLOCKABLE,HIT_NOADD,100*(int)(0.67 + (float)ch->level/30),NULL);
warrior.c:				af.level = ch->level;
warrior.c:				(char*)weapon_name_lookup(weapon->value[0]),victim,TO_CHAR);
warrior.c:				(char*)weapon_name_lookup(weapon->value[0]),victim,TO_VICT);
warrior.c:				(char*)weapon_name_lookup(weapon->value[0]),victim,TO_NOTVICT);
warrior.c:		if(!IS_NPC(victim) && victim->fighting == NULL)
warrior.c:		if (number_percent() < (100 - 7*(26 - get_curr_stat(ch,STAT_DEX)))*skill)
warrior.c:			one_hit_new(ch,victim,gsn_hurl,HIT_NOSPECIALS,HIT_UNBLOCKABLE,HIT_NOADD,100*(1 + ch->level/20),NULL);
warrior.c:				af.level = ch->level;
warrior.c:		if((victim = ch->fighting) == NULL) {
warrior.c:	if(weapon->weight < 15)
warrior.c:	if(victim->size > ch->size + 1) {
warrior.c:	if(ch->fighting == NULL && is_affected(victim,gsn_overhead)) {
warrior.c:	switch(weapon->value[0]) {
warrior.c:	special = skill * (int)((float)1 + (float)((float)ch->size - (float)victim->size)/(float)4) * (float)((float)1 + (float)(weapon->weight)/(float)200);
warrior.c:		if(ch->fighting == NULL) {
warrior.c:				af.level = ch->level;
warrior.c:				switch(weapon->value[0]) {
warrior.c:						victim->position = POS_SLEEPING;
warrior.c:						victim->position = POS_SLEEPING;
warrior.c:						victim->position = POS_SLEEPING;
warrior.c:			af.level = ch->level;
warrior.c:			switch(weapon->value[0]) {
warrior.c:					af.duration = ch->level/8;
warrior.c:					af.duration = ch->level/12;
warrior.c:	if(!IS_NPC(victim) && ((ch->fighting == NULL) ||
warrior.c:	(victim->fighting == NULL))) {
warrior.c:	dam = (int)((float)ch->max_hit*.2);
warrior.c:	if((af=affect_find(ch->affected,gsn_impale)) && af->owner)
warrior.c:		owner = af->owner;
warrior.c:            (ch->level < skill_table[gsn_exchange].skill_level[ch->Class()->GetIndex()] &&
warrior.c:        if (!ch->fighting)
warrior.c:        victim = ch->fighting;
warrior.c:        AC=100-AC;
warrior.c:			total_weight += eq->weight;
warrior.c:	if (ch->fighting) {
warrior.c:	if (ch->size < victim->size - 1) {
warrior.c:		avoid += 5 * (get_curr_stat(ch,STAT_DEX) - 20);
warrior.c:		dam = 10 + dice(armor_weight(ch)/15,(int)(0.4*(float)ch->level));
warrior.c:		damage(ch,victim,number_range(dam-1,dam+1),gsn_charge,DAM_BASH,TRUE);
warrior.c:	if(!IS_NPC(ch) && !style_check(gsn_ease, ch->pcdata->style)) {
warrior.c:	if ((victim = ch->fighting) == NULL) {
warrior.c:	if (ch->size < victim->size) {
warrior.c:	if (ch->size > victim->size + 1) {
warrior.c:	chance += 5 * (ch->size - victim->size);
warrior.c:	chance -= get_curr_stat(victim,STAT_DEX);
warrior.c:	if (IS_NPC(victim)) chance += (ch->level - victim->level) * 2;
warrior.c:		dam = (int)((float)dice(ch->level/4,4) + ((float)weight/(float)20));
warrior.c:		if (pow(2,ch->size - victim->size) * weight > 250) 
warrior.c:	if ((victim = ch->fighting) == NULL) {
warrior.c:		bracemod = (float) 1 - (float) ac / (float) 400;
warrior.c:		ch->dam_mod *= bracemod;
warrior.c:	ch->dam_mod /= *braceptr;
warrior.c:	CHAR_DATA *victim = ch->fighting;
warrior.c:	if (weapon->value[0] == WEAPON_DAGGER || weapon->value[0] == WEAPON_WHIP || weapon->value[0] == WEAPON_EXOTIC)
warrior.c:	if (weapon->weight < 15)
warrior.c:		if (material_table[weapon->pIndexData->material_index].mat_hardness >= material_table[wield->pIndexData->material_index].mat_hardness)
warrior.c:			switch(weapon->value[0])
warrior.c:		switch(wield->value[0])
warrior.c://		if (material_table[weapon->pIndexData->material_index].mat_hardness >= material_table[wield->pIndexData->material_index].mat_hardness)
warrior.c:			switch(weapon->value[0])
warrior.c:					switch(wield->value[0])
warrior.c:					switch(wield->value[0])
warrior.c:					switch(wield->value[0])
warrior.c:					switch(wield->value[0])
warrior.c:					switch(weapon->value[0])
warrior.c:					switch(weapon->value[0])
warrior.c:					switch(weapon->value[0])
warrior.c:	chance *= (130 - 20 * material_table[wield->pIndexData->material_index].mat_hardness);
warrior.c:		act(chfail,ch,(char*)weapon_name_lookup(wield->value[0]),victim,TO_CHAR);
warrior.c:		act(victfail,ch,(char*)weapon_name_lookup(wield->value[0]),victim,TO_VICT);
warrior.c:		act(nvictfail,ch,(char*)weapon_name_lookup(wield->value[0]),victim,TO_NOTVICT);
warrior.c:	act(chsuc,ch,(char*)weapon_name_lookup(wield->value[0]),victim,TO_CHAR);
warrior.c:	act(victsuc,ch,(char*)weapon_name_lookup(wield->value[0]),victim,TO_VICT);
warrior.c:	act(nvictsuc,ch,(char*)weapon_name_lookup(wield->value[0]),victim,TO_NOTVICT);
warrior.c:		if ((victim = ch->fighting) == NULL) {
warrior.c:	if((wield->value[0]==WEAPON_WHIP) || (dualwield->value[0]==WEAPON_WHIP)) {
warrior.c:	if(wield->weight > skirmisher_max_weapweight(ch) || dualwield->weight > skirmisher_max_weapweight(ch)) {
warrior.c:	if (!IS_NPC(victim) && ((ch->fighting == NULL) ||
warrior.c:		(victim->fighting == NULL)))
warrior.c:	chance-=5 * (25-chdex);
warrior.c:	for (vch = ch->in_room->people; vch != NULL; vch = vch_next) 
warrior.c:		vch_next = vch->next_in_room;
warrior.c:				(((can_see(ch,vch)) || (vch->fighting!=NULL))))) 
warrior.c:					if ((victim->pIndexData->vnum==vch->pIndexData->vnum)) 
warrior.c:				(((can_see(ch,vch)) || (vch->fighting!=NULL))))) 
warrior.c:				if ((victim->pIndexData->vnum==vch->pIndexData->vnum)) 
warrior.c:	if (wield->weight < 15)	
warrior.c:	if ((dual = get_eq_char(ch, WEAR_DUAL_WIELD)) != NULL && dual->weight >= 15)
warrior.c:		ch->batter += 5;
warrior.c:		ch->batter += 3;
warrior.c:	for (af = ch->affected; af != NULL; af = af->next )
warrior.c:		if (type == 0 && af->type == gsn_entwine && af->modifier == 0)
warrior.c:		else if (type == 1 && af->type == gsn_entwine && af->modifier == 1)
warrior.c:		else if (type == 2 && af->type == gsn_entwine && af->location == APPLY_DEX)
warrior.c:	if ((victim = ch->fighting) == NULL) {
warrior.c:		skill *= 60 + 2 * (get_curr_stat(ch,STAT_DEX) - get_curr_stat(victim,STAT_DEX));
warrior.c:		skill *= 40 + 2 * (get_curr_stat(ch,STAT_DEX) - get_curr_stat(victim,STAT_DEX));
warrior.c:	if (arm && victim->arms < 1)
warrior.c:	if (leg && victim->legs < 1)
warrior.c:	if (!IS_NPC(victim) && ((ch->fighting == NULL) || (victim->fighting == NULL))) {
warrior.c:		af.duration = -1;
warrior.c:		af.level = ch->level;
warrior.c:			af.modifier = -(ch->level/15);
warrior.c:		af.duration = -1;
warrior.c:		af.level = ch->level;
warrior.c:	if (!ch->fighting && !victim->fighting)
warrior.c:	for (af = ch->affected; af != NULL; af = af->next )
warrior.c:		if (type == 0 && af->type == gsn_entwine && af->modifier == 0)
warrior.c:		else if (type == 1 && af->type == gsn_entwine && af->modifier == 1)
warrior.c:		else if (type == 2 && af->type == gsn_entwine && af->location == APPLY_DEX)
warrior.c:	guy = af->owner;
warrior.c:		for (af2 = guy->affected; af2 != NULL; af2 = af2->next )
warrior.c:			if (af2->type == gsn_entwine && af2->owner == ch)
warrior.c:	if (number_percent() < ((get_curr_stat(ch,STAT_STR) - 13) * 8) || type == 0)
warrior.c:			act("With a sudden jerk of your wrist, you uncoil your whip, freeing $N's $t!",ch,af2->modifier ==  1 ? "arm" : af2->location == APPLY_DEX ? "leg" : "",guy,TO_CHAR);
warrior.c:			act("With a sudden jerk of $n's wrist, $e uncoils $s whip, freeing your $t!",ch,af2->modifier ==  1 ? "arm" : af2->location == APPLY_DEX ? "leg" : "",guy,TO_VICT);
warrior.c:			act("With a sudden jerk of $n's wrist, $e uncoils $s whip, freeing $N's $t!",ch,af2->modifier ==  1 ? "arm" : af2->location == APPLY_DEX ? "leg" : "",guy,TO_NOTVICT);
warrior.c:		for (af = ch->affected; af != NULL; af = af->next )
warrior.c:			if (af->type == gsn_entwine && af->modifier == 0)
warrior.c:		guy = af->owner;
warrior.c:		for (af2 = guy->affected; af2 != NULL; af2 = af2->next )
warrior.c:			if (af2->type == gsn_entwine && af2->owner == ch)
warrior.c:		if (af2->location == APPLY_DEX)
warrior.c:		else if (af2->modifier == 1)
warrior.c: 			if ((dir = direction_lookup(argument)) == -1)
warrior.c:			pexit = ch->in_room->exit[dir];
warrior.c:			if (number_percent() < (skill * 0.9) && !(IS_NPC(guy) && IS_SET(guy->act,ACT_SENTINEL)))
warrior.c:				to_room = pexit->u1.to_room;
warrior.c:				act("$n enters from $t, pulling along a tightly-entwined $N with him!",ch,direction,guy,TO_NOTVICT);
warrior.c:				if (guy->in_room == ch->in_room && !ch->fighting && !guy->fighting)
warrior.c:	if (argument[0] == '\0' && !(victim = ch->fighting))
warrior.c:		act("$N appears to be resistant to $t.",ch,(char*)get_assess_line(victim->res_flags,skill),victim,TO_CHAR);
warrior.c:		act("$N appears to be immune to $t.",ch,(char*)get_assess_line(victim->imm_flags,skill),victim,TO_CHAR);
warrior.c:		act("$N appears to be vulnerable to $t.",ch,(char*)get_assess_line(victim->vuln_flags,skill),victim,TO_CHAR);
warrior.c:		dammod = victim->dam_mod;
warrior.c:		if (victim->dam_mod < 20)
warrior.c:		else if (victim->dam_mod <= 40)
warrior.c:		else if (victim->dam_mod <= 60)
warrior.c:		else if (victim->dam_mod <= 80)
warrior.c:		else if (victim->dam_mod <= 99)
warrior.c:		else if (victim->dam_mod <= 100)
warrior.c:	int matindex = exposed->pIndexData->material_index;
warrior.c:	if(exposed->item_type != ITEM_ARMOR)
warrior.c:		avgac += exposed->value[i];
warrior.c:	chance += (material_table[chwield->pIndexData->material_index].mat_hardness - material_table[matindex].mat_hardness) * 8;
warrior.c:	chance -= avgac * 7;
warrior.c:			exposed->value[i] = UMAX(0, exposed->value[i]-number_range(1,2));	
warrior.c:	if ( ( victim = ch->fighting ) == NULL )
warrior.c:	if (head && !str_cmp(race_table[victim->race].name,"minotaur")) {
warrior.c:	if ((!str_cmp(race_table[victim->race].name,"human")) ||
warrior.c:		(!str_cmp(race_table[victim->race].name,"dwarf")) ||
warrior.c:		(!str_cmp(race_table[victim->race].name,"elf")) ||
warrior.c:		(!str_cmp(race_table[victim->race].name,"drow")) ||
warrior.c:		(!str_cmp(race_table[victim->race].name,"planar")) ||
warrior.c:		(!str_cmp(race_table[victim->race].name,"imp")) ||
warrior.c:		(!str_cmp(race_table[victim->race].name,"halfling")) ||
warrior.c:		(!str_cmp(race_table[victim->race].name,"abyss")) ||
warrior.c:		(!str_cmp(race_table[victim->race].name,"duergar")) ||
warrior.c:		(!str_cmp(race_table[victim->race].name,"celestial")) ||
warrior.c:		(!str_cmp(race_table[victim->race].name,"sidhe")) ||
warrior.c:		(!str_cmp(race_table[victim->race].name,"minotaur")))
warrior.c:			act(chsuc,ch,(char*)weapon_name_lookup(weapon->value[0]),victim,TO_CHAR);
warrior.c:			act(victsuc,ch,(char*)weapon_name_lookup(weapon->value[0]),victim,TO_VICT);
warrior.c:			act(nvictsuc,ch,(char*)weapon_name_lookup(weapon->value[0]),victim,TO_NOTVICT);
warrior.c:				act(chspe,ch,(char*)weapon_name_lookup(wield->value[0]),victim,TO_CHAR);
warrior.c:				act(victspe,ch,(char*)weapon_name_lookup(wield->value[0]),victim,TO_VICT);
warrior.c:				act(nvictspe,ch,(char*)weapon_name_lookup(wield->value[0]),victim,TO_NOTVICT);
warrior.c:					obj_to_room( wield, victim->in_room );
warrior.c:					if (IS_NPC(victim) && victim->wait == 0 && can_see_obj(victim,wield))
warrior.c:			victim->position = POS_RESTING;
warrior.c:		CHAR_DATA *victim = ch->fighting;
warrior.c:	chance-=40;
warrior.c:		chance-=15;
warrior.c:				obj_to_room(offhand,victim->in_room);
warrior.c: 	if(ch->fighting) {
warrior.c:		if((where = direction_lookup(argument)) == -1) {
warrior.c:  			victim=ch->fighting;
warrior.c:  		skill=(skill - (skill/3));
warrior.c: 	if((where = direction_lookup(dir)) == -1)
warrior.c: 	if ((pexit = ch->in_room->exit[where]) == NULL)
warrior.c:		&& (ch->fighting == NULL || victim->fighting == NULL)) {
warrior.c:	if (IS_NPC(victim) && pexit->u1.to_room 
warrior.c:		&& victim->pIndexData->restrict_low != -1 
warrior.c:		&& victim->pIndexData->restrict_high != 65535)
warrior.c:		if(pexit->u1.to_room->vnum < victim->pIndexData->restrict_low
warrior.c:		   || pexit->u1.to_room->vnum > victim->pIndexData->restrict_high)
warrior.c:	if (IS_NPC(victim) && IS_SET(victim->act,ACT_SENTINEL))
warrior.c:		to_room = pexit->u1.to_room;
warrior.c:		if(victim->in_room != ch->in_room)
warrior.c:	if(victim->in_room == ch->in_room && !ch->fighting && !victim->fighting)
warrior.c:	if(ch->fighting)
warrior.c: 	if((where = direction_lookup(dir)) == -1)
warrior.c:	if ((pexit = ch->in_room->exit[where]) == NULL)
warrior.c:	to_room = pexit->u1.to_room;
warrior.c:		if(ch->in_room != to_room)
warrior.c:		|| ( ch->level < skill_table[gsn_concuss].skill_level[ch->Class()->GetIndex()]
warrior.c:	if (!ch->fighting)
warrior.c:	victim = ch->fighting;
warrior.c:	size=victim->size-ch->size;
warrior.c:	chance += (ch->level - victim->level);
warrior.c:		chance -= 20*size;
warrior.c:		chance -= 20;
warrior.c:		chance -= 20;
warrior.c:	af.level = ch->level;
warrior.c:		sprintf(weapon_name,"%s",weapon_name_lookup(weapon->value[0]));
warrior.c:	if(!ch->fighting)
warrior.c:	if((direction = direction_lookup(arg))<0 || !ch->in_room->exit[direction])
warrior.c:	pexit = ch->in_room->exit[direction];
warrior.c:	to_room = pexit->u1.to_room;
warrior.c:	ROOM_INDEX_DATA *start = ch->in_room;
warrior.c:	if (ch->in_room != start)
warrior.c:		victim = ch->fighting;
warrior.c:	if(ch->fighting && !IS_NPC(ch))
warrior.c:	if(ch->leader)
warrior.c:        for ( gch = char_list; gch != NULL; gch = gch->next )
warrior.c:		for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
warrior.c:			vch_next = vch->next_in_room;
warrior.c:                	if(vch->Class()->GetIndex() == CLASS_WARRIOR)
warrior.c:						if(!IS_NPC(vch) && vch->pcdata->style == style_lookup("duelist"))
warrior.c:				if(vch->Class()->ctype == CLASS_CASTER ||
warrior.c:				   vch->Class()->ctype == CLASS_COMMUNER)
warrior.c:				vch->leader = NULL;
warrior.c:        || ch->level < skill_table[gsn_leadership].skill_level[ch->Class()->GetIndex()])
warrior.c:		for (to = ch->in_room->people; to != NULL; to = to->next_in_room )
warrior.c:		if (ch->mana < 50)
warrior.c:        	ch->mana -= 25;
warrior.c:			af.duration = ch->level;
warrior.c:			af.duration = ch->level / 3;
warrior.c:			af.level = ch->level;
warrior.c:			to = ch->in_room->people;
warrior.c:			for(; to != NULL; to = to->next_in_room )
warrior.c:        			af.modifier = ch->level/5;
warrior.c:        			af.duration = ch->level;
warrior.c:					af.duration = ch->level / 3;
warrior.c:					af.level = ch->level;
warrior.c:        			af.modifier = -(ch->level/5);
warrior.c:			ch->mana -= 50;
warrior.c:	if(ch->leader == NULL || ch->leader == ch)
warrior.c:	for ( af = ch->affected; af != NULL; af = af_next )
warrior.c:		af_next=af->next;
warrior.c:		if(af->type == gsn_leadership)
warrior.c:	int modifier = -1;
warrior.c:	for (paf = ch->affected; paf != NULL; paf = paf->next)
warrior.c:		if (paf->type == gsn_outflank) {
warrior.c:			modifier = paf->modifier;
warrior.c:		if ((type = check_outflank(ch)) != -1)
warrior.c: 	if ((type = direction_lookup(argument)) == -1 && !IS_NPC(ch))
warrior.c:		type = -2;
warrior.c:			if ((pexit = ch->in_room->exit[dir]) != NULL)
warrior.c:				type = -1;
warrior.c:		if (type == -2)
warrior.c:		while (type == -1)
warrior.c:			if ((pexit = ch->in_room->exit[dir]) != NULL)
warrior.c:	af.level     = ch->level;
warrior.c:	af.duration  = -1;
warrior.c:	for (victim = ch->in_room->people; victim != NULL; victim = victim->next_in_room)
warrior.c:			switch(weapon->value[0])
zealot.c:		return -1;
zealot.c:	for (af = ch->affected; af != NULL; af = af->next)
zealot.c:		if(af->type == gsn_burning_vision)
zealot.c:	return ((20 - af->duration) / af->modifier);
zealot.c:		for (maf = victim->affected; maf != NULL; maf = maf->next)
zealot.c:			if(maf->type == gsn_burning_vision)
zealot.c:		mod = maf->modifier;
zealot.c:		mod--;
zealot.c:			maf->modifier = mod;
zealot.c:		for (caf = ch->affected; caf != NULL; caf = caf->next)
zealot.c:	        if(caf->type == gsn_burning_vision)
zealot.c:		SET_BIT(caf->bitvector, AFF_BLIND);
zealot.c:		SET_BIT(ch->affected_by,AFF_BLIND);
zealot.c:		&& (paf = affect_find(victim->affected,gsn_divine_ward)) != NULL
zealot.c:		&& paf->owner == ch)
zealot.c:	if (ch->fighting && saves_spell(level + 9, victim, DAM_HOLY)) {
